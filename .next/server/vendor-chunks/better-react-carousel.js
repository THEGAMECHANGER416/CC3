/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-react-carousel";
exports.ids = ["vendor-chunks/better-react-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/better-react-carousel/dist/bundle.js":
/*!***********************************************************!*\
  !*** ./node_modules/better-react-carousel/dist/bundle.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nfunction _interopDefault(ex) {\n    return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n}\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar React__default = _interopDefault(React);\nvar styled = _interopDefault(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/better-react-carousel/node_modules/styled-components/dist/styled-components.esm.js\"));\nvar PropTypes = _interopDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar smoothscroll = _interopDefault(__webpack_require__(/*! smoothscroll-polyfill */ \"(ssr)/./node_modules/smoothscroll-polyfill/dist/smoothscroll.js\"));\nvar debounce = _interopDefault(__webpack_require__(/*! lodash.debounce */ \"(ssr)/./node_modules/lodash.debounce/index.js\"));\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar ButtonWrapper = styled.div.withConfig({\n    displayName: \"ArrowButton__ButtonWrapper\",\n    componentId: \"sc-1ikb0hj-0\"\n})([\n    \"@media screen and (max-width:\",\n    \"px){display:none;}\"\n], function(_ref) {\n    var mobileBreakpoint = _ref.mobileBreakpoint;\n    return mobileBreakpoint;\n});\nvar Button = styled.span.withConfig({\n    displayName: \"ArrowButton__Button\",\n    componentId: \"sc-1ikb0hj-1\"\n})([\n    \"position:absolute;top:calc(50% - 17.5px);height:35px;width:35px;background:#fff;border-radius:50%;box-shadow:0 0 5px 0 #0009;z-index:10;cursor:pointer;font-size:10px;opacity:0.6;transition:opacity 0.25s;left:\",\n    \";right:\",\n    \";&:hover{opacity:1;}&::before{content:'';height:10px;width:10px;background:transparent;border-top:2px solid #000;border-right:2px solid #000;display:inline-block;position:absolute;top:50%;left:50%;transform:\",\n    \";}\"\n], function(_ref2) {\n    var type = _ref2.type;\n    return type === \"prev\" ? \"5px\" : \"initial\";\n}, function(_ref3) {\n    var type = _ref3.type;\n    return type === \"next\" ? \"5px\" : \"initial\";\n}, function(_ref4) {\n    var type = _ref4.type;\n    return type === \"prev\" ? \"translate(-25%, -50%) rotate(-135deg)\" : \"translate(-75%, -50%) rotate(45deg)\";\n});\nvar ArrowButton = function ArrowButton(_ref5) {\n    var type = _ref5.type, _ref5$mobileBreakpoin = _ref5.mobileBreakpoint, mobileBreakpoint = _ref5$mobileBreakpoin === void 0 ? 1 : _ref5$mobileBreakpoin, _ref5$hidden = _ref5.hidden, hidden = _ref5$hidden === void 0 ? false : _ref5$hidden, CustomBtn = _ref5.CustomBtn, onClick = _ref5.onClick;\n    return /*#__PURE__*/ React__default.createElement(ButtonWrapper, {\n        mobileBreakpoint: mobileBreakpoint,\n        hidden: hidden,\n        onClick: onClick\n    }, CustomBtn ? typeof CustomBtn === \"function\" ? /*#__PURE__*/ React__default.createElement(CustomBtn, null) : CustomBtn : /*#__PURE__*/ React__default.createElement(Button, {\n        type: type\n    }));\n};\nArrowButton.propTypes = {\n    type: PropTypes.oneOf([\n        \"prev\",\n        \"next\"\n    ]).isRequired,\n    mobileBreakpoint: PropTypes.number,\n    hidden: PropTypes.bool,\n    CustomBtn: PropTypes.oneOfType([\n        PropTypes.node,\n        PropTypes.element,\n        PropTypes.elementType\n    ]),\n    onClick: PropTypes.func.isRequired\n};\nvar DotWrapper = styled.div.withConfig({\n    displayName: \"Dot__DotWrapper\",\n    componentId: \"sc-176tc56-0\"\n})([\n    \"display:flex;margin:0 5px;cursor:pointer;\"\n]);\nvar DotDefault = styled.div.withConfig({\n    displayName: \"Dot__DotDefault\",\n    componentId: \"sc-176tc56-1\"\n})([\n    \"width:8px;height:8px;border-radius:50%;background:\",\n    \";\"\n], function(_ref) {\n    var color = _ref.color;\n    return color;\n});\nvar Dot = function Dot(_ref2) {\n    var index = _ref2.index, _ref2$isActive = _ref2.isActive, isActive = _ref2$isActive === void 0 ? false : _ref2$isActive, dotColorInactive = _ref2.dotColorInactive, dotColorActive = _ref2.dotColorActive, DotCustom = _ref2.dot, onClick = _ref2.onClick;\n    var handleClick = React.useCallback(function() {\n        onClick(index);\n    }, [\n        index,\n        onClick\n    ]);\n    return /*#__PURE__*/ React__default.createElement(DotWrapper, {\n        onClick: handleClick\n    }, DotCustom ? /*#__PURE__*/ React__default.createElement(DotCustom, {\n        isActive: isActive\n    }) : /*#__PURE__*/ React__default.createElement(DotDefault, {\n        color: isActive ? dotColorActive : dotColorInactive\n    }));\n};\nDot.propTypes = {\n    index: PropTypes.number.isRequired,\n    isActive: PropTypes.bool,\n    dotColorInactive: PropTypes.string,\n    dotColorActive: PropTypes.string,\n    dot: PropTypes.oneOfType([\n        PropTypes.node,\n        PropTypes.element,\n        PropTypes.elementType\n    ]),\n    onClick: PropTypes.func.isRequired\n};\nvar HANDLER_NAME_SPACE = \"__react-grid-carousle-resize-handler\";\nvar handleResize = debounce(function(e) {\n    Object.values(window[HANDLER_NAME_SPACE]).forEach(function(handler) {\n        if (typeof handler === \"function\") {\n            handler(e);\n        }\n    });\n}, 16);\nvar setupListener = function setupListener() {\n    window.addEventListener(\"resize\", handleResize);\n};\nvar removeListener = function removeListener() {\n    window.removeEventListener(\"resize\", handleResize);\n};\nvar addResizeHandler = function addResizeHandler(key, handler) {\n    if (_typeof(window[HANDLER_NAME_SPACE]) !== \"object\") {\n        window[HANDLER_NAME_SPACE] = {};\n        setupListener();\n    }\n    window[HANDLER_NAME_SPACE][key] = handler;\n};\nvar removeResizeHandler = function removeResizeHandler(key) {\n    delete window[HANDLER_NAME_SPACE][key];\n    if (!Object.keys(window[HANDLER_NAME_SPACE])) {\n        delete window[HANDLER_NAME_SPACE];\n        removeListener();\n    }\n};\nvar useResponsiveLayout = function useResponsiveLayout() {\n    var breakpointList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var _useState = React.useState(), _useState2 = _slicedToArray(_useState, 2), currentBreakpointSetting = _useState2[0], setCurrentBreakpointSetting = _useState2[1];\n    var random = React.useMemo(function() {\n        return \"\".concat(Math.random(), \"-\").concat(Math.random());\n    }, []);\n    var sortedBreakpointList = React.useMemo(function() {\n        return _toConsumableArray(breakpointList).sort(function(a, b) {\n            return (b.breakpoint || 0) - (a.breakpoint || 0);\n        });\n    }, [\n        breakpointList\n    ]);\n    var handleResize = React.useCallback(function() {\n        var windowWidth = window.innerWidth;\n        var matchedSetting;\n        sortedBreakpointList.find(function(setting) {\n            if (windowWidth <= setting.breakpoint) {\n                matchedSetting = setting;\n            } else {\n                return true;\n            }\n        });\n        setCurrentBreakpointSetting(matchedSetting);\n    }, [\n        sortedBreakpointList\n    ]);\n    React.useEffect(function() {\n        if (breakpointList.length) {\n            handleResize();\n            addResizeHandler(\"responsiveLayout-\".concat(random), handleResize);\n            return function() {\n                removeResizeHandler(\"responsiveLayout-\".concat(random));\n            };\n        }\n    }, [\n        breakpointList,\n        handleResize,\n        random\n    ]);\n    return currentBreakpointSetting;\n};\nvar Container = styled.div.withConfig({\n    displayName: \"Carousel__Container\",\n    componentId: \"sc-hyhecw-0\"\n})([\n    \"position:relative;\"\n]);\nvar RailWrapper = styled.div.withConfig({\n    displayName: \"Carousel__RailWrapper\",\n    componentId: \"sc-hyhecw-1\"\n})([\n    \"overflow:hidden;margin:\",\n    \";@media screen and (max-width:\",\n    \"px){overflow-x:auto;margin:0;scroll-snap-type:\",\n    \";scrollbar-width:none;&::-webkit-scrollbar{display:none;}}\"\n], function(_ref) {\n    var showDots = _ref.showDots;\n    return showDots ? \"0 20px 15px 20px\" : \"0 20px\";\n}, function(_ref2) {\n    var mobileBreakpoint = _ref2.mobileBreakpoint;\n    return mobileBreakpoint;\n}, function(_ref3) {\n    var scrollSnap = _ref3.scrollSnap;\n    return scrollSnap ? \"x mandatory\" : \"\";\n});\nvar Rail = styled.div.withConfig({\n    displayName: \"Carousel__Rail\",\n    componentId: \"sc-hyhecw-2\"\n})([\n    \"display:grid;grid-column-gap:\",\n    \";position:relative;transition:transform 0.5s cubic-bezier(0.2,1,0.3,1) 0s;grid-template-columns:\",\n    \";transform:\",\n    \";@media screen and (max-width:\",\n    \"px){padding-left:\",\n    \";grid-template-columns:\",\n    \";grid-column-gap:\",\n    \";transform:translateX(0);}\"\n], function(_ref4) {\n    var gap = _ref4.gap;\n    return \"\".concat(gap, \"px\");\n}, function(_ref5) {\n    var page = _ref5.page;\n    return \"repeat(\".concat(page, \", 100%)\");\n}, function(_ref6) {\n    var currentPage = _ref6.currentPage, gap = _ref6.gap;\n    return \"translateX(calc(\".concat(-100 * currentPage, \"% - \").concat(gap * currentPage, \"px))\");\n}, function(_ref7) {\n    var mobileBreakpoint = _ref7.mobileBreakpoint;\n    return mobileBreakpoint;\n}, function(_ref8) {\n    var gap = _ref8.gap;\n    return \"\".concat(gap, \"px\");\n}, function(_ref9) {\n    var page = _ref9.page;\n    return \"repeat(\".concat(page, \", 90%)\");\n}, function(_ref10) {\n    var cols = _ref10.cols, rows = _ref10.rows, gap = _ref10.gap;\n    return \"calc(\".concat((cols * rows - 1) * 90, \"% + \").concat(cols * rows * gap, \"px)\");\n});\nvar ItemSet = styled.div.withConfig({\n    displayName: \"Carousel__ItemSet\",\n    componentId: \"sc-hyhecw-3\"\n})([\n    \"display:grid;grid-template-columns:\",\n    \";grid-template-rows:\",\n    \";grid-gap:\",\n    \";@media screen and (max-width:\",\n    \"px){grid-template-columns:\",\n    \";grid-template-rows:1fr;&:last-of-type > \",\n    \":last-of-type{padding-right:\",\n    \";margin-right:\",\n    \";}}\"\n], function(_ref11) {\n    var cols = _ref11.cols;\n    return \"repeat(\".concat(cols, \", 1fr)\");\n}, function(_ref12) {\n    var rows = _ref12.rows;\n    return \"repeat(\".concat(rows, \", 1fr)\");\n}, function(_ref13) {\n    var gap = _ref13.gap;\n    return \"\".concat(gap, \"px\");\n}, function(_ref14) {\n    var mobileBreakpoint = _ref14.mobileBreakpoint;\n    return mobileBreakpoint;\n}, function(_ref15) {\n    var cols = _ref15.cols, rows = _ref15.rows;\n    return \"repeat(\".concat(cols * rows, \", 100%)\");\n}, /* sc-sel */ Item, function(_ref16) {\n    var gap = _ref16.gap;\n    return \"\".concat(gap, \"px\");\n}, function(_ref17) {\n    var gap = _ref17.gap;\n    return \"-\".concat(gap, \"px\");\n});\nvar Dots = styled.div.withConfig({\n    displayName: \"Carousel__Dots\",\n    componentId: \"sc-hyhecw-4\"\n})([\n    \"position:absolute;display:flex;align-items:center;justify-content:center;bottom:-12px;height:10px;width:100%;line-height:10px;text-align:center;@media screen and (max-width:\",\n    \"px){display:none;}\"\n], function(_ref18) {\n    var mobileBreakpoint = _ref18.mobileBreakpoint;\n    return mobileBreakpoint;\n});\nvar Item = styled.div.withConfig({\n    displayName: \"Carousel__Item\",\n    componentId: \"sc-hyhecw-5\"\n})([\n    \"scroll-snap-align:\",\n    \";\"\n], function(_ref19) {\n    var scrollSnap = _ref19.scrollSnap;\n    return scrollSnap ? \"center\" : \"\";\n});\nvar CAROUSEL_ITEM = \"CAROUSEL_ITEM\";\nvar Carousel = function Carousel(_ref20) {\n    var _ref20$cols = _ref20.cols, colsProp = _ref20$cols === void 0 ? 1 : _ref20$cols, _ref20$rows = _ref20.rows, rowsProp = _ref20$rows === void 0 ? 1 : _ref20$rows, _ref20$gap = _ref20.gap, gapProp = _ref20$gap === void 0 ? 10 : _ref20$gap, _ref20$loop = _ref20.loop, loopProp = _ref20$loop === void 0 ? false : _ref20$loop, _ref20$scrollSnap = _ref20.scrollSnap, scrollSnap = _ref20$scrollSnap === void 0 ? true : _ref20$scrollSnap, _ref20$hideArrow = _ref20.hideArrow, hideArrow = _ref20$hideArrow === void 0 ? false : _ref20$hideArrow, _ref20$showDots = _ref20.showDots, showDots = _ref20$showDots === void 0 ? false : _ref20$showDots, autoplayProp = _ref20.autoplay, _ref20$dotColorActive = _ref20.dotColorActive, dotColorActive = _ref20$dotColorActive === void 0 ? \"#795548\" : _ref20$dotColorActive, _ref20$dotColorInacti = _ref20.dotColorInactive, dotColorInactive = _ref20$dotColorInacti === void 0 ? \"#ccc\" : _ref20$dotColorInacti, responsiveLayout = _ref20.responsiveLayout, _ref20$mobileBreakpoi = _ref20.mobileBreakpoint, mobileBreakpoint = _ref20$mobileBreakpoi === void 0 ? 767 : _ref20$mobileBreakpoi, arrowLeft = _ref20.arrowLeft, arrowRight = _ref20.arrowRight, dot = _ref20.dot, _ref20$containerClass = _ref20.containerClassName, containerClassName = _ref20$containerClass === void 0 ? \"\" : _ref20$containerClass, _ref20$containerStyle = _ref20.containerStyle, containerStyle = _ref20$containerStyle === void 0 ? {} : _ref20$containerStyle, children = _ref20.children;\n    var _useState = React.useState(0), _useState2 = _slicedToArray(_useState, 2), currentPage = _useState2[0], setCurrentPage = _useState2[1];\n    var _useState3 = React.useState(false), _useState4 = _slicedToArray(_useState3, 2), isHover = _useState4[0], setIsHover = _useState4[1];\n    var _useState5 = React.useState(false), _useState6 = _slicedToArray(_useState5, 2), isTouch = _useState6[0], setIsTouch = _useState6[1];\n    var _useState7 = React.useState(colsProp), _useState8 = _slicedToArray(_useState7, 2), cols = _useState8[0], setCols = _useState8[1];\n    var _useState9 = React.useState(rowsProp), _useState10 = _slicedToArray(_useState9, 2), rows = _useState10[0], setRows = _useState10[1];\n    var _useState11 = React.useState(0), _useState12 = _slicedToArray(_useState11, 2), gap = _useState12[0], setGap = _useState12[1];\n    var _useState13 = React.useState(loopProp), _useState14 = _slicedToArray(_useState13, 2), loop = _useState14[0], setLoop = _useState14[1];\n    var _useState15 = React.useState(autoplayProp), _useState16 = _slicedToArray(_useState15, 2), autoplay = _useState16[0], setAutoplay = _useState16[1];\n    var _useState17 = React.useState(0), _useState18 = _slicedToArray(_useState17, 2), railWrapperWidth = _useState18[0], setRailWrapperWidth = _useState18[1];\n    var _useState19 = React.useState(false), _useState20 = _slicedToArray(_useState19, 2), hasSetResizeHandler = _useState20[0], setHasSetResizeHandler = _useState20[1];\n    var railWrapperRef = React.useRef(null);\n    var autoplayIntervalRef = React.useRef(null);\n    var breakpointSetting = useResponsiveLayout(responsiveLayout);\n    var randomKey = React.useMemo(function() {\n        return \"\".concat(Math.random(), \"-\").concat(Math.random());\n    }, []);\n    React.useEffect(function() {\n        smoothscroll.polyfill();\n    }, []);\n    React.useEffect(function() {\n        var _ref21 = breakpointSetting || {}, cols = _ref21.cols, rows = _ref21.rows, gap = _ref21.gap, loop = _ref21.loop, autoplay = _ref21.autoplay;\n        setCols(cols || colsProp);\n        setRows(rows || rowsProp);\n        setGap(parseGap(gap || gapProp));\n        setLoop(loop || loopProp);\n        setAutoplay(autoplay || autoplayProp);\n        setCurrentPage(0);\n    }, [\n        breakpointSetting,\n        colsProp,\n        rowsProp,\n        gapProp,\n        loopProp,\n        autoplayProp,\n        parseGap\n    ]);\n    var handleRailWrapperResize = React.useCallback(function() {\n        railWrapperRef.current && setRailWrapperWidth(railWrapperRef.current.offsetWidth);\n    }, [\n        railWrapperRef\n    ]);\n    var setResizeHandler = React.useCallback(function() {\n        addResizeHandler(\"gapCalculator-\".concat(randomKey), handleRailWrapperResize);\n        setHasSetResizeHandler(true);\n    }, [\n        randomKey,\n        handleRailWrapperResize\n    ]);\n    var rmResizeHandler = React.useCallback(function() {\n        removeResizeHandler(\"gapCalculator-\".concat(randomKey));\n        setHasSetResizeHandler(false);\n    }, [\n        randomKey\n    ]);\n    var parseGap = React.useCallback(function(gap) {\n        var parsed = gap;\n        var shouldSetResizeHandler = false;\n        if (typeof gap !== \"number\") {\n            switch(/\\D*$/.exec(gap)[0]){\n                case \"px\":\n                    {\n                        parsed = +gap.replace(\"px\", \"\");\n                        break;\n                    }\n                case \"%\":\n                    {\n                        var wrapperWidth = railWrapperWidth || railWrapperRef.current ? railWrapperRef.current.offsetWidth : 0;\n                        parsed = wrapperWidth * gap.replace(\"%\", \"\") / 100;\n                        shouldSetResizeHandler = true;\n                        break;\n                    }\n                default:\n                    {\n                        parsed = 0;\n                        console.error(\"Doesn't support the provided measurement unit: \".concat(gap));\n                    }\n            }\n        }\n        shouldSetResizeHandler && !hasSetResizeHandler && setResizeHandler();\n        !shouldSetResizeHandler && hasSetResizeHandler && rmResizeHandler();\n        return parsed;\n    }, [\n        railWrapperWidth,\n        railWrapperRef,\n        hasSetResizeHandler,\n        setResizeHandler,\n        rmResizeHandler\n    ]);\n    var itemList = React.useMemo(function() {\n        return React__default.Children.toArray(children).filter(function(child) {\n            return child.type.displayName === CAROUSEL_ITEM;\n        });\n    }, [\n        children\n    ]);\n    var itemAmountPerSet = cols * rows;\n    var itemSetList = React.useMemo(function() {\n        return itemList.reduce(function(result, item, i) {\n            var itemComponent = /*#__PURE__*/ React__default.createElement(Item, {\n                key: i,\n                scrollSnap: scrollSnap\n            }, item);\n            if (i % itemAmountPerSet === 0) {\n                result.push([\n                    itemComponent\n                ]);\n            } else {\n                result[result.length - 1].push(itemComponent);\n            }\n            return result;\n        }, []);\n    }, [\n        itemList,\n        itemAmountPerSet,\n        scrollSnap\n    ]);\n    var page = Math.ceil(itemList.length / itemAmountPerSet);\n    var handlePrev = React.useCallback(function() {\n        setCurrentPage(function(p) {\n            var prevPage = p - 1;\n            if (loop && prevPage < 0) {\n                return page - 1;\n            }\n            return prevPage;\n        });\n    }, [\n        loop,\n        page\n    ]);\n    var handleNext = React.useCallback(function() {\n        var isMobile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var railWrapper = railWrapperRef.current;\n        if (isMobile && railWrapper) {\n            if (!scrollSnap) {\n                return;\n            }\n            var scrollLeft = railWrapper.scrollLeft, offsetWidth = railWrapper.offsetWidth, scrollWidth = railWrapper.scrollWidth;\n            railWrapper.scrollBy({\n                top: 0,\n                left: loop && scrollLeft + offsetWidth >= scrollWidth ? -scrollLeft : scrollLeft === 0 ? gap + (offsetWidth - gap) * 0.9 - (offsetWidth * 0.1 - gap * 1.1) / 2 : (offsetWidth - gap) * 0.9 + gap,\n                behavior: \"smooth\"\n            });\n        } else {\n            setCurrentPage(function(p) {\n                var nextPage = p + 1;\n                if (nextPage >= page) {\n                    return loop ? 0 : p;\n                }\n                return nextPage;\n            });\n        }\n    }, [\n        loop,\n        page,\n        gap,\n        railWrapperRef,\n        scrollSnap\n    ]);\n    var startAutoplayInterval = React.useCallback(function() {\n        if (autoplayIntervalRef.current === null && typeof autoplay === \"number\") {\n            autoplayIntervalRef.current = setInterval(function() {\n                handleNext(window.innerWidth <= mobileBreakpoint);\n            }, autoplay);\n        }\n    }, [\n        autoplay,\n        autoplayIntervalRef,\n        handleNext,\n        mobileBreakpoint\n    ]);\n    React.useEffect(function() {\n        startAutoplayInterval();\n        return function() {\n            if (autoplayIntervalRef.current !== null) {\n                clearInterval(autoplayIntervalRef.current);\n                autoplayIntervalRef.current = null;\n            }\n        };\n    }, [\n        startAutoplayInterval,\n        autoplayIntervalRef\n    ]);\n    React.useEffect(function() {\n        if (isHover || isTouch) {\n            clearInterval(autoplayIntervalRef.current);\n            autoplayIntervalRef.current = null;\n        } else {\n            startAutoplayInterval();\n        }\n    }, [\n        isHover,\n        isTouch,\n        autoplayIntervalRef,\n        startAutoplayInterval\n    ]);\n    var turnToPage = React.useCallback(function(page) {\n        setCurrentPage(page);\n    }, []);\n    var handleHover = React.useCallback(function() {\n        setIsHover(function(hover) {\n            return !hover;\n        });\n    }, []);\n    var handleTouch = React.useCallback(function() {\n        setIsTouch(function(touch) {\n            return !touch;\n        });\n    }, []);\n    return /*#__PURE__*/ React__default.createElement(Container, {\n        onMouseEnter: handleHover,\n        onMouseLeave: handleHover,\n        onTouchStart: handleTouch,\n        onTouchEnd: handleTouch,\n        className: containerClassName,\n        style: containerStyle\n    }, /*#__PURE__*/ React__default.createElement(ArrowButton, {\n        type: \"prev\",\n        mobileBreakpoint: mobileBreakpoint,\n        hidden: hideArrow || !loop && currentPage <= 0,\n        CustomBtn: arrowLeft,\n        onClick: handlePrev\n    }), /*#__PURE__*/ React__default.createElement(RailWrapper, {\n        mobileBreakpoint: mobileBreakpoint,\n        scrollSnap: scrollSnap,\n        showDots: showDots,\n        ref: railWrapperRef\n    }, /*#__PURE__*/ React__default.createElement(Rail, {\n        cols: cols,\n        rows: rows,\n        page: page,\n        gap: gap,\n        currentPage: currentPage,\n        mobileBreakpoint: mobileBreakpoint\n    }, itemSetList.map(function(set, i) {\n        return /*#__PURE__*/ React__default.createElement(ItemSet, {\n            key: i,\n            cols: cols,\n            rows: rows,\n            gap: gap,\n            mobileBreakpoint: mobileBreakpoint\n        }, set);\n    }))), showDots && /*#__PURE__*/ React__default.createElement(Dots, {\n        mobileBreakpoint: mobileBreakpoint\n    }, _toConsumableArray(Array(page)).map(function(_, i) {\n        return /*#__PURE__*/ React__default.createElement(Dot, {\n            key: i,\n            index: i,\n            isActive: i === currentPage,\n            dotColorInactive: dotColorInactive,\n            dotColorActive: dotColorActive,\n            dot: dot,\n            onClick: turnToPage\n        });\n    })), /*#__PURE__*/ React__default.createElement(ArrowButton, {\n        type: \"next\",\n        mobileBreakpoint: mobileBreakpoint,\n        hidden: hideArrow || !loop && currentPage === page - 1,\n        CustomBtn: arrowRight,\n        onClick: handleNext.bind(null, false)\n    }));\n};\nCarousel.Item = function(_ref22) {\n    var children = _ref22.children;\n    return children;\n};\nCarousel.Item.displayName = CAROUSEL_ITEM;\nmodule.exports = Carousel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL2Rpc3QvYnVuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0EsZ0JBQWlCQyxFQUFFO0lBQUksT0FBTyxNQUFRLE9BQU9BLE9BQU8sWUFBYSxhQUFhQSxLQUFNQSxFQUFFLENBQUMsVUFBVSxHQUFHQTtBQUFJO0FBRWpILElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLGlCQUFpQkosZ0JBQWdCRTtBQUNyQyxJQUFJRyxTQUFTTCxnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBQ3JDLElBQUlHLFlBQVlOLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDeEMsSUFBSUksZUFBZVAsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUMzQyxJQUFJSyxXQUFXUixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBRXZDLFNBQVNNLFFBQVFDLEdBQUc7SUFDbEI7SUFFQSxPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixHQUFHO1FBQ2hHLE9BQU8sT0FBT0E7SUFDaEIsSUFBSSxTQUFVQSxHQUFHO1FBQ2YsT0FBT0EsT0FBTyxjQUFjLE9BQU9DLFVBQVVELElBQUlHLFdBQVcsS0FBS0YsVUFBVUQsUUFBUUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFDMUgsR0FBR0QsUUFBUUM7QUFDYjtBQUVBLFNBQVNLLGVBQWVDLEdBQUcsRUFBRUMsQ0FBQztJQUM1QixPQUFPQyxnQkFBZ0JGLFFBQVFHLHNCQUFzQkgsS0FBS0MsTUFBTUcsNEJBQTRCSixLQUFLQyxNQUFNSTtBQUN6RztBQUVBLFNBQVNDLG1CQUFtQk4sR0FBRztJQUM3QixPQUFPTyxtQkFBbUJQLFFBQVFRLGlCQUFpQlIsUUFBUUksNEJBQTRCSixRQUFRUztBQUNqRztBQUVBLFNBQVNGLG1CQUFtQlAsR0FBRztJQUM3QixJQUFJVSxNQUFNQyxPQUFPLENBQUNYLE1BQU0sT0FB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V0FBVzRCLElBQUksQ0FBQyxNQUFNO0lBQ2pDO0FBQ0Y7QUFFQTNILFNBQVNQLElBQUksR0FBRyxTQUFVbUksTUFBTTtJQUM5QixJQUFJakcsV0FBV2lHLE9BQU9qRyxRQUFRO0lBQzlCLE9BQU9BO0FBQ1Q7QUFFQTNCLFNBQVNQLElBQUksQ0FBQ3RHLFdBQVcsR0FBRzRHO0FBRTVCOEgsT0FBT0MsT0FBTyxHQUFHOUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kdWhhY2tzXzMvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL2Rpc3QvYnVuZGxlLmpzPzUyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBSZWFjdF9fZGVmYXVsdCA9IF9pbnRlcm9wRGVmYXVsdChSZWFjdCk7XG52YXIgc3R5bGVkID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3N0eWxlZC1jb21wb25lbnRzJykpO1xudmFyIFByb3BUeXBlcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdwcm9wLXR5cGVzJykpO1xudmFyIHNtb290aHNjcm9sbCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdzbW9vdGhzY3JvbGwtcG9seWZpbGwnKSk7XG52YXIgZGVib3VuY2UgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnbG9kYXNoLmRlYm91bmNlJykpO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICB2YXIgX2kgPSBhcnIgPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG5cbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG5cbiAgdmFyIF9zLCBfZTtcblxuICB0cnkge1xuICAgIGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxudmFyIEJ1dHRvbldyYXBwZXIgPSBzdHlsZWQuZGl2LndpdGhDb25maWcoe1xuICBkaXNwbGF5TmFtZTogXCJBcnJvd0J1dHRvbl9fQnV0dG9uV3JhcHBlclwiLFxuICBjb21wb25lbnRJZDogXCJzYy0xaWtiMGhqLTBcIlxufSkoW1wiQG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDpcIiwgXCJweCl7ZGlzcGxheTpub25lO31cIl0sIGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBtb2JpbGVCcmVha3BvaW50ID0gX3JlZi5tb2JpbGVCcmVha3BvaW50O1xuICByZXR1cm4gbW9iaWxlQnJlYWtwb2ludDtcbn0pO1xudmFyIEJ1dHRvbiA9IHN0eWxlZC5zcGFuLndpdGhDb25maWcoe1xuICBkaXNwbGF5TmFtZTogXCJBcnJvd0J1dHRvbl9fQnV0dG9uXCIsXG4gIGNvbXBvbmVudElkOiBcInNjLTFpa2IwaGotMVwiXG59KShbXCJwb3NpdGlvbjphYnNvbHV0ZTt0b3A6Y2FsYyg1MCUgLSAxNy41cHgpO2hlaWdodDozNXB4O3dpZHRoOjM1cHg7YmFja2dyb3VuZDojZmZmO2JvcmRlci1yYWRpdXM6NTAlO2JveC1zaGFkb3c6MCAwIDVweCAwICMwMDA5O3otaW5kZXg6MTA7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjEwcHg7b3BhY2l0eTowLjY7dHJhbnNpdGlvbjpvcGFjaXR5IDAuMjVzO2xlZnQ6XCIsIFwiO3JpZ2h0OlwiLCBcIjsmOmhvdmVye29wYWNpdHk6MTt9Jjo6YmVmb3Jle2NvbnRlbnQ6Jyc7aGVpZ2h0OjEwcHg7d2lkdGg6MTBweDtiYWNrZ3JvdW5kOnRyYW5zcGFyZW50O2JvcmRlci10b3A6MnB4IHNvbGlkICMwMDA7Ym9yZGVyLXJpZ2h0OjJweCBzb2xpZCAjMDAwO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3RvcDo1MCU7bGVmdDo1MCU7dHJhbnNmb3JtOlwiLCBcIjt9XCJdLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgdmFyIHR5cGUgPSBfcmVmMi50eXBlO1xuICByZXR1cm4gdHlwZSA9PT0gJ3ByZXYnID8gJzVweCcgOiAnaW5pdGlhbCc7XG59LCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgdmFyIHR5cGUgPSBfcmVmMy50eXBlO1xuICByZXR1cm4gdHlwZSA9PT0gJ25leHQnID8gJzVweCcgOiAnaW5pdGlhbCc7XG59LCBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNC50eXBlO1xuICByZXR1cm4gdHlwZSA9PT0gJ3ByZXYnID8gJ3RyYW5zbGF0ZSgtMjUlLCAtNTAlKSByb3RhdGUoLTEzNWRlZyknIDogJ3RyYW5zbGF0ZSgtNzUlLCAtNTAlKSByb3RhdGUoNDVkZWcpJztcbn0pO1xuXG52YXIgQXJyb3dCdXR0b24gPSBmdW5jdGlvbiBBcnJvd0J1dHRvbihfcmVmNSkge1xuICB2YXIgdHlwZSA9IF9yZWY1LnR5cGUsXG4gICAgICBfcmVmNSRtb2JpbGVCcmVha3BvaW4gPSBfcmVmNS5tb2JpbGVCcmVha3BvaW50LFxuICAgICAgbW9iaWxlQnJlYWtwb2ludCA9IF9yZWY1JG1vYmlsZUJyZWFrcG9pbiA9PT0gdm9pZCAwID8gMSA6IF9yZWY1JG1vYmlsZUJyZWFrcG9pbixcbiAgICAgIF9yZWY1JGhpZGRlbiA9IF9yZWY1LmhpZGRlbixcbiAgICAgIGhpZGRlbiA9IF9yZWY1JGhpZGRlbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNSRoaWRkZW4sXG4gICAgICBDdXN0b21CdG4gPSBfcmVmNS5DdXN0b21CdG4sXG4gICAgICBvbkNsaWNrID0gX3JlZjUub25DbGljaztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJ1dHRvbldyYXBwZXIsIHtcbiAgICBtb2JpbGVCcmVha3BvaW50OiBtb2JpbGVCcmVha3BvaW50LFxuICAgIGhpZGRlbjogaGlkZGVuLFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2tcbiAgfSwgQ3VzdG9tQnRuID8gdHlwZW9mIEN1c3RvbUJ0biA9PT0gJ2Z1bmN0aW9uJyA/IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEN1c3RvbUJ0biwgbnVsbCkgOiBDdXN0b21CdG4gOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChCdXR0b24sIHtcbiAgICB0eXBlOiB0eXBlXG4gIH0pKTtcbn07XG5cbkFycm93QnV0dG9uLnByb3BUeXBlcyA9IHtcbiAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsncHJldicsICduZXh0J10pLmlzUmVxdWlyZWQsXG4gIG1vYmlsZUJyZWFrcG9pbnQ6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhpZGRlbjogUHJvcFR5cGVzLmJvb2wsXG4gIEN1c3RvbUJ0bjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMuZWxlbWVudFR5cGVdKSxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufTtcblxudmFyIERvdFdyYXBwZXIgPSBzdHlsZWQuZGl2LndpdGhDb25maWcoe1xuICBkaXNwbGF5TmFtZTogXCJEb3RfX0RvdFdyYXBwZXJcIixcbiAgY29tcG9uZW50SWQ6IFwic2MtMTc2dGM1Ni0wXCJcbn0pKFtcImRpc3BsYXk6ZmxleDttYXJnaW46MCA1cHg7Y3Vyc29yOnBvaW50ZXI7XCJdKTtcbnZhciBEb3REZWZhdWx0ID0gc3R5bGVkLmRpdi53aXRoQ29uZmlnKHtcbiAgZGlzcGxheU5hbWU6IFwiRG90X19Eb3REZWZhdWx0XCIsXG4gIGNvbXBvbmVudElkOiBcInNjLTE3NnRjNTYtMVwiXG59KShbXCJ3aWR0aDo4cHg7aGVpZ2h0OjhweDtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kOlwiLCBcIjtcIl0sIGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjb2xvciA9IF9yZWYuY29sb3I7XG4gIHJldHVybiBjb2xvcjtcbn0pO1xuXG52YXIgRG90ID0gZnVuY3Rpb24gRG90KF9yZWYyKSB7XG4gIHZhciBpbmRleCA9IF9yZWYyLmluZGV4LFxuICAgICAgX3JlZjIkaXNBY3RpdmUgPSBfcmVmMi5pc0FjdGl2ZSxcbiAgICAgIGlzQWN0aXZlID0gX3JlZjIkaXNBY3RpdmUgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkaXNBY3RpdmUsXG4gICAgICBkb3RDb2xvckluYWN0aXZlID0gX3JlZjIuZG90Q29sb3JJbmFjdGl2ZSxcbiAgICAgIGRvdENvbG9yQWN0aXZlID0gX3JlZjIuZG90Q29sb3JBY3RpdmUsXG4gICAgICBEb3RDdXN0b20gPSBfcmVmMi5kb3QsXG4gICAgICBvbkNsaWNrID0gX3JlZjIub25DbGljaztcbiAgdmFyIGhhbmRsZUNsaWNrID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIG9uQ2xpY2soaW5kZXgpO1xuICB9LCBbaW5kZXgsIG9uQ2xpY2tdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERvdFdyYXBwZXIsIHtcbiAgICBvbkNsaWNrOiBoYW5kbGVDbGlja1xuICB9LCBEb3RDdXN0b20gPyAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChEb3RDdXN0b20sIHtcbiAgICBpc0FjdGl2ZTogaXNBY3RpdmVcbiAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChEb3REZWZhdWx0LCB7XG4gICAgY29sb3I6IGlzQWN0aXZlID8gZG90Q29sb3JBY3RpdmUgOiBkb3RDb2xvckluYWN0aXZlXG4gIH0pKTtcbn07XG5cbkRvdC5wcm9wVHlwZXMgPSB7XG4gIGluZGV4OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gIGlzQWN0aXZlOiBQcm9wVHlwZXMuYm9vbCxcbiAgZG90Q29sb3JJbmFjdGl2ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZG90Q29sb3JBY3RpdmU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGRvdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm5vZGUsIFByb3BUeXBlcy5lbGVtZW50LCBQcm9wVHlwZXMuZWxlbWVudFR5cGVdKSxcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxufTtcblxudmFyIEhBTkRMRVJfTkFNRV9TUEFDRSA9ICdfX3JlYWN0LWdyaWQtY2Fyb3VzbGUtcmVzaXplLWhhbmRsZXInO1xudmFyIGhhbmRsZVJlc2l6ZSA9IGRlYm91bmNlKGZ1bmN0aW9uIChlKSB7XG4gIE9iamVjdC52YWx1ZXMod2luZG93W0hBTkRMRVJfTkFNRV9TUEFDRV0pLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGhhbmRsZXIoZSk7XG4gICAgfVxuICB9KTtcbn0sIDE2KTtcblxudmFyIHNldHVwTGlzdGVuZXIgPSBmdW5jdGlvbiBzZXR1cExpc3RlbmVyKCkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbn07XG5cbnZhciByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbn07XG5cbnZhciBhZGRSZXNpemVIYW5kbGVyID0gZnVuY3Rpb24gYWRkUmVzaXplSGFuZGxlcihrZXksIGhhbmRsZXIpIHtcbiAgaWYgKF90eXBlb2Yod2luZG93W0hBTkRMRVJfTkFNRV9TUEFDRV0pICE9PSAnb2JqZWN0Jykge1xuICAgIHdpbmRvd1tIQU5ETEVSX05BTUVfU1BBQ0VdID0ge307XG4gICAgc2V0dXBMaXN0ZW5lcigpO1xuICB9XG5cbiAgd2luZG93W0hBTkRMRVJfTkFNRV9TUEFDRV1ba2V5XSA9IGhhbmRsZXI7XG59O1xudmFyIHJlbW92ZVJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiByZW1vdmVSZXNpemVIYW5kbGVyKGtleSkge1xuICBkZWxldGUgd2luZG93W0hBTkRMRVJfTkFNRV9TUEFDRV1ba2V5XTtcblxuICBpZiAoIU9iamVjdC5rZXlzKHdpbmRvd1tIQU5ETEVSX05BTUVfU1BBQ0VdKSkge1xuICAgIGRlbGV0ZSB3aW5kb3dbSEFORExFUl9OQU1FX1NQQUNFXTtcbiAgICByZW1vdmVMaXN0ZW5lcigpO1xuICB9XG59O1xuXG52YXIgdXNlUmVzcG9uc2l2ZUxheW91dCA9IGZ1bmN0aW9uIHVzZVJlc3BvbnNpdmVMYXlvdXQoKSB7XG4gIHZhciBicmVha3BvaW50TGlzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogW107XG5cbiAgdmFyIF91c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKCksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIGN1cnJlbnRCcmVha3BvaW50U2V0dGluZyA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRDdXJyZW50QnJlYWtwb2ludFNldHRpbmcgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciByYW5kb20gPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoTWF0aC5yYW5kb20oKSwgXCItXCIpLmNvbmNhdChNYXRoLnJhbmRvbSgpKTtcbiAgfSwgW10pO1xuICB2YXIgc29ydGVkQnJlYWtwb2ludExpc3QgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KGJyZWFrcG9pbnRMaXN0KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gKGIuYnJlYWtwb2ludCB8fCAwKSAtIChhLmJyZWFrcG9pbnQgfHwgMCk7XG4gICAgfSk7XG4gIH0sIFticmVha3BvaW50TGlzdF0pO1xuICB2YXIgaGFuZGxlUmVzaXplID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHZhciBtYXRjaGVkU2V0dGluZztcbiAgICBzb3J0ZWRCcmVha3BvaW50TGlzdC5maW5kKGZ1bmN0aW9uIChzZXR0aW5nKSB7XG4gICAgICBpZiAod2luZG93V2lkdGggPD0gc2V0dGluZy5icmVha3BvaW50KSB7XG4gICAgICAgIG1hdGNoZWRTZXR0aW5nID0gc2V0dGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNldEN1cnJlbnRCcmVha3BvaW50U2V0dGluZyhtYXRjaGVkU2V0dGluZyk7XG4gIH0sIFtzb3J0ZWRCcmVha3BvaW50TGlzdF0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChicmVha3BvaW50TGlzdC5sZW5ndGgpIHtcbiAgICAgIGhhbmRsZVJlc2l6ZSgpO1xuICAgICAgYWRkUmVzaXplSGFuZGxlcihcInJlc3BvbnNpdmVMYXlvdXQtXCIuY29uY2F0KHJhbmRvbSksIGhhbmRsZVJlc2l6ZSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVSZXNpemVIYW5kbGVyKFwicmVzcG9uc2l2ZUxheW91dC1cIi5jb25jYXQocmFuZG9tKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW2JyZWFrcG9pbnRMaXN0LCBoYW5kbGVSZXNpemUsIHJhbmRvbV0pO1xuICByZXR1cm4gY3VycmVudEJyZWFrcG9pbnRTZXR0aW5nO1xufTtcblxudmFyIENvbnRhaW5lciA9IHN0eWxlZC5kaXYud2l0aENvbmZpZyh7XG4gIGRpc3BsYXlOYW1lOiBcIkNhcm91c2VsX19Db250YWluZXJcIixcbiAgY29tcG9uZW50SWQ6IFwic2MtaHloZWN3LTBcIlxufSkoW1wicG9zaXRpb246cmVsYXRpdmU7XCJdKTtcbnZhciBSYWlsV3JhcHBlciA9IHN0eWxlZC5kaXYud2l0aENvbmZpZyh7XG4gIGRpc3BsYXlOYW1lOiBcIkNhcm91c2VsX19SYWlsV3JhcHBlclwiLFxuICBjb21wb25lbnRJZDogXCJzYy1oeWhlY3ctMVwiXG59KShbXCJvdmVyZmxvdzpoaWRkZW47bWFyZ2luOlwiLCBcIjtAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOlwiLCBcInB4KXtvdmVyZmxvdy14OmF1dG87bWFyZ2luOjA7c2Nyb2xsLXNuYXAtdHlwZTpcIiwgXCI7c2Nyb2xsYmFyLXdpZHRoOm5vbmU7Jjo6LXdlYmtpdC1zY3JvbGxiYXJ7ZGlzcGxheTpub25lO319XCJdLCBmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgc2hvd0RvdHMgPSBfcmVmLnNob3dEb3RzO1xuICByZXR1cm4gc2hvd0RvdHMgPyAnMCAyMHB4IDE1cHggMjBweCcgOiAnMCAyMHB4Jztcbn0sIGZ1bmN0aW9uIChfcmVmMikge1xuICB2YXIgbW9iaWxlQnJlYWtwb2ludCA9IF9yZWYyLm1vYmlsZUJyZWFrcG9pbnQ7XG4gIHJldHVybiBtb2JpbGVCcmVha3BvaW50O1xufSwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gIHZhciBzY3JvbGxTbmFwID0gX3JlZjMuc2Nyb2xsU25hcDtcbiAgcmV0dXJuIHNjcm9sbFNuYXAgPyAneCBtYW5kYXRvcnknIDogJyc7XG59KTtcbnZhciBSYWlsID0gc3R5bGVkLmRpdi53aXRoQ29uZmlnKHtcbiAgZGlzcGxheU5hbWU6IFwiQ2Fyb3VzZWxfX1JhaWxcIixcbiAgY29tcG9uZW50SWQ6IFwic2MtaHloZWN3LTJcIlxufSkoW1wiZGlzcGxheTpncmlkO2dyaWQtY29sdW1uLWdhcDpcIiwgXCI7cG9zaXRpb246cmVsYXRpdmU7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC41cyBjdWJpYy1iZXppZXIoMC4yLDEsMC4zLDEpIDBzO2dyaWQtdGVtcGxhdGUtY29sdW1uczpcIiwgXCI7dHJhbnNmb3JtOlwiLCBcIjtAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOlwiLCBcInB4KXtwYWRkaW5nLWxlZnQ6XCIsIFwiO2dyaWQtdGVtcGxhdGUtY29sdW1uczpcIiwgXCI7Z3JpZC1jb2x1bW4tZ2FwOlwiLCBcIjt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKTt9XCJdLCBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgdmFyIGdhcCA9IF9yZWY0LmdhcDtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGdhcCwgXCJweFwiKTtcbn0sIGZ1bmN0aW9uIChfcmVmNSkge1xuICB2YXIgcGFnZSA9IF9yZWY1LnBhZ2U7XG4gIHJldHVybiBcInJlcGVhdChcIi5jb25jYXQocGFnZSwgXCIsIDEwMCUpXCIpO1xufSwgZnVuY3Rpb24gKF9yZWY2KSB7XG4gIHZhciBjdXJyZW50UGFnZSA9IF9yZWY2LmN1cnJlbnRQYWdlLFxuICAgICAgZ2FwID0gX3JlZjYuZ2FwO1xuICByZXR1cm4gXCJ0cmFuc2xhdGVYKGNhbGMoXCIuY29uY2F0KC0xMDAgKiBjdXJyZW50UGFnZSwgXCIlIC0gXCIpLmNvbmNhdChnYXAgKiBjdXJyZW50UGFnZSwgXCJweCkpXCIpO1xufSwgZnVuY3Rpb24gKF9yZWY3KSB7XG4gIHZhciBtb2JpbGVCcmVha3BvaW50ID0gX3JlZjcubW9iaWxlQnJlYWtwb2ludDtcbiAgcmV0dXJuIG1vYmlsZUJyZWFrcG9pbnQ7XG59LCBmdW5jdGlvbiAoX3JlZjgpIHtcbiAgdmFyIGdhcCA9IF9yZWY4LmdhcDtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGdhcCwgXCJweFwiKTtcbn0sIGZ1bmN0aW9uIChfcmVmOSkge1xuICB2YXIgcGFnZSA9IF9yZWY5LnBhZ2U7XG4gIHJldHVybiBcInJlcGVhdChcIi5jb25jYXQocGFnZSwgXCIsIDkwJSlcIik7XG59LCBmdW5jdGlvbiAoX3JlZjEwKSB7XG4gIHZhciBjb2xzID0gX3JlZjEwLmNvbHMsXG4gICAgICByb3dzID0gX3JlZjEwLnJvd3MsXG4gICAgICBnYXAgPSBfcmVmMTAuZ2FwO1xuICByZXR1cm4gXCJjYWxjKFwiLmNvbmNhdCgoY29scyAqIHJvd3MgLSAxKSAqIDkwLCBcIiUgKyBcIikuY29uY2F0KGNvbHMgKiByb3dzICogZ2FwLCBcInB4KVwiKTtcbn0pO1xudmFyIEl0ZW1TZXQgPSBzdHlsZWQuZGl2LndpdGhDb25maWcoe1xuICBkaXNwbGF5TmFtZTogXCJDYXJvdXNlbF9fSXRlbVNldFwiLFxuICBjb21wb25lbnRJZDogXCJzYy1oeWhlY3ctM1wiXG59KShbXCJkaXNwbGF5OmdyaWQ7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOlwiLCBcIjtncmlkLXRlbXBsYXRlLXJvd3M6XCIsIFwiO2dyaWQtZ2FwOlwiLCBcIjtAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOlwiLCBcInB4KXtncmlkLXRlbXBsYXRlLWNvbHVtbnM6XCIsIFwiO2dyaWQtdGVtcGxhdGUtcm93czoxZnI7JjpsYXN0LW9mLXR5cGUgPiBcIiwgXCI6bGFzdC1vZi10eXBle3BhZGRpbmctcmlnaHQ6XCIsIFwiO21hcmdpbi1yaWdodDpcIiwgXCI7fX1cIl0sIGZ1bmN0aW9uIChfcmVmMTEpIHtcbiAgdmFyIGNvbHMgPSBfcmVmMTEuY29scztcbiAgcmV0dXJuIFwicmVwZWF0KFwiLmNvbmNhdChjb2xzLCBcIiwgMWZyKVwiKTtcbn0sIGZ1bmN0aW9uIChfcmVmMTIpIHtcbiAgdmFyIHJvd3MgPSBfcmVmMTIucm93cztcbiAgcmV0dXJuIFwicmVwZWF0KFwiLmNvbmNhdChyb3dzLCBcIiwgMWZyKVwiKTtcbn0sIGZ1bmN0aW9uIChfcmVmMTMpIHtcbiAgdmFyIGdhcCA9IF9yZWYxMy5nYXA7XG4gIHJldHVybiBcIlwiLmNvbmNhdChnYXAsIFwicHhcIik7XG59LCBmdW5jdGlvbiAoX3JlZjE0KSB7XG4gIHZhciBtb2JpbGVCcmVha3BvaW50ID0gX3JlZjE0Lm1vYmlsZUJyZWFrcG9pbnQ7XG4gIHJldHVybiBtb2JpbGVCcmVha3BvaW50O1xufSwgZnVuY3Rpb24gKF9yZWYxNSkge1xuICB2YXIgY29scyA9IF9yZWYxNS5jb2xzLFxuICAgICAgcm93cyA9IF9yZWYxNS5yb3dzO1xuICByZXR1cm4gXCJyZXBlYXQoXCIuY29uY2F0KGNvbHMgKiByb3dzLCBcIiwgMTAwJSlcIik7XG59LFxuLyogc2Mtc2VsICovXG5JdGVtLCBmdW5jdGlvbiAoX3JlZjE2KSB7XG4gIHZhciBnYXAgPSBfcmVmMTYuZ2FwO1xuICByZXR1cm4gXCJcIi5jb25jYXQoZ2FwLCBcInB4XCIpO1xufSwgZnVuY3Rpb24gKF9yZWYxNykge1xuICB2YXIgZ2FwID0gX3JlZjE3LmdhcDtcbiAgcmV0dXJuIFwiLVwiLmNvbmNhdChnYXAsIFwicHhcIik7XG59KTtcbnZhciBEb3RzID0gc3R5bGVkLmRpdi53aXRoQ29uZmlnKHtcbiAgZGlzcGxheU5hbWU6IFwiQ2Fyb3VzZWxfX0RvdHNcIixcbiAgY29tcG9uZW50SWQ6IFwic2MtaHloZWN3LTRcIlxufSkoW1wicG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JvdHRvbTotMTJweDtoZWlnaHQ6MTBweDt3aWR0aDoxMDAlO2xpbmUtaGVpZ2h0OjEwcHg7dGV4dC1hbGlnbjpjZW50ZXI7QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDpcIiwgXCJweCl7ZGlzcGxheTpub25lO31cIl0sIGZ1bmN0aW9uIChfcmVmMTgpIHtcbiAgdmFyIG1vYmlsZUJyZWFrcG9pbnQgPSBfcmVmMTgubW9iaWxlQnJlYWtwb2ludDtcbiAgcmV0dXJuIG1vYmlsZUJyZWFrcG9pbnQ7XG59KTtcbnZhciBJdGVtID0gc3R5bGVkLmRpdi53aXRoQ29uZmlnKHtcbiAgZGlzcGxheU5hbWU6IFwiQ2Fyb3VzZWxfX0l0ZW1cIixcbiAgY29tcG9uZW50SWQ6IFwic2MtaHloZWN3LTVcIlxufSkoW1wic2Nyb2xsLXNuYXAtYWxpZ246XCIsIFwiO1wiXSwgZnVuY3Rpb24gKF9yZWYxOSkge1xuICB2YXIgc2Nyb2xsU25hcCA9IF9yZWYxOS5zY3JvbGxTbmFwO1xuICByZXR1cm4gc2Nyb2xsU25hcCA/ICdjZW50ZXInIDogJyc7XG59KTtcbnZhciBDQVJPVVNFTF9JVEVNID0gJ0NBUk9VU0VMX0lURU0nO1xuXG52YXIgQ2Fyb3VzZWwgPSBmdW5jdGlvbiBDYXJvdXNlbChfcmVmMjApIHtcbiAgdmFyIF9yZWYyMCRjb2xzID0gX3JlZjIwLmNvbHMsXG4gICAgICBjb2xzUHJvcCA9IF9yZWYyMCRjb2xzID09PSB2b2lkIDAgPyAxIDogX3JlZjIwJGNvbHMsXG4gICAgICBfcmVmMjAkcm93cyA9IF9yZWYyMC5yb3dzLFxuICAgICAgcm93c1Byb3AgPSBfcmVmMjAkcm93cyA9PT0gdm9pZCAwID8gMSA6IF9yZWYyMCRyb3dzLFxuICAgICAgX3JlZjIwJGdhcCA9IF9yZWYyMC5nYXAsXG4gICAgICBnYXBQcm9wID0gX3JlZjIwJGdhcCA9PT0gdm9pZCAwID8gMTAgOiBfcmVmMjAkZ2FwLFxuICAgICAgX3JlZjIwJGxvb3AgPSBfcmVmMjAubG9vcCxcbiAgICAgIGxvb3BQcm9wID0gX3JlZjIwJGxvb3AgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIwJGxvb3AsXG4gICAgICBfcmVmMjAkc2Nyb2xsU25hcCA9IF9yZWYyMC5zY3JvbGxTbmFwLFxuICAgICAgc2Nyb2xsU25hcCA9IF9yZWYyMCRzY3JvbGxTbmFwID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIwJHNjcm9sbFNuYXAsXG4gICAgICBfcmVmMjAkaGlkZUFycm93ID0gX3JlZjIwLmhpZGVBcnJvdyxcbiAgICAgIGhpZGVBcnJvdyA9IF9yZWYyMCRoaWRlQXJyb3cgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIwJGhpZGVBcnJvdyxcbiAgICAgIF9yZWYyMCRzaG93RG90cyA9IF9yZWYyMC5zaG93RG90cyxcbiAgICAgIHNob3dEb3RzID0gX3JlZjIwJHNob3dEb3RzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyMCRzaG93RG90cyxcbiAgICAgIGF1dG9wbGF5UHJvcCA9IF9yZWYyMC5hdXRvcGxheSxcbiAgICAgIF9yZWYyMCRkb3RDb2xvckFjdGl2ZSA9IF9yZWYyMC5kb3RDb2xvckFjdGl2ZSxcbiAgICAgIGRvdENvbG9yQWN0aXZlID0gX3JlZjIwJGRvdENvbG9yQWN0aXZlID09PSB2b2lkIDAgPyAnIzc5NTU0OCcgOiBfcmVmMjAkZG90Q29sb3JBY3RpdmUsXG4gICAgICBfcmVmMjAkZG90Q29sb3JJbmFjdGkgPSBfcmVmMjAuZG90Q29sb3JJbmFjdGl2ZSxcbiAgICAgIGRvdENvbG9ySW5hY3RpdmUgPSBfcmVmMjAkZG90Q29sb3JJbmFjdGkgPT09IHZvaWQgMCA/ICcjY2NjJyA6IF9yZWYyMCRkb3RDb2xvckluYWN0aSxcbiAgICAgIHJlc3BvbnNpdmVMYXlvdXQgPSBfcmVmMjAucmVzcG9uc2l2ZUxheW91dCxcbiAgICAgIF9yZWYyMCRtb2JpbGVCcmVha3BvaSA9IF9yZWYyMC5tb2JpbGVCcmVha3BvaW50LFxuICAgICAgbW9iaWxlQnJlYWtwb2ludCA9IF9yZWYyMCRtb2JpbGVCcmVha3BvaSA9PT0gdm9pZCAwID8gNzY3IDogX3JlZjIwJG1vYmlsZUJyZWFrcG9pLFxuICAgICAgYXJyb3dMZWZ0ID0gX3JlZjIwLmFycm93TGVmdCxcbiAgICAgIGFycm93UmlnaHQgPSBfcmVmMjAuYXJyb3dSaWdodCxcbiAgICAgIGRvdCA9IF9yZWYyMC5kb3QsXG4gICAgICBfcmVmMjAkY29udGFpbmVyQ2xhc3MgPSBfcmVmMjAuY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgICAgY29udGFpbmVyQ2xhc3NOYW1lID0gX3JlZjIwJGNvbnRhaW5lckNsYXNzID09PSB2b2lkIDAgPyAnJyA6IF9yZWYyMCRjb250YWluZXJDbGFzcyxcbiAgICAgIF9yZWYyMCRjb250YWluZXJTdHlsZSA9IF9yZWYyMC5jb250YWluZXJTdHlsZSxcbiAgICAgIGNvbnRhaW5lclN0eWxlID0gX3JlZjIwJGNvbnRhaW5lclN0eWxlID09PSB2b2lkIDAgPyB7fSA6IF9yZWYyMCRjb250YWluZXJTdHlsZSxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjIwLmNoaWxkcmVuO1xuXG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSgwKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgY3VycmVudFBhZ2UgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0Q3VycmVudFBhZ2UgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX3VzZVN0YXRlNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTMsIDIpLFxuICAgICAgaXNIb3ZlciA9IF91c2VTdGF0ZTRbMF0sXG4gICAgICBzZXRJc0hvdmVyID0gX3VzZVN0YXRlNFsxXTtcblxuICB2YXIgX3VzZVN0YXRlNSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTYgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGU1LCAyKSxcbiAgICAgIGlzVG91Y2ggPSBfdXNlU3RhdGU2WzBdLFxuICAgICAgc2V0SXNUb3VjaCA9IF91c2VTdGF0ZTZbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTcgPSBSZWFjdC51c2VTdGF0ZShjb2xzUHJvcCksXG4gICAgICBfdXNlU3RhdGU4ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlNywgMiksXG4gICAgICBjb2xzID0gX3VzZVN0YXRlOFswXSxcbiAgICAgIHNldENvbHMgPSBfdXNlU3RhdGU4WzFdO1xuXG4gIHZhciBfdXNlU3RhdGU5ID0gUmVhY3QudXNlU3RhdGUocm93c1Byb3ApLFxuICAgICAgX3VzZVN0YXRlMTAgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGU5LCAyKSxcbiAgICAgIHJvd3MgPSBfdXNlU3RhdGUxMFswXSxcbiAgICAgIHNldFJvd3MgPSBfdXNlU3RhdGUxMFsxXTtcblxuICB2YXIgX3VzZVN0YXRlMTEgPSBSZWFjdC51c2VTdGF0ZSgwKSxcbiAgICAgIF91c2VTdGF0ZTEyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMTEsIDIpLFxuICAgICAgZ2FwID0gX3VzZVN0YXRlMTJbMF0sXG4gICAgICBzZXRHYXAgPSBfdXNlU3RhdGUxMlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMTMgPSBSZWFjdC51c2VTdGF0ZShsb29wUHJvcCksXG4gICAgICBfdXNlU3RhdGUxNCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTEzLCAyKSxcbiAgICAgIGxvb3AgPSBfdXNlU3RhdGUxNFswXSxcbiAgICAgIHNldExvb3AgPSBfdXNlU3RhdGUxNFsxXTtcblxuICB2YXIgX3VzZVN0YXRlMTUgPSBSZWFjdC51c2VTdGF0ZShhdXRvcGxheVByb3ApLFxuICAgICAgX3VzZVN0YXRlMTYgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUxNSwgMiksXG4gICAgICBhdXRvcGxheSA9IF91c2VTdGF0ZTE2WzBdLFxuICAgICAgc2V0QXV0b3BsYXkgPSBfdXNlU3RhdGUxNlsxXTtcblxuICB2YXIgX3VzZVN0YXRlMTcgPSBSZWFjdC51c2VTdGF0ZSgwKSxcbiAgICAgIF91c2VTdGF0ZTE4ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMTcsIDIpLFxuICAgICAgcmFpbFdyYXBwZXJXaWR0aCA9IF91c2VTdGF0ZTE4WzBdLFxuICAgICAgc2V0UmFpbFdyYXBwZXJXaWR0aCA9IF91c2VTdGF0ZTE4WzFdO1xuXG4gIHZhciBfdXNlU3RhdGUxOSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICAgIF91c2VTdGF0ZTIwID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMTksIDIpLFxuICAgICAgaGFzU2V0UmVzaXplSGFuZGxlciA9IF91c2VTdGF0ZTIwWzBdLFxuICAgICAgc2V0SGFzU2V0UmVzaXplSGFuZGxlciA9IF91c2VTdGF0ZTIwWzFdO1xuXG4gIHZhciByYWlsV3JhcHBlclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGF1dG9wbGF5SW50ZXJ2YWxSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHZhciBicmVha3BvaW50U2V0dGluZyA9IHVzZVJlc3BvbnNpdmVMYXlvdXQocmVzcG9uc2l2ZUxheW91dCk7XG4gIHZhciByYW5kb21LZXkgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJcIi5jb25jYXQoTWF0aC5yYW5kb20oKSwgXCItXCIpLmNvbmNhdChNYXRoLnJhbmRvbSgpKTtcbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHNtb290aHNjcm9sbC5wb2x5ZmlsbCgpO1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYyMSA9IGJyZWFrcG9pbnRTZXR0aW5nIHx8IHt9LFxuICAgICAgICBjb2xzID0gX3JlZjIxLmNvbHMsXG4gICAgICAgIHJvd3MgPSBfcmVmMjEucm93cyxcbiAgICAgICAgZ2FwID0gX3JlZjIxLmdhcCxcbiAgICAgICAgbG9vcCA9IF9yZWYyMS5sb29wLFxuICAgICAgICBhdXRvcGxheSA9IF9yZWYyMS5hdXRvcGxheTtcblxuICAgIHNldENvbHMoY29scyB8fCBjb2xzUHJvcCk7XG4gICAgc2V0Um93cyhyb3dzIHx8IHJvd3NQcm9wKTtcbiAgICBzZXRHYXAocGFyc2VHYXAoZ2FwIHx8IGdhcFByb3ApKTtcbiAgICBzZXRMb29wKGxvb3AgfHwgbG9vcFByb3ApO1xuICAgIHNldEF1dG9wbGF5KGF1dG9wbGF5IHx8IGF1dG9wbGF5UHJvcCk7XG4gICAgc2V0Q3VycmVudFBhZ2UoMCk7XG4gIH0sIFticmVha3BvaW50U2V0dGluZywgY29sc1Byb3AsIHJvd3NQcm9wLCBnYXBQcm9wLCBsb29wUHJvcCwgYXV0b3BsYXlQcm9wLCBwYXJzZUdhcF0pO1xuICB2YXIgaGFuZGxlUmFpbFdyYXBwZXJSZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmFpbFdyYXBwZXJSZWYuY3VycmVudCAmJiBzZXRSYWlsV3JhcHBlcldpZHRoKHJhaWxXcmFwcGVyUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGgpO1xuICB9LCBbcmFpbFdyYXBwZXJSZWZdKTtcbiAgdmFyIHNldFJlc2l6ZUhhbmRsZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgYWRkUmVzaXplSGFuZGxlcihcImdhcENhbGN1bGF0b3ItXCIuY29uY2F0KHJhbmRvbUtleSksIGhhbmRsZVJhaWxXcmFwcGVyUmVzaXplKTtcbiAgICBzZXRIYXNTZXRSZXNpemVIYW5kbGVyKHRydWUpO1xuICB9LCBbcmFuZG9tS2V5LCBoYW5kbGVSYWlsV3JhcHBlclJlc2l6ZV0pO1xuICB2YXIgcm1SZXNpemVIYW5kbGVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoXCJnYXBDYWxjdWxhdG9yLVwiLmNvbmNhdChyYW5kb21LZXkpKTtcbiAgICBzZXRIYXNTZXRSZXNpemVIYW5kbGVyKGZhbHNlKTtcbiAgfSwgW3JhbmRvbUtleV0pO1xuICB2YXIgcGFyc2VHYXAgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZ2FwKSB7XG4gICAgdmFyIHBhcnNlZCA9IGdhcDtcbiAgICB2YXIgc2hvdWxkU2V0UmVzaXplSGFuZGxlciA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBnYXAgIT09ICdudW1iZXInKSB7XG4gICAgICBzd2l0Y2ggKC9cXEQqJC8uZXhlYyhnYXApWzBdKSB7XG4gICAgICAgIGNhc2UgJ3B4JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYXJzZWQgPSArZ2FwLnJlcGxhY2UoJ3B4JywgJycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3cmFwcGVyV2lkdGggPSByYWlsV3JhcHBlcldpZHRoIHx8IHJhaWxXcmFwcGVyUmVmLmN1cnJlbnQgPyByYWlsV3JhcHBlclJlZi5jdXJyZW50Lm9mZnNldFdpZHRoIDogMDtcbiAgICAgICAgICAgIHBhcnNlZCA9IHdyYXBwZXJXaWR0aCAqIGdhcC5yZXBsYWNlKCclJywgJycpIC8gMTAwO1xuICAgICAgICAgICAgc2hvdWxkU2V0UmVzaXplSGFuZGxlciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYXJzZWQgPSAwO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRvZXNuJ3Qgc3VwcG9ydCB0aGUgcHJvdmlkZWQgbWVhc3VyZW1lbnQgdW5pdDogXCIuY29uY2F0KGdhcCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzaG91bGRTZXRSZXNpemVIYW5kbGVyICYmICFoYXNTZXRSZXNpemVIYW5kbGVyICYmIHNldFJlc2l6ZUhhbmRsZXIoKTtcbiAgICAhc2hvdWxkU2V0UmVzaXplSGFuZGxlciAmJiBoYXNTZXRSZXNpemVIYW5kbGVyICYmIHJtUmVzaXplSGFuZGxlcigpO1xuICAgIHJldHVybiBwYXJzZWQ7XG4gIH0sIFtyYWlsV3JhcHBlcldpZHRoLCByYWlsV3JhcHBlclJlZiwgaGFzU2V0UmVzaXplSGFuZGxlciwgc2V0UmVzaXplSGFuZGxlciwgcm1SZXNpemVIYW5kbGVyXSk7XG4gIHZhciBpdGVtTGlzdCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudHlwZS5kaXNwbGF5TmFtZSA9PT0gQ0FST1VTRUxfSVRFTTtcbiAgICB9KTtcbiAgfSwgW2NoaWxkcmVuXSk7XG4gIHZhciBpdGVtQW1vdW50UGVyU2V0ID0gY29scyAqIHJvd3M7XG4gIHZhciBpdGVtU2V0TGlzdCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpdGVtTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgaXRlbSwgaSkge1xuICAgICAgdmFyIGl0ZW1Db21wb25lbnQgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChJdGVtLCB7XG4gICAgICAgIGtleTogaSxcbiAgICAgICAgc2Nyb2xsU25hcDogc2Nyb2xsU25hcFxuICAgICAgfSwgaXRlbSk7XG5cbiAgICAgIGlmIChpICUgaXRlbUFtb3VudFBlclNldCA9PT0gMCkge1xuICAgICAgICByZXN1bHQucHVzaChbaXRlbUNvbXBvbmVudF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5wdXNoKGl0ZW1Db21wb25lbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgfSwgW2l0ZW1MaXN0LCBpdGVtQW1vdW50UGVyU2V0LCBzY3JvbGxTbmFwXSk7XG4gIHZhciBwYWdlID0gTWF0aC5jZWlsKGl0ZW1MaXN0Lmxlbmd0aCAvIGl0ZW1BbW91bnRQZXJTZXQpO1xuICB2YXIgaGFuZGxlUHJldiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZXRDdXJyZW50UGFnZShmdW5jdGlvbiAocCkge1xuICAgICAgdmFyIHByZXZQYWdlID0gcCAtIDE7XG5cbiAgICAgIGlmIChsb29wICYmIHByZXZQYWdlIDwgMCkge1xuICAgICAgICByZXR1cm4gcGFnZSAtIDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2UGFnZTtcbiAgICB9KTtcbiAgfSwgW2xvb3AsIHBhZ2VdKTtcbiAgdmFyIGhhbmRsZU5leHQgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzTW9iaWxlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgcmFpbFdyYXBwZXIgPSByYWlsV3JhcHBlclJlZi5jdXJyZW50O1xuXG4gICAgaWYgKGlzTW9iaWxlICYmIHJhaWxXcmFwcGVyKSB7XG4gICAgICBpZiAoIXNjcm9sbFNuYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IHJhaWxXcmFwcGVyLnNjcm9sbExlZnQsXG4gICAgICAgICAgb2Zmc2V0V2lkdGggPSByYWlsV3JhcHBlci5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBzY3JvbGxXaWR0aCA9IHJhaWxXcmFwcGVyLnNjcm9sbFdpZHRoO1xuICAgICAgcmFpbFdyYXBwZXIuc2Nyb2xsQnkoe1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IGxvb3AgJiYgc2Nyb2xsTGVmdCArIG9mZnNldFdpZHRoID49IHNjcm9sbFdpZHRoID8gLXNjcm9sbExlZnQgOiBzY3JvbGxMZWZ0ID09PSAwID8gZ2FwICsgKG9mZnNldFdpZHRoIC0gZ2FwKSAqIDAuOSAtIChvZmZzZXRXaWR0aCAqIDAuMSAtIGdhcCAqIDEuMSkgLyAyIDogKG9mZnNldFdpZHRoIC0gZ2FwKSAqIDAuOSArIGdhcCxcbiAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0Q3VycmVudFBhZ2UoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIG5leHRQYWdlID0gcCArIDE7XG5cbiAgICAgICAgaWYgKG5leHRQYWdlID49IHBhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbG9vcCA/IDAgOiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5leHRQYWdlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbbG9vcCwgcGFnZSwgZ2FwLCByYWlsV3JhcHBlclJlZiwgc2Nyb2xsU25hcF0pO1xuICB2YXIgc3RhcnRBdXRvcGxheUludGVydmFsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGlmIChhdXRvcGxheUludGVydmFsUmVmLmN1cnJlbnQgPT09IG51bGwgJiYgdHlwZW9mIGF1dG9wbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgYXV0b3BsYXlJbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBoYW5kbGVOZXh0KHdpbmRvdy5pbm5lcldpZHRoIDw9IG1vYmlsZUJyZWFrcG9pbnQpO1xuICAgICAgfSwgYXV0b3BsYXkpO1xuICAgIH1cbiAgfSwgW2F1dG9wbGF5LCBhdXRvcGxheUludGVydmFsUmVmLCBoYW5kbGVOZXh0LCBtb2JpbGVCcmVha3BvaW50XSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc3RhcnRBdXRvcGxheUludGVydmFsKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhdXRvcGxheUludGVydmFsUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChhdXRvcGxheUludGVydmFsUmVmLmN1cnJlbnQpO1xuICAgICAgICBhdXRvcGxheUludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtzdGFydEF1dG9wbGF5SW50ZXJ2YWwsIGF1dG9wbGF5SW50ZXJ2YWxSZWZdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNIb3ZlciB8fCBpc1RvdWNoKSB7XG4gICAgICBjbGVhckludGVydmFsKGF1dG9wbGF5SW50ZXJ2YWxSZWYuY3VycmVudCk7XG4gICAgICBhdXRvcGxheUludGVydmFsUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydEF1dG9wbGF5SW50ZXJ2YWwoKTtcbiAgICB9XG4gIH0sIFtpc0hvdmVyLCBpc1RvdWNoLCBhdXRvcGxheUludGVydmFsUmVmLCBzdGFydEF1dG9wbGF5SW50ZXJ2YWxdKTtcbiAgdmFyIHR1cm5Ub1BhZ2UgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAocGFnZSkge1xuICAgIHNldEN1cnJlbnRQYWdlKHBhZ2UpO1xuICB9LCBbXSk7XG4gIHZhciBoYW5kbGVIb3ZlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJc0hvdmVyKGZ1bmN0aW9uIChob3Zlcikge1xuICAgICAgcmV0dXJuICFob3ZlcjtcbiAgICB9KTtcbiAgfSwgW10pO1xuICB2YXIgaGFuZGxlVG91Y2ggPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgc2V0SXNUb3VjaChmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgIHJldHVybiAhdG91Y2g7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbnRhaW5lciwge1xuICAgIG9uTW91c2VFbnRlcjogaGFuZGxlSG92ZXIsXG4gICAgb25Nb3VzZUxlYXZlOiBoYW5kbGVIb3ZlcixcbiAgICBvblRvdWNoU3RhcnQ6IGhhbmRsZVRvdWNoLFxuICAgIG9uVG91Y2hFbmQ6IGhhbmRsZVRvdWNoLFxuICAgIGNsYXNzTmFtZTogY29udGFpbmVyQ2xhc3NOYW1lLFxuICAgIHN0eWxlOiBjb250YWluZXJTdHlsZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChBcnJvd0J1dHRvbiwge1xuICAgIHR5cGU6IFwicHJldlwiLFxuICAgIG1vYmlsZUJyZWFrcG9pbnQ6IG1vYmlsZUJyZWFrcG9pbnQsXG4gICAgaGlkZGVuOiBoaWRlQXJyb3cgfHwgIWxvb3AgJiYgY3VycmVudFBhZ2UgPD0gMCxcbiAgICBDdXN0b21CdG46IGFycm93TGVmdCxcbiAgICBvbkNsaWNrOiBoYW5kbGVQcmV2XG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSYWlsV3JhcHBlciwge1xuICAgIG1vYmlsZUJyZWFrcG9pbnQ6IG1vYmlsZUJyZWFrcG9pbnQsXG4gICAgc2Nyb2xsU25hcDogc2Nyb2xsU25hcCxcbiAgICBzaG93RG90czogc2hvd0RvdHMsXG4gICAgcmVmOiByYWlsV3JhcHBlclJlZlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSYWlsLCB7XG4gICAgY29sczogY29scyxcbiAgICByb3dzOiByb3dzLFxuICAgIHBhZ2U6IHBhZ2UsXG4gICAgZ2FwOiBnYXAsXG4gICAgY3VycmVudFBhZ2U6IGN1cnJlbnRQYWdlLFxuICAgIG1vYmlsZUJyZWFrcG9pbnQ6IG1vYmlsZUJyZWFrcG9pbnRcbiAgfSwgaXRlbVNldExpc3QubWFwKGZ1bmN0aW9uIChzZXQsIGkpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSXRlbVNldCwge1xuICAgICAga2V5OiBpLFxuICAgICAgY29sczogY29scyxcbiAgICAgIHJvd3M6IHJvd3MsXG4gICAgICBnYXA6IGdhcCxcbiAgICAgIG1vYmlsZUJyZWFrcG9pbnQ6IG1vYmlsZUJyZWFrcG9pbnRcbiAgICB9LCBzZXQpO1xuICB9KSkpLCBzaG93RG90cyAmJiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChEb3RzLCB7XG4gICAgbW9iaWxlQnJlYWtwb2ludDogbW9iaWxlQnJlYWtwb2ludFxuICB9LCBfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkocGFnZSkpLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChEb3QsIHtcbiAgICAgIGtleTogaSxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgaXNBY3RpdmU6IGkgPT09IGN1cnJlbnRQYWdlLFxuICAgICAgZG90Q29sb3JJbmFjdGl2ZTogZG90Q29sb3JJbmFjdGl2ZSxcbiAgICAgIGRvdENvbG9yQWN0aXZlOiBkb3RDb2xvckFjdGl2ZSxcbiAgICAgIGRvdDogZG90LFxuICAgICAgb25DbGljazogdHVyblRvUGFnZVxuICAgIH0pO1xuICB9KSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFycm93QnV0dG9uLCB7XG4gICAgdHlwZTogXCJuZXh0XCIsXG4gICAgbW9iaWxlQnJlYWtwb2ludDogbW9iaWxlQnJlYWtwb2ludCxcbiAgICBoaWRkZW46IGhpZGVBcnJvdyB8fCAhbG9vcCAmJiBjdXJyZW50UGFnZSA9PT0gcGFnZSAtIDEsXG4gICAgQ3VzdG9tQnRuOiBhcnJvd1JpZ2h0LFxuICAgIG9uQ2xpY2s6IGhhbmRsZU5leHQuYmluZChudWxsLCBmYWxzZSlcbiAgfSkpO1xufTtcblxuQ2Fyb3VzZWwuSXRlbSA9IGZ1bmN0aW9uIChfcmVmMjIpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZjIyLmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW47XG59O1xuXG5DYXJvdXNlbC5JdGVtLmRpc3BsYXlOYW1lID0gQ0FST1VTRUxfSVRFTTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYXJvdXNlbDtcbiJdLCJuYW1lcyI6WyJfaW50ZXJvcERlZmF1bHQiLCJleCIsIlJlYWN0IiwicmVxdWlyZSIsIlJlYWN0X19kZWZhdWx0Iiwic3R5bGVkIiwiUHJvcFR5cGVzIiwic21vb3Roc2Nyb2xsIiwiZGVib3VuY2UiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIl9zbGljZWRUb0FycmF5IiwiYXJyIiwiaSIsIl9hcnJheVdpdGhIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiQXJyYXkiLCJpc0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJpdGVyIiwiZnJvbSIsIl9pIiwiX2FyciIsIl9uIiwiX2QiLCJfcyIsIl9lIiwiY2FsbCIsIm5leHQiLCJkb25lIiwicHVzaCIsInZhbHVlIiwibGVuZ3RoIiwiZXJyIiwibyIsIm1pbkxlbiIsIm4iLCJPYmplY3QiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiVHlwZUVycm9yIiwiQnV0dG9uV3JhcHBlciIsImRpdiIsIndpdGhDb25maWciLCJkaXNwbGF5TmFtZSIsImNvbXBvbmVudElkIiwiX3JlZiIsIm1vYmlsZUJyZWFrcG9pbnQiLCJCdXR0b24iLCJzcGFuIiwiX3JlZjIiLCJ0eXBlIiwiX3JlZjMiLCJfcmVmNCIsIkFycm93QnV0dG9uIiwiX3JlZjUiLCJfcmVmNSRtb2JpbGVCcmVha3BvaW4iLCJfcmVmNSRoaWRkZW4iLCJoaWRkZW4iLCJDdXN0b21CdG4iLCJvbkNsaWNrIiwiY3JlYXRlRWxlbWVudCIsInByb3BUeXBlcyIsIm9uZU9mIiwiaXNSZXF1aXJlZCIsIm51bWJlciIsImJvb2wiLCJvbmVPZlR5cGUiLCJub2RlIiwiZWxlbWVudCIsImVsZW1lbnRUeXBlIiwiZnVuYyIsIkRvdFdyYXBwZXIiLCJEb3REZWZhdWx0IiwiY29sb3IiLCJEb3QiLCJpbmRleCIsIl9yZWYyJGlzQWN0aXZlIiwiaXNBY3RpdmUiLCJkb3RDb2xvckluYWN0aXZlIiwiZG90Q29sb3JBY3RpdmUiLCJEb3RDdXN0b20iLCJkb3QiLCJoYW5kbGVDbGljayIsInVzZUNhbGxiYWNrIiwic3RyaW5nIiwiSEFORExFUl9OQU1FX1NQQUNFIiwiaGFuZGxlUmVzaXplIiwiZSIsInZhbHVlcyIsIndpbmRvdyIsImZvckVhY2giLCJoYW5kbGVyIiwic2V0dXBMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRSZXNpemVIYW5kbGVyIiwia2V5IiwicmVtb3ZlUmVzaXplSGFuZGxlciIsImtleXMiLCJ1c2VSZXNwb25zaXZlTGF5b3V0IiwiYnJlYWtwb2ludExpc3QiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJfdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIl91c2VTdGF0ZTIiLCJjdXJyZW50QnJlYWtwb2ludFNldHRpbmciLCJzZXRDdXJyZW50QnJlYWtwb2ludFNldHRpbmciLCJyYW5kb20iLCJ1c2VNZW1vIiwiY29uY2F0IiwiTWF0aCIsInNvcnRlZEJyZWFrcG9pbnRMaXN0Iiwic29ydCIsImEiLCJiIiwiYnJlYWtwb2ludCIsIndpbmRvd1dpZHRoIiwiaW5uZXJXaWR0aCIsIm1hdGNoZWRTZXR0aW5nIiwiZmluZCIsInNldHRpbmciLCJ1c2VFZmZlY3QiLCJDb250YWluZXIiLCJSYWlsV3JhcHBlciIsInNob3dEb3RzIiwic2Nyb2xsU25hcCIsIlJhaWwiLCJnYXAiLCJwYWdlIiwiX3JlZjYiLCJjdXJyZW50UGFnZSIsIl9yZWY3IiwiX3JlZjgiLCJfcmVmOSIsIl9yZWYxMCIsImNvbHMiLCJyb3dzIiwiSXRlbVNldCIsIl9yZWYxMSIsIl9yZWYxMiIsIl9yZWYxMyIsIl9yZWYxNCIsIl9yZWYxNSIsIkl0ZW0iLCJfcmVmMTYiLCJfcmVmMTciLCJEb3RzIiwiX3JlZjE4IiwiX3JlZjE5IiwiQ0FST1VTRUxfSVRFTSIsIkNhcm91c2VsIiwiX3JlZjIwIiwiX3JlZjIwJGNvbHMiLCJjb2xzUHJvcCIsIl9yZWYyMCRyb3dzIiwicm93c1Byb3AiLCJfcmVmMjAkZ2FwIiwiZ2FwUHJvcCIsIl9yZWYyMCRsb29wIiwibG9vcCIsImxvb3BQcm9wIiwiX3JlZjIwJHNjcm9sbFNuYXAiLCJfcmVmMjAkaGlkZUFycm93IiwiaGlkZUFycm93IiwiX3JlZjIwJHNob3dEb3RzIiwiYXV0b3BsYXlQcm9wIiwiYXV0b3BsYXkiLCJfcmVmMjAkZG90Q29sb3JBY3RpdmUiLCJfcmVmMjAkZG90Q29sb3JJbmFjdGkiLCJyZXNwb25zaXZlTGF5b3V0IiwiX3JlZjIwJG1vYmlsZUJyZWFrcG9pIiwiYXJyb3dMZWZ0IiwiYXJyb3dSaWdodCIsIl9yZWYyMCRjb250YWluZXJDbGFzcyIsImNvbnRhaW5lckNsYXNzTmFtZSIsIl9yZWYyMCRjb250YWluZXJTdHlsZSIsImNvbnRhaW5lclN0eWxlIiwiY2hpbGRyZW4iLCJzZXRDdXJyZW50UGFnZSIsIl91c2VTdGF0ZTMiLCJfdXNlU3RhdGU0IiwiaXNIb3ZlciIsInNldElzSG92ZXIiLCJfdXNlU3RhdGU1IiwiX3VzZVN0YXRlNiIsImlzVG91Y2giLCJzZXRJc1RvdWNoIiwiX3VzZVN0YXRlNyIsIl91c2VTdGF0ZTgiLCJzZXRDb2xzIiwiX3VzZVN0YXRlOSIsIl91c2VTdGF0ZTEwIiwic2V0Um93cyIsIl91c2VTdGF0ZTExIiwiX3VzZVN0YXRlMTIiLCJzZXRHYXAiLCJfdXNlU3RhdGUxMyIsIl91c2VTdGF0ZTE0Iiwic2V0TG9vcCIsIl91c2VTdGF0ZTE1IiwiX3VzZVN0YXRlMTYiLCJzZXRBdXRvcGxheSIsIl91c2VTdGF0ZTE3IiwiX3VzZVN0YXRlMTgiLCJyYWlsV3JhcHBlcldpZHRoIiwic2V0UmFpbFdyYXBwZXJXaWR0aCIsIl91c2VTdGF0ZTE5IiwiX3VzZVN0YXRlMjAiLCJoYXNTZXRSZXNpemVIYW5kbGVyIiwic2V0SGFzU2V0UmVzaXplSGFuZGxlciIsInJhaWxXcmFwcGVyUmVmIiwidXNlUmVmIiwiYXV0b3BsYXlJbnRlcnZhbFJlZiIsImJyZWFrcG9pbnRTZXR0aW5nIiwicmFuZG9tS2V5IiwicG9seWZpbGwiLCJfcmVmMjEiLCJwYXJzZUdhcCIsImhhbmRsZVJhaWxXcmFwcGVyUmVzaXplIiwiY3VycmVudCIsIm9mZnNldFdpZHRoIiwic2V0UmVzaXplSGFuZGxlciIsInJtUmVzaXplSGFuZGxlciIsInBhcnNlZCIsInNob3VsZFNldFJlc2l6ZUhhbmRsZXIiLCJleGVjIiwicmVwbGFjZSIsIndyYXBwZXJXaWR0aCIsImNvbnNvbGUiLCJlcnJvciIsIml0ZW1MaXN0IiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiZmlsdGVyIiwiY2hpbGQiLCJpdGVtQW1vdW50UGVyU2V0IiwiaXRlbVNldExpc3QiLCJyZWR1Y2UiLCJyZXN1bHQiLCJpdGVtIiwiaXRlbUNvbXBvbmVudCIsImNlaWwiLCJoYW5kbGVQcmV2IiwicCIsInByZXZQYWdlIiwiaGFuZGxlTmV4dCIsImlzTW9iaWxlIiwicmFpbFdyYXBwZXIiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxCeSIsInRvcCIsImxlZnQiLCJiZWhhdmlvciIsIm5leHRQYWdlIiwic3RhcnRBdXRvcGxheUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidHVyblRvUGFnZSIsImhhbmRsZUhvdmVyIiwiaG92ZXIiLCJoYW5kbGVUb3VjaCIsInRvdWNoIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaEVuZCIsImNsYXNzTmFtZSIsInN0eWxlIiwicmVmIiwibWFwIiwic2V0IiwiXyIsImJpbmQiLCJfcmVmMjIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/dist/bundle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/better-react-carousel/node_modules/@emotion/unitless/dist/unitless.esm.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/better-react-carousel/node_modules/@emotion/unitless/dist/unitless.esm.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar unitlessKeys = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unitlessKeys);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9AZW1vdGlvbi91bml0bGVzcy9kaXN0L3VuaXRsZXNzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsZUFBZTtJQUNqQkMseUJBQXlCO0lBQ3pCQyxtQkFBbUI7SUFDbkJDLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyxTQUFTO0lBQ1RDLGNBQWM7SUFDZEMsaUJBQWlCO0lBQ2pCQyxhQUFhO0lBQ2JDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsWUFBWTtJQUNaQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxZQUFZO0lBQ1pDLGFBQWE7SUFDYkMsY0FBYztJQUNkQyxZQUFZO0lBQ1pDLGVBQWU7SUFDZkMsZ0JBQWdCO0lBQ2hCQyxpQkFBaUI7SUFDakJDLFdBQVc7SUFDWEMsZUFBZTtJQUNmQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsaUJBQWlCO0lBQ2pCLHlCQUF5QjtJQUN6QkMsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLGFBQWE7SUFDYkMsaUJBQWlCO0lBQ2pCQyxrQkFBa0I7SUFDbEJDLGtCQUFrQjtJQUNsQkMsZUFBZTtJQUNmQyxhQUFhO0FBQ2Y7QUFFQSxpRUFBZTdDLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kdWhhY2tzXzMvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9AZW1vdGlvbi91bml0bGVzcy9kaXN0L3VuaXRsZXNzLmVzbS5qcz84NDQ4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1bml0bGVzc0tleXMgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiAxLFxuICBib3JkZXJJbWFnZU91dHNldDogMSxcbiAgYm9yZGVySW1hZ2VTbGljZTogMSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogMSxcbiAgYm94RmxleDogMSxcbiAgYm94RmxleEdyb3VwOiAxLFxuICBib3hPcmRpbmFsR3JvdXA6IDEsXG4gIGNvbHVtbkNvdW50OiAxLFxuICBjb2x1bW5zOiAxLFxuICBmbGV4OiAxLFxuICBmbGV4R3JvdzogMSxcbiAgZmxleFBvc2l0aXZlOiAxLFxuICBmbGV4U2hyaW5rOiAxLFxuICBmbGV4TmVnYXRpdmU6IDEsXG4gIGZsZXhPcmRlcjogMSxcbiAgZ3JpZFJvdzogMSxcbiAgZ3JpZFJvd0VuZDogMSxcbiAgZ3JpZFJvd1NwYW46IDEsXG4gIGdyaWRSb3dTdGFydDogMSxcbiAgZ3JpZENvbHVtbjogMSxcbiAgZ3JpZENvbHVtbkVuZDogMSxcbiAgZ3JpZENvbHVtblNwYW46IDEsXG4gIGdyaWRDb2x1bW5TdGFydDogMSxcbiAgbXNHcmlkUm93OiAxLFxuICBtc0dyaWRSb3dTcGFuOiAxLFxuICBtc0dyaWRDb2x1bW46IDEsXG4gIG1zR3JpZENvbHVtblNwYW46IDEsXG4gIGZvbnRXZWlnaHQ6IDEsXG4gIGxpbmVIZWlnaHQ6IDEsXG4gIG9wYWNpdHk6IDEsXG4gIG9yZGVyOiAxLFxuICBvcnBoYW5zOiAxLFxuICB0YWJTaXplOiAxLFxuICB3aWRvd3M6IDEsXG4gIHpJbmRleDogMSxcbiAgem9vbTogMSxcbiAgV2Via2l0TGluZUNsYW1wOiAxLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBmbG9vZE9wYWNpdHk6IDEsXG4gIHN0b3BPcGFjaXR5OiAxLFxuICBzdHJva2VEYXNoYXJyYXk6IDEsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgZGVmYXVsdCB1bml0bGVzc0tleXM7XG4iXSwibmFtZXMiOlsidW5pdGxlc3NLZXlzIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3JkZXJJbWFnZU91dHNldCIsImJvcmRlckltYWdlU2xpY2UiLCJib3JkZXJJbWFnZVdpZHRoIiwiYm94RmxleCIsImJveEZsZXhHcm91cCIsImJveE9yZGluYWxHcm91cCIsImNvbHVtbkNvdW50IiwiY29sdW1ucyIsImZsZXgiLCJmbGV4R3JvdyIsImZsZXhQb3NpdGl2ZSIsImZsZXhTaHJpbmsiLCJmbGV4TmVnYXRpdmUiLCJmbGV4T3JkZXIiLCJncmlkUm93IiwiZ3JpZFJvd0VuZCIsImdyaWRSb3dTcGFuIiwiZ3JpZFJvd1N0YXJ0IiwiZ3JpZENvbHVtbiIsImdyaWRDb2x1bW5FbmQiLCJncmlkQ29sdW1uU3BhbiIsImdyaWRDb2x1bW5TdGFydCIsIm1zR3JpZFJvdyIsIm1zR3JpZFJvd1NwYW4iLCJtc0dyaWRDb2x1bW4iLCJtc0dyaWRDb2x1bW5TcGFuIiwiZm9udFdlaWdodCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJXZWJraXRMaW5lQ2xhbXAiLCJmaWxsT3BhY2l0eSIsImZsb29kT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VPcGFjaXR5Iiwic3Ryb2tlV2lkdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/node_modules/@emotion/unitless/dist/unitless.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/better-react-carousel/node_modules/styled-components/dist/styled-components.esm.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/better-react-carousel/node_modules/styled-components/dist/styled-components.esm.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServerStyleSheet: () => (/* binding */ ServerStyleSheet),\n/* harmony export */   StyleSheetConsumer: () => (/* binding */ StyleSheetConsumer),\n/* harmony export */   StyleSheetContext: () => (/* binding */ StyleSheetContext),\n/* harmony export */   StyleSheetManager: () => (/* binding */ StyleSheetManager),\n/* harmony export */   ThemeConsumer: () => (/* binding */ ThemeConsumer),\n/* harmony export */   ThemeContext: () => (/* binding */ ThemeContext),\n/* harmony export */   ThemeProvider: () => (/* binding */ ThemeProvider),\n/* harmony export */   __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS: () => (/* binding */ __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS),\n/* harmony export */   createGlobalStyle: () => (/* binding */ createGlobalStyle),\n/* harmony export */   css: () => (/* binding */ css),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   isStyledComponent: () => (/* binding */ isStyledComponent),\n/* harmony export */   keyframes: () => (/* binding */ keyframes),\n/* harmony export */   withTheme: () => (/* binding */ withTheme)\n/* harmony export */ });\n/* harmony import */ var stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stylis/stylis.min */ \"(ssr)/./node_modules/better-react-carousel/node_modules/stylis/stylis.min.js\");\n/* harmony import */ var stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stylis-rule-sheet */ \"(ssr)/./node_modules/better-react-carousel/node_modules/stylis-rule-sheet/index.js\");\n/* harmony import */ var stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/unitless */ \"(ssr)/./node_modules/better-react-carousel/node_modules/@emotion/unitless/dist/unitless.esm.js\");\n/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-is */ \"(ssr)/./node_modules/react-is/index.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @emotion/is-prop-valid */ \"(ssr)/./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\");\n/* harmony import */ var merge_anything__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! merge-anything */ \"(ssr)/./node_modules/merge-anything/dist/index.esm.js\");\n\n\n\n\n\n\n\n\n\n\n// \nvar interleave = function(strings, interpolations) {\n    var result = [\n        strings[0]\n    ];\n    for(var i = 0, len = interpolations.length; i < len; i += 1){\n        result.push(interpolations[i], strings[i + 1]);\n    }\n    return result;\n};\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n    return typeof obj;\n} : function(obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar classCallCheck = function(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n};\nvar createClass = function() {\n    function defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n}();\nvar _extends = Object.assign || function(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i];\n        for(var key in source){\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n};\nvar inherits = function(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\nvar objectWithoutProperties = function(obj, keys) {\n    var target = {};\n    for(var i in obj){\n        if (keys.indexOf(i) >= 0) continue;\n        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n        target[i] = obj[i];\n    }\n    return target;\n};\nvar possibleConstructorReturn = function(self, call) {\n    if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n// \nvar isPlainObject = function(x) {\n    return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.constructor === Object;\n};\n// \nvar EMPTY_ARRAY = Object.freeze([]);\nvar EMPTY_OBJECT = Object.freeze({});\n// \nfunction isFunction(test) {\n    return typeof test === \"function\";\n}\n// \nfunction getComponentName(target) {\n    return ( true ? typeof target === \"string\" && target : 0) || target.displayName || target.name || \"Component\";\n}\n// \nfunction isStatelessFunction(test) {\n    return typeof test === \"function\" && !(test.prototype && test.prototype.isReactComponent);\n}\n// \nfunction isStyledComponent(target) {\n    return target && typeof target.styledComponentId === \"string\";\n}\n// \nvar SC_ATTR = typeof process !== \"undefined\" && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || \"data-styled\";\nvar SC_VERSION_ATTR = \"data-styled-version\";\nvar SC_STREAM_ATTR = \"data-styled-streamed\";\nvar IS_BROWSER =  false && 0;\nvar DISABLE_SPEEDY = typeof SC_DISABLE_SPEEDY === \"boolean\" && SC_DISABLE_SPEEDY || typeof process !== \"undefined\" && (process.env.REACT_APP_SC_DISABLE_SPEEDY || process.env.SC_DISABLE_SPEEDY) || \"development\" !== \"production\";\n// Shared empty execution context when generating static styles\nvar STATIC_EXECUTION_CONTEXT = {};\n// \n/**\n * Parse errors.md and turn it into a simple hash of code: message\n */ var ERRORS =  true ? {\n    \"1\": \"Cannot create styled-component for component: %s.\\n\\n\",\n    \"2\": \"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\\n\\n- Are you trying to reuse it across renders?\\n- Are you accidentally calling collectStyles twice?\\n\\n\",\n    \"3\": \"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\\n\\n\",\n    \"4\": \"The `StyleSheetManager` expects a valid target or sheet prop!\\n\\n- Does this error occur on the client and is your target falsy?\\n- Does this error occur on the server and is the sheet falsy?\\n\\n\",\n    \"5\": \"The clone method cannot be used on the client!\\n\\n- Are you running in a client-like environment on the server?\\n- Are you trying to run SSR on the client?\\n\\n\",\n    \"6\": \"Trying to insert a new style tag, but the given Node is unmounted!\\n\\n- Are you using a custom target that isn't mounted?\\n- Does your document not have a valid head element?\\n- Have you accidentally removed a style tag manually?\\n\\n\",\n    \"7\": 'ThemeProvider: Please return an object from your \"theme\" prop function, e.g.\\n\\n```js\\ntheme={() => ({})}\\n```\\n\\n',\n    \"8\": 'ThemeProvider: Please make your \"theme\" prop an object.\\n\\n',\n    \"9\": \"Missing document `<head>`\\n\\n\",\n    \"10\": \"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\\n\\n\",\n    \"11\": \"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\\n\\n\",\n    \"12\": \"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\\\`\\\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\\n\\n\",\n    \"13\": \"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\\n\"\n} : 0;\n/**\n * super basic version of sprintf\n */ function format() {\n    var a = arguments.length <= 0 ? undefined : arguments[0];\n    var b = [];\n    for(var c = 1, len = arguments.length; c < len; c += 1){\n        b.push(arguments.length <= c ? undefined : arguments[c]);\n    }\n    b.forEach(function(d) {\n        a = a.replace(/%[a-z]/, d);\n    });\n    return a;\n}\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n */ var StyledComponentsError = function(_Error) {\n    inherits(StyledComponentsError, _Error);\n    function StyledComponentsError(code) {\n        classCallCheck(this, StyledComponentsError);\n        for(var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            interpolations[_key - 1] = arguments[_key];\n        }\n        if (false) { var _this; } else {\n            var _this = possibleConstructorReturn(this, _Error.call(this, format.apply(undefined, [\n                ERRORS[code]\n            ].concat(interpolations)).trim()));\n        }\n        return possibleConstructorReturn(_this);\n    }\n    return StyledComponentsError;\n}(Error);\n// \nvar SC_COMPONENT_ID = /^[^\\S\\n]*?\\/\\* sc-component-id:\\s*(\\S+)\\s+\\*\\//gm;\nvar extractComps = function(maybeCSS) {\n    var css = \"\" + (maybeCSS || \"\"); // Definitely a string, and a clone\n    var existingComponents = [];\n    css.replace(SC_COMPONENT_ID, function(match, componentId, matchIndex) {\n        existingComponents.push({\n            componentId: componentId,\n            matchIndex: matchIndex\n        });\n        return match;\n    });\n    return existingComponents.map(function(_ref, i) {\n        var componentId = _ref.componentId, matchIndex = _ref.matchIndex;\n        var nextComp = existingComponents[i + 1];\n        var cssFromDOM = nextComp ? css.slice(matchIndex, nextComp.matchIndex) : css.slice(matchIndex);\n        return {\n            componentId: componentId,\n            cssFromDOM: cssFromDOM\n        };\n    });\n};\n// \nvar COMMENT_REGEX = /^\\s*\\/\\/.*$/gm;\n// NOTE: This stylis instance is only used to split rules from SSR'd style tags\nvar stylisSplitter = new (stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default())({\n    global: false,\n    cascade: true,\n    keyframe: false,\n    prefix: false,\n    compress: false,\n    semicolon: true\n});\nvar stylis = new (stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default())({\n    global: false,\n    cascade: true,\n    keyframe: false,\n    prefix: true,\n    compress: false,\n    semicolon: false // NOTE: This means \"autocomplete missing semicolons\"\n});\n// Wrap `insertRulePlugin to build a list of rules,\n// and then make our own plugin to return the rules. This\n// makes it easier to hook into the existing SSR architecture\nvar parsingRules = [];\n// eslint-disable-next-line consistent-return\nvar returnRulesPlugin = function returnRulesPlugin(context) {\n    if (context === -2) {\n        var parsedRules = parsingRules;\n        parsingRules = [];\n        return parsedRules;\n    }\n};\nvar parseRulesPlugin = stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1___default()(function(rule) {\n    parsingRules.push(rule);\n});\nvar _componentId = void 0;\nvar _selector = void 0;\nvar _selectorRegexp = void 0;\nvar selfReferenceReplacer = function selfReferenceReplacer(match, offset, string) {\n    if (// the first self-ref is always untouched\n    offset > 0 && // there should be at least two self-refs to do a replacement (.b > .b)\n    string.slice(0, offset).indexOf(_selector) !== -1 && // no consecutive self refs (.b.b); that is a precedence boost and treated differently\n    string.slice(offset - _selector.length, offset) !== _selector) {\n        return \".\" + _componentId;\n    }\n    return match;\n};\n/**\n * When writing a style like\n *\n * & + & {\n *   color: red;\n * }\n *\n * The second ampersand should be a reference to the static component class. stylis\n * has no knowledge of static class so we have to intelligently replace the base selector.\n */ var selfReferenceReplacementPlugin = function selfReferenceReplacementPlugin(context, _, selectors) {\n    if (context === 2 && selectors.length && selectors[0].lastIndexOf(_selector) > 0) {\n        // eslint-disable-next-line no-param-reassign\n        selectors[0] = selectors[0].replace(_selectorRegexp, selfReferenceReplacer);\n    }\n};\nstylis.use([\n    selfReferenceReplacementPlugin,\n    parseRulesPlugin,\n    returnRulesPlugin\n]);\nstylisSplitter.use([\n    parseRulesPlugin,\n    returnRulesPlugin\n]);\nvar splitByRules = function splitByRules(css) {\n    return stylisSplitter(\"\", css);\n};\nfunction stringifyRules(rules, selector, prefix) {\n    var componentId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"&\";\n    var flatCSS = rules.join(\"\").replace(COMMENT_REGEX, \"\"); // replace JS comments\n    var cssStr = selector && prefix ? prefix + \" \" + selector + \" { \" + flatCSS + \" }\" : flatCSS;\n    // stylis has no concept of state to be passed to plugins\n    // but since JS is single=threaded, we can rely on that to ensure\n    // these properties stay in sync with the current stylis run\n    _componentId = componentId;\n    _selector = selector;\n    _selectorRegexp = new RegExp(\"\\\\\" + _selector + \"\\\\b\", \"g\");\n    return stylis(prefix || !selector ? \"\" : selector, cssStr);\n}\n// \n/* eslint-disable camelcase, no-undef */ var getNonce = function() {\n    return  true ? __webpack_require__.nc : 0;\n};\n// \n/* These are helpers for the StyleTags to keep track of the injected\n * rule names for each (component) ID that they're keeping track of.\n * They're crucial for detecting whether a name has already been\n * injected.\n * (This excludes rehydrated names) */ /* adds a new ID:name pairing to a names dictionary */ var addNameForId = function addNameForId(names, id, name) {\n    if (name) {\n        // eslint-disable-next-line no-param-reassign\n        var namesForId = names[id] || (names[id] = Object.create(null));\n        namesForId[name] = true;\n    }\n};\n/* resets an ID entirely by overwriting it in the dictionary */ var resetIdNames = function resetIdNames(names, id) {\n    // eslint-disable-next-line no-param-reassign\n    names[id] = Object.create(null);\n};\n/* factory for a names dictionary checking the existance of an ID:name pairing */ var hasNameForId = function hasNameForId(names) {\n    return function(id, name) {\n        return names[id] !== undefined && names[id][name];\n    };\n};\n/* stringifies names for the html/element output */ var stringifyNames = function stringifyNames(names) {\n    var str = \"\";\n    // eslint-disable-next-line guard-for-in\n    for(var id in names){\n        str += Object.keys(names[id]).join(\" \") + \" \";\n    }\n    return str.trim();\n};\n/* clones the nested names dictionary */ var cloneNames = function cloneNames(names) {\n    var clone = Object.create(null);\n    // eslint-disable-next-line guard-for-in\n    for(var id in names){\n        clone[id] = _extends({}, names[id]);\n    }\n    return clone;\n};\n// \n/* These are helpers that deal with the insertRule (aka speedy) API\n * They are used in the StyleTags and specifically the speedy tag\n */ /* retrieve a sheet for a given style tag */ var sheetForTag = function sheetForTag(tag) {\n    // $FlowFixMe\n    if (tag.sheet) return tag.sheet;\n    /* Firefox quirk requires us to step through all stylesheets to find one owned by the given tag */ var size = tag.ownerDocument.styleSheets.length;\n    for(var i = 0; i < size; i += 1){\n        var sheet = tag.ownerDocument.styleSheets[i];\n        // $FlowFixMe\n        if (sheet.ownerNode === tag) return sheet;\n    }\n    /* we should always be able to find a tag */ throw new StyledComponentsError(10);\n};\n/* insert a rule safely and return whether it was actually injected */ var safeInsertRule = function safeInsertRule(sheet, cssRule, index) {\n    /* abort early if cssRule string is falsy */ if (!cssRule) return false;\n    var maxIndex = sheet.cssRules.length;\n    try {\n        /* use insertRule and cap passed index with maxIndex (no of cssRules) */ sheet.insertRule(cssRule, index <= maxIndex ? index : maxIndex);\n    } catch (err) {\n        /* any error indicates an invalid rule */ return false;\n    }\n    return true;\n};\n/* deletes `size` rules starting from `removalIndex` */ var deleteRules = function deleteRules(sheet, removalIndex, size) {\n    var lowerBound = removalIndex - size;\n    for(var i = removalIndex; i > lowerBound; i -= 1){\n        sheet.deleteRule(i);\n    }\n};\n// \n/* this marker separates component styles and is important for rehydration */ var makeTextMarker = function makeTextMarker(id) {\n    return \"\\n/* sc-component-id: \" + id + \" */\\n\";\n};\n/* add up all numbers in array up until and including the index */ var addUpUntilIndex = function addUpUntilIndex(sizes, index) {\n    var totalUpToIndex = 0;\n    for(var i = 0; i <= index; i += 1){\n        totalUpToIndex += sizes[i];\n    }\n    return totalUpToIndex;\n};\n/* create a new style tag after lastEl */ var makeStyleTag = function makeStyleTag(target, tagEl, insertBefore) {\n    var targetDocument = document;\n    if (target) targetDocument = target.ownerDocument;\n    else if (tagEl) targetDocument = tagEl.ownerDocument;\n    var el = targetDocument.createElement(\"style\");\n    el.setAttribute(SC_ATTR, \"\");\n    el.setAttribute(SC_VERSION_ATTR, \"4.4.1\");\n    var nonce = getNonce();\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    /* Work around insertRule quirk in EdgeHTML */ el.appendChild(targetDocument.createTextNode(\"\"));\n    if (target && !tagEl) {\n        /* Append to target when no previous element was passed */ target.appendChild(el);\n    } else {\n        if (!tagEl || !target || !tagEl.parentNode) {\n            throw new StyledComponentsError(6);\n        }\n        /* Insert new style tag after the previous one */ tagEl.parentNode.insertBefore(el, insertBefore ? tagEl : tagEl.nextSibling);\n    }\n    return el;\n};\n/* takes a css factory function and outputs an html styled tag factory */ var wrapAsHtmlTag = function wrapAsHtmlTag(css, names) {\n    return function(additionalAttrs) {\n        var nonce = getNonce();\n        var attrs = [\n            nonce && 'nonce=\"' + nonce + '\"',\n            SC_ATTR + '=\"' + stringifyNames(names) + '\"',\n            SC_VERSION_ATTR + '=\"' + \"4.4.1\" + '\"',\n            additionalAttrs\n        ];\n        var htmlAttr = attrs.filter(Boolean).join(\" \");\n        return \"<style \" + htmlAttr + \">\" + css() + \"</style>\";\n    };\n};\n/* takes a css factory function and outputs an element factory */ var wrapAsElement = function wrapAsElement(css, names) {\n    return function() {\n        var _props;\n        var props = (_props = {}, _props[SC_ATTR] = stringifyNames(names), _props[SC_VERSION_ATTR] = \"4.4.1\", _props);\n        var nonce = getNonce();\n        if (nonce) {\n            // $FlowFixMe\n            props.nonce = nonce;\n        }\n        // eslint-disable-next-line react/no-danger\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(\"style\", _extends({}, props, {\n            dangerouslySetInnerHTML: {\n                __html: css()\n            }\n        }));\n    };\n};\nvar getIdsFromMarkersFactory = function getIdsFromMarkersFactory(markers) {\n    return function() {\n        return Object.keys(markers);\n    };\n};\n/* speedy tags utilise insertRule */ var makeSpeedyTag = function makeSpeedyTag(el, getImportRuleTag) {\n    var names = Object.create(null);\n    var markers = Object.create(null);\n    var sizes = [];\n    var extractImport = getImportRuleTag !== undefined;\n    /* indicates whether getImportRuleTag was called */ var usedImportRuleTag = false;\n    var insertMarker = function insertMarker(id) {\n        var prev = markers[id];\n        if (prev !== undefined) {\n            return prev;\n        }\n        markers[id] = sizes.length;\n        sizes.push(0);\n        resetIdNames(names, id);\n        return markers[id];\n    };\n    var insertRules = function insertRules(id, cssRules, name) {\n        var marker = insertMarker(id);\n        var sheet = sheetForTag(el);\n        var insertIndex = addUpUntilIndex(sizes, marker);\n        var injectedRules = 0;\n        var importRules = [];\n        var cssRulesSize = cssRules.length;\n        for(var i = 0; i < cssRulesSize; i += 1){\n            var cssRule = cssRules[i];\n            var mayHaveImport = extractImport; /* @import rules are reordered to appear first */ \n            if (mayHaveImport && cssRule.indexOf(\"@import\") !== -1) {\n                importRules.push(cssRule);\n            } else if (safeInsertRule(sheet, cssRule, insertIndex + injectedRules)) {\n                mayHaveImport = false;\n                injectedRules += 1;\n            }\n        }\n        if (extractImport && importRules.length > 0) {\n            usedImportRuleTag = true;\n            // $FlowFixMe\n            getImportRuleTag().insertRules(id + \"-import\", importRules);\n        }\n        sizes[marker] += injectedRules; /* add up no of injected rules */ \n        addNameForId(names, id, name);\n    };\n    var removeRules = function removeRules(id) {\n        var marker = markers[id];\n        if (marker === undefined) return;\n        // $FlowFixMe\n        if (el.isConnected === false) return;\n        var size = sizes[marker];\n        var sheet = sheetForTag(el);\n        var removalIndex = addUpUntilIndex(sizes, marker) - 1;\n        deleteRules(sheet, removalIndex, size);\n        sizes[marker] = 0;\n        resetIdNames(names, id);\n        if (extractImport && usedImportRuleTag) {\n            // $FlowFixMe\n            getImportRuleTag().removeRules(id + \"-import\");\n        }\n    };\n    var css = function css() {\n        var _sheetForTag = sheetForTag(el), cssRules = _sheetForTag.cssRules;\n        var str = \"\";\n        // eslint-disable-next-line guard-for-in\n        for(var id in markers){\n            str += makeTextMarker(id);\n            var marker = markers[id];\n            var end = addUpUntilIndex(sizes, marker);\n            var size = sizes[marker];\n            for(var i = end - size; i < end; i += 1){\n                var rule = cssRules[i];\n                if (rule !== undefined) {\n                    str += rule.cssText;\n                }\n            }\n        }\n        return str;\n    };\n    return {\n        clone: function clone() {\n            throw new StyledComponentsError(5);\n        },\n        css: css,\n        getIds: getIdsFromMarkersFactory(markers),\n        hasNameForId: hasNameForId(names),\n        insertMarker: insertMarker,\n        insertRules: insertRules,\n        removeRules: removeRules,\n        sealed: false,\n        styleTag: el,\n        toElement: wrapAsElement(css, names),\n        toHTML: wrapAsHtmlTag(css, names)\n    };\n};\nvar makeTextNode = function makeTextNode(targetDocument, id) {\n    return targetDocument.createTextNode(makeTextMarker(id));\n};\nvar makeBrowserTag = function makeBrowserTag(el, getImportRuleTag) {\n    var names = Object.create(null);\n    var markers = Object.create(null);\n    var extractImport = getImportRuleTag !== undefined;\n    /* indicates whether getImportRuleTag was called */ var usedImportRuleTag = false;\n    var insertMarker = function insertMarker(id) {\n        var prev = markers[id];\n        if (prev !== undefined) {\n            return prev;\n        }\n        markers[id] = makeTextNode(el.ownerDocument, id);\n        el.appendChild(markers[id]);\n        names[id] = Object.create(null);\n        return markers[id];\n    };\n    var insertRules = function insertRules(id, cssRules, name) {\n        var marker = insertMarker(id);\n        var importRules = [];\n        var cssRulesSize = cssRules.length;\n        for(var i = 0; i < cssRulesSize; i += 1){\n            var rule = cssRules[i];\n            var mayHaveImport = extractImport;\n            if (mayHaveImport && rule.indexOf(\"@import\") !== -1) {\n                importRules.push(rule);\n            } else {\n                mayHaveImport = false;\n                var separator = i === cssRulesSize - 1 ? \"\" : \" \";\n                marker.appendData(\"\" + rule + separator);\n            }\n        }\n        addNameForId(names, id, name);\n        if (extractImport && importRules.length > 0) {\n            usedImportRuleTag = true;\n            // $FlowFixMe\n            getImportRuleTag().insertRules(id + \"-import\", importRules);\n        }\n    };\n    var removeRules = function removeRules(id) {\n        var marker = markers[id];\n        if (marker === undefined) return;\n        /* create new empty text node and replace the current one */ var newMarker = makeTextNode(el.ownerDocument, id);\n        el.replaceChild(newMarker, marker);\n        markers[id] = newMarker;\n        resetIdNames(names, id);\n        if (extractImport && usedImportRuleTag) {\n            // $FlowFixMe\n            getImportRuleTag().removeRules(id + \"-import\");\n        }\n    };\n    var css = function css() {\n        var str = \"\";\n        // eslint-disable-next-line guard-for-in\n        for(var id in markers){\n            str += markers[id].data;\n        }\n        return str;\n    };\n    return {\n        clone: function clone() {\n            throw new StyledComponentsError(5);\n        },\n        css: css,\n        getIds: getIdsFromMarkersFactory(markers),\n        hasNameForId: hasNameForId(names),\n        insertMarker: insertMarker,\n        insertRules: insertRules,\n        removeRules: removeRules,\n        sealed: false,\n        styleTag: el,\n        toElement: wrapAsElement(css, names),\n        toHTML: wrapAsHtmlTag(css, names)\n    };\n};\nvar makeServerTag = function makeServerTag(namesArg, markersArg) {\n    var names = namesArg === undefined ? Object.create(null) : namesArg;\n    var markers = markersArg === undefined ? Object.create(null) : markersArg;\n    var insertMarker = function insertMarker(id) {\n        var prev = markers[id];\n        if (prev !== undefined) {\n            return prev;\n        }\n        return markers[id] = [\n            \"\"\n        ];\n    };\n    var insertRules = function insertRules(id, cssRules, name) {\n        var marker = insertMarker(id);\n        marker[0] += cssRules.join(\" \");\n        addNameForId(names, id, name);\n    };\n    var removeRules = function removeRules(id) {\n        var marker = markers[id];\n        if (marker === undefined) return;\n        marker[0] = \"\";\n        resetIdNames(names, id);\n    };\n    var css = function css() {\n        var str = \"\";\n        // eslint-disable-next-line guard-for-in\n        for(var id in markers){\n            var cssForId = markers[id][0];\n            if (cssForId) {\n                str += makeTextMarker(id) + cssForId;\n            }\n        }\n        return str;\n    };\n    var clone = function clone() {\n        var namesClone = cloneNames(names);\n        var markersClone = Object.create(null);\n        // eslint-disable-next-line guard-for-in\n        for(var id in markers){\n            markersClone[id] = [\n                markers[id][0]\n            ];\n        }\n        return makeServerTag(namesClone, markersClone);\n    };\n    var tag = {\n        clone: clone,\n        css: css,\n        getIds: getIdsFromMarkersFactory(markers),\n        hasNameForId: hasNameForId(names),\n        insertMarker: insertMarker,\n        insertRules: insertRules,\n        removeRules: removeRules,\n        sealed: false,\n        styleTag: null,\n        toElement: wrapAsElement(css, names),\n        toHTML: wrapAsHtmlTag(css, names)\n    };\n    return tag;\n};\nvar makeTag = function makeTag(target, tagEl, forceServer, insertBefore, getImportRuleTag) {\n    if (IS_BROWSER && !forceServer) {\n        var el = makeStyleTag(target, tagEl, insertBefore);\n        if (DISABLE_SPEEDY) {\n            return makeBrowserTag(el, getImportRuleTag);\n        } else {\n            return makeSpeedyTag(el, getImportRuleTag);\n        }\n    }\n    return makeServerTag();\n};\nvar rehydrate = function rehydrate(tag, els, extracted) {\n    /* add all extracted components to the new tag */ for(var i = 0, len = extracted.length; i < len; i += 1){\n        var _extracted$i = extracted[i], componentId = _extracted$i.componentId, cssFromDOM = _extracted$i.cssFromDOM;\n        var cssRules = splitByRules(cssFromDOM);\n        tag.insertRules(componentId, cssRules);\n    }\n    /* remove old HTMLStyleElements, since they have been rehydrated */ for(var _i = 0, _len = els.length; _i < _len; _i += 1){\n        var el = els[_i];\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n    }\n};\n// \nvar SPLIT_REGEX = /\\s+/;\n/* determine the maximum number of components before tags are sharded */ var MAX_SIZE = void 0;\nif (IS_BROWSER) {\n    /* in speedy mode we can keep a lot more rules in a sheet before a slowdown can be expected */ MAX_SIZE = DISABLE_SPEEDY ? 40 : 1000;\n} else {\n    /* for servers we do not need to shard at all */ MAX_SIZE = -1;\n}\nvar sheetRunningId = 0;\nvar master = void 0;\nvar StyleSheet = function() {\n    /* a map from ids to tags */ /* deferred rules for a given id */ /* this is used for not reinjecting rules via hasNameForId() */ /* when rules for an id are removed using remove() we have to ignore rehydratedNames for it */ /* a list of tags belonging to this StyleSheet */ /* a tag for import rules */ /* current capacity until a new tag must be created */ /* children (aka clones) of this StyleSheet inheriting all and future injections */ function StyleSheet() {\n        var _this = this;\n        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : IS_BROWSER ? document.head : null;\n        var forceServer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        classCallCheck(this, StyleSheet);\n        this.getImportRuleTag = function() {\n            var importRuleTag = _this.importRuleTag;\n            if (importRuleTag !== undefined) {\n                return importRuleTag;\n            }\n            var firstTag = _this.tags[0];\n            var insertBefore = true;\n            return _this.importRuleTag = makeTag(_this.target, firstTag ? firstTag.styleTag : null, _this.forceServer, insertBefore);\n        };\n        sheetRunningId += 1;\n        this.id = sheetRunningId;\n        this.forceServer = forceServer;\n        this.target = forceServer ? null : target;\n        this.tagMap = {};\n        this.deferred = {};\n        this.rehydratedNames = {};\n        this.ignoreRehydratedNames = {};\n        this.tags = [];\n        this.capacity = 1;\n        this.clones = [];\n    }\n    /* rehydrate all SSR'd style tags */ StyleSheet.prototype.rehydrate = function rehydrate$$1() {\n        if (!IS_BROWSER || this.forceServer) return this;\n        var els = [];\n        var extracted = [];\n        var isStreamed = false;\n        /* retrieve all of our SSR style elements from the DOM */ var nodes = document.querySelectorAll(\"style[\" + SC_ATTR + \"][\" + SC_VERSION_ATTR + '=\"' + \"4.4.1\" + '\"]');\n        var nodesSize = nodes.length;\n        /* abort rehydration if no previous style tags were found */ if (!nodesSize) return this;\n        for(var i = 0; i < nodesSize; i += 1){\n            var el = nodes[i];\n            /* check if style tag is a streamed tag */ if (!isStreamed) isStreamed = !!el.getAttribute(SC_STREAM_ATTR);\n            /* retrieve all component names */ var elNames = (el.getAttribute(SC_ATTR) || \"\").trim().split(SPLIT_REGEX);\n            var elNamesSize = elNames.length;\n            for(var j = 0, name; j < elNamesSize; j += 1){\n                name = elNames[j];\n                /* add rehydrated name to sheet to avoid re-adding styles */ this.rehydratedNames[name] = true;\n            }\n            /* extract all components and their CSS */ extracted.push.apply(extracted, extractComps(el.textContent));\n            /* store original HTMLStyleElement */ els.push(el);\n        }\n        /* abort rehydration if nothing was extracted */ var extractedSize = extracted.length;\n        if (!extractedSize) return this;\n        /* create a tag to be used for rehydration */ var tag = this.makeTag(null);\n        rehydrate(tag, els, extracted);\n        /* reset capacity and adjust MAX_SIZE by the initial size of the rehydration */ this.capacity = Math.max(1, MAX_SIZE - extractedSize);\n        this.tags.push(tag);\n        /* retrieve all component ids */ for(var _j = 0; _j < extractedSize; _j += 1){\n            this.tagMap[extracted[_j].componentId] = tag;\n        }\n        return this;\n    };\n    /* retrieve a \"master\" instance of StyleSheet which is typically used when no other is available\n   * The master StyleSheet is targeted by createGlobalStyle, keyframes, and components outside of any\n    * StyleSheetManager's context */ /* reset the internal \"master\" instance */ StyleSheet.reset = function reset() {\n        var forceServer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        master = new StyleSheet(undefined, forceServer).rehydrate();\n    };\n    /* adds \"children\" to the StyleSheet that inherit all of the parents' rules\n   * while their own rules do not affect the parent */ StyleSheet.prototype.clone = function clone() {\n        var sheet = new StyleSheet(this.target, this.forceServer);\n        /* add to clone array */ this.clones.push(sheet);\n        /* clone all tags */ sheet.tags = this.tags.map(function(tag) {\n            var ids = tag.getIds();\n            var newTag = tag.clone();\n            /* reconstruct tagMap */ for(var i = 0; i < ids.length; i += 1){\n                sheet.tagMap[ids[i]] = newTag;\n            }\n            return newTag;\n        });\n        /* clone other maps */ sheet.rehydratedNames = _extends({}, this.rehydratedNames);\n        sheet.deferred = _extends({}, this.deferred);\n        return sheet;\n    };\n    /* force StyleSheet to create a new tag on the next injection */ StyleSheet.prototype.sealAllTags = function sealAllTags() {\n        this.capacity = 1;\n        this.tags.forEach(function(tag) {\n            // eslint-disable-next-line no-param-reassign\n            tag.sealed = true;\n        });\n    };\n    StyleSheet.prototype.makeTag = function makeTag$$1(tag) {\n        var lastEl = tag ? tag.styleTag : null;\n        var insertBefore = false;\n        return makeTag(this.target, lastEl, this.forceServer, insertBefore, this.getImportRuleTag);\n    };\n    /* get a tag for a given componentId, assign the componentId to one, or shard */ StyleSheet.prototype.getTagForId = function getTagForId(id) {\n        /* simply return a tag, when the componentId was already assigned one */ var prev = this.tagMap[id];\n        if (prev !== undefined && !prev.sealed) {\n            return prev;\n        }\n        var tag = this.tags[this.tags.length - 1];\n        /* shard (create a new tag) if the tag is exhausted (See MAX_SIZE) */ this.capacity -= 1;\n        if (this.capacity === 0) {\n            this.capacity = MAX_SIZE;\n            tag = this.makeTag(tag);\n            this.tags.push(tag);\n        }\n        return this.tagMap[id] = tag;\n    };\n    /* mainly for createGlobalStyle to check for its id */ StyleSheet.prototype.hasId = function hasId(id) {\n        return this.tagMap[id] !== undefined;\n    };\n    /* caching layer checking id+name to already have a corresponding tag and injected rules */ StyleSheet.prototype.hasNameForId = function hasNameForId(id, name) {\n        /* exception for rehydrated names which are checked separately */ if (this.ignoreRehydratedNames[id] === undefined && this.rehydratedNames[name]) {\n            return true;\n        }\n        var tag = this.tagMap[id];\n        return tag !== undefined && tag.hasNameForId(id, name);\n    };\n    /* registers a componentId and registers it on its tag */ StyleSheet.prototype.deferredInject = function deferredInject(id, cssRules) {\n        /* don't inject when the id is already registered */ if (this.tagMap[id] !== undefined) return;\n        var clones = this.clones;\n        for(var i = 0; i < clones.length; i += 1){\n            clones[i].deferredInject(id, cssRules);\n        }\n        this.getTagForId(id).insertMarker(id);\n        this.deferred[id] = cssRules;\n    };\n    /* injects rules for a given id with a name that will need to be cached */ StyleSheet.prototype.inject = function inject(id, cssRules, name) {\n        var clones = this.clones;\n        for(var i = 0; i < clones.length; i += 1){\n            clones[i].inject(id, cssRules, name);\n        }\n        var tag = this.getTagForId(id);\n        /* add deferred rules for component */ if (this.deferred[id] !== undefined) {\n            // Combine passed cssRules with previously deferred CSS rules\n            // NOTE: We cannot mutate the deferred array itself as all clones\n            // do the same (see clones[i].inject)\n            var rules = this.deferred[id].concat(cssRules);\n            tag.insertRules(id, rules, name);\n            this.deferred[id] = undefined;\n        } else {\n            tag.insertRules(id, cssRules, name);\n        }\n    };\n    /* removes all rules for a given id, which doesn't remove its marker but resets it */ StyleSheet.prototype.remove = function remove(id) {\n        var tag = this.tagMap[id];\n        if (tag === undefined) return;\n        var clones = this.clones;\n        for(var i = 0; i < clones.length; i += 1){\n            clones[i].remove(id);\n        }\n        /* remove all rules from the tag */ tag.removeRules(id);\n        /* ignore possible rehydrated names */ this.ignoreRehydratedNames[id] = true;\n        /* delete possible deferred rules */ this.deferred[id] = undefined;\n    };\n    StyleSheet.prototype.toHTML = function toHTML() {\n        return this.tags.map(function(tag) {\n            return tag.toHTML();\n        }).join(\"\");\n    };\n    StyleSheet.prototype.toReactElements = function toReactElements() {\n        var id = this.id;\n        return this.tags.map(function(tag, i) {\n            var key = \"sc-\" + id + \"-\" + i;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.cloneElement)(tag.toElement(), {\n                key: key\n            });\n        });\n    };\n    createClass(StyleSheet, null, [\n        {\n            key: \"master\",\n            get: function get$$1() {\n                return master || (master = new StyleSheet().rehydrate());\n            }\n        },\n        {\n            key: \"instance\",\n            get: function get$$1() {\n                return StyleSheet.master;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\n// \nvar Keyframes = function() {\n    function Keyframes(name, rules) {\n        var _this = this;\n        classCallCheck(this, Keyframes);\n        this.inject = function(styleSheet) {\n            if (!styleSheet.hasNameForId(_this.id, _this.name)) {\n                styleSheet.inject(_this.id, _this.rules, _this.name);\n            }\n        };\n        this.toString = function() {\n            throw new StyledComponentsError(12, String(_this.name));\n        };\n        this.name = name;\n        this.rules = rules;\n        this.id = \"sc-keyframes-\" + name;\n    }\n    Keyframes.prototype.getName = function getName() {\n        return this.name;\n    };\n    return Keyframes;\n}();\n// \n/**\n * inlined version of\n * https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/hyphenateStyleName.js\n */ var uppercasePattern = /([A-Z])/g;\nvar msPattern = /^ms-/;\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */ function hyphenateStyleName(string) {\n    return string.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n}\n// \n// Taken from https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/dangerousStyleValue.js\nfunction addUnitIfNeeded(name, value) {\n    // https://github.com/amilajack/eslint-plugin-flowtype-errors/issues/133\n    // $FlowFixMe\n    if (value == null || typeof value === \"boolean\" || value === \"\") {\n        return \"\";\n    }\n    if (typeof value === \"number\" && value !== 0 && !(name in _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) {\n        return value + \"px\"; // Presumes implicit 'px' suffix for unitless numbers\n    }\n    return String(value).trim();\n}\n// \n/**\n * It's falsish not falsy because 0 is allowed.\n */ var isFalsish = function isFalsish(chunk) {\n    return chunk === undefined || chunk === null || chunk === false || chunk === \"\";\n};\nvar objToCssArray = function objToCssArray(obj, prevKey) {\n    var rules = [];\n    var keys = Object.keys(obj);\n    keys.forEach(function(key) {\n        if (!isFalsish(obj[key])) {\n            if (isPlainObject(obj[key])) {\n                rules.push.apply(rules, objToCssArray(obj[key], key));\n                return rules;\n            } else if (isFunction(obj[key])) {\n                rules.push(hyphenateStyleName(key) + \":\", obj[key], \";\");\n                return rules;\n            }\n            rules.push(hyphenateStyleName(key) + \": \" + addUnitIfNeeded(key, obj[key]) + \";\");\n        }\n        return rules;\n    });\n    return prevKey ? [\n        prevKey + \" {\"\n    ].concat(rules, [\n        \"}\"\n    ]) : rules;\n};\nfunction flatten(chunk, executionContext, styleSheet) {\n    if (Array.isArray(chunk)) {\n        var ruleSet = [];\n        for(var i = 0, len = chunk.length, result; i < len; i += 1){\n            result = flatten(chunk[i], executionContext, styleSheet);\n            if (result === null) continue;\n            else if (Array.isArray(result)) ruleSet.push.apply(ruleSet, result);\n            else ruleSet.push(result);\n        }\n        return ruleSet;\n    }\n    if (isFalsish(chunk)) {\n        return null;\n    }\n    /* Handle other components */ if (isStyledComponent(chunk)) {\n        return \".\" + chunk.styledComponentId;\n    }\n    /* Either execute or defer the function */ if (isFunction(chunk)) {\n        if (isStatelessFunction(chunk) && executionContext) {\n            var _result = chunk(executionContext);\n            if ( true && (0,react_is__WEBPACK_IMPORTED_MODULE_4__.isElement)(_result)) {\n                // eslint-disable-next-line no-console\n                console.warn(getComponentName(chunk) + \" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\");\n            }\n            return flatten(_result, executionContext, styleSheet);\n        } else return chunk;\n    }\n    if (chunk instanceof Keyframes) {\n        if (styleSheet) {\n            chunk.inject(styleSheet);\n            return chunk.getName();\n        } else return chunk;\n    }\n    /* Handle objects */ return isPlainObject(chunk) ? objToCssArray(chunk) : chunk.toString();\n}\n// \nfunction css(styles) {\n    for(var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        interpolations[_key - 1] = arguments[_key];\n    }\n    if (isFunction(styles) || isPlainObject(styles)) {\n        // $FlowFixMe\n        return flatten(interleave(EMPTY_ARRAY, [\n            styles\n        ].concat(interpolations)));\n    }\n    // $FlowFixMe\n    return flatten(interleave(styles, interpolations));\n}\n// \nfunction constructWithOptions(componentConstructor, tag) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;\n    if (!(0,react_is__WEBPACK_IMPORTED_MODULE_4__.isValidElementType)(tag)) {\n        throw new StyledComponentsError(1, String(tag));\n    }\n    /* This is callable directly as a template function */ // $FlowFixMe: Not typed to avoid destructuring arguments\n    var templateFunction = function templateFunction() {\n        return componentConstructor(tag, options, css.apply(undefined, arguments));\n    };\n    /* If config methods are called, wrap up a new template function and merge options */ templateFunction.withConfig = function(config) {\n        return constructWithOptions(componentConstructor, tag, _extends({}, options, config));\n    };\n    /* Modify/inject new props at runtime */ templateFunction.attrs = function(attrs) {\n        return constructWithOptions(componentConstructor, tag, _extends({}, options, {\n            attrs: Array.prototype.concat(options.attrs, attrs).filter(Boolean)\n        }));\n    };\n    return templateFunction;\n}\n// \n// Source: https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js\nfunction murmurhash(c) {\n    for(var e = c.length | 0, a = e | 0, d = 0, b; e >= 4;){\n        b = c.charCodeAt(d) & 255 | (c.charCodeAt(++d) & 255) << 8 | (c.charCodeAt(++d) & 255) << 16 | (c.charCodeAt(++d) & 255) << 24, b = 1540483477 * (b & 65535) + ((1540483477 * (b >>> 16) & 65535) << 16), b ^= b >>> 24, b = 1540483477 * (b & 65535) + ((1540483477 * (b >>> 16) & 65535) << 16), a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ b, e -= 4, ++d;\n    }\n    switch(e){\n        case 3:\n            a ^= (c.charCodeAt(d + 2) & 255) << 16;\n        case 2:\n            a ^= (c.charCodeAt(d + 1) & 255) << 8;\n        case 1:\n            a ^= c.charCodeAt(d) & 255, a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);\n    }\n    a ^= a >>> 13;\n    a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);\n    return (a ^ a >>> 15) >>> 0;\n}\n// \n/* eslint-disable no-bitwise */ /* This is the \"capacity\" of our alphabet i.e. 2x26 for all letters plus their capitalised\n * counterparts */ var charsLength = 52;\n/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */ var getAlphabeticChar = function getAlphabeticChar(code) {\n    return String.fromCharCode(code + (code > 25 ? 39 : 97));\n};\n/* input a number, usually a hash and convert it to base-52 */ function generateAlphabeticName(code) {\n    var name = \"\";\n    var x = void 0;\n    /* get a char and divide by alphabet-length */ for(x = code; x > charsLength; x = Math.floor(x / charsLength)){\n        name = getAlphabeticChar(x % charsLength) + name;\n    }\n    return getAlphabeticChar(x % charsLength) + name;\n}\n// \nfunction hasFunctionObjectKey(obj) {\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for(var key in obj){\n        if (isFunction(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isStaticRules(rules, attrs) {\n    for(var i = 0; i < rules.length; i += 1){\n        var rule = rules[i];\n        // recursive case\n        if (Array.isArray(rule) && !isStaticRules(rule, attrs)) {\n            return false;\n        } else if (isFunction(rule) && !isStyledComponent(rule)) {\n            // functions are allowed to be static if they're just being\n            // used to get the classname of a nested styled component\n            return false;\n        }\n    }\n    if (attrs.some(function(x) {\n        return isFunction(x) || hasFunctionObjectKey(x);\n    })) return false;\n    return true;\n}\n// \n/* combines hashStr (murmurhash) and nameGenerator for convenience */ var hasher = function hasher(str) {\n    return generateAlphabeticName(murmurhash(str));\n};\n/*\n ComponentStyle is all the CSS-specific stuff, not\n the React-specific stuff.\n */ var ComponentStyle = function() {\n    function ComponentStyle(rules, attrs, componentId) {\n        classCallCheck(this, ComponentStyle);\n        this.rules = rules;\n        this.isStatic =  false && 0;\n        this.componentId = componentId;\n        if (!StyleSheet.master.hasId(componentId)) {\n            StyleSheet.master.deferredInject(componentId, []);\n        }\n    }\n    /*\n   * Flattens a rule set into valid CSS\n   * Hashes it, wraps the whole chunk in a .hash1234 {}\n   * Returns the hash to be injected on render()\n   * */ ComponentStyle.prototype.generateAndInjectStyles = function generateAndInjectStyles(executionContext, styleSheet) {\n        var isStatic = this.isStatic, componentId = this.componentId, lastClassName = this.lastClassName;\n        if (IS_BROWSER && isStatic && typeof lastClassName === \"string\" && styleSheet.hasNameForId(componentId, lastClassName)) {\n            return lastClassName;\n        }\n        var flatCSS = flatten(this.rules, executionContext, styleSheet);\n        var name = hasher(this.componentId + flatCSS.join(\"\"));\n        if (!styleSheet.hasNameForId(componentId, name)) {\n            styleSheet.inject(this.componentId, stringifyRules(flatCSS, \".\" + name, undefined, componentId), name);\n        }\n        this.lastClassName = name;\n        return name;\n    };\n    ComponentStyle.generateName = function generateName(str) {\n        return hasher(str);\n    };\n    return ComponentStyle;\n}();\n// \nvar LIMIT = 200;\nvar createWarnTooManyClasses = function(displayName) {\n    var generatedClasses = {};\n    var warningSeen = false;\n    return function(className) {\n        if (!warningSeen) {\n            generatedClasses[className] = true;\n            if (Object.keys(generatedClasses).length >= LIMIT) {\n                // Unable to find latestRule in test environment.\n                /* eslint-disable no-console, prefer-template */ console.warn(\"Over \" + LIMIT + \" classes were generated for component \" + displayName + \". \\n\" + \"Consider using the attrs method, together with a style object for frequently changed styles.\\n\" + \"Example:\\n\" + \"  const Component = styled.div.attrs(props => ({\\n\" + \"    style: {\\n\" + \"      background: props.background,\\n\" + \"    },\\n\" + \"  }))`width: 100%;`\\n\\n\" + \"  <Component />\");\n                warningSeen = true;\n                generatedClasses = {};\n            }\n        }\n    };\n};\n// \nvar determineTheme = function(props, fallbackTheme) {\n    var defaultProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;\n    // Props should take precedence over ThemeProvider, which should take precedence over\n    // defaultProps, but React automatically puts defaultProps on props.\n    /* eslint-disable react/prop-types, flowtype-errors/show-errors */ var isDefaultTheme = defaultProps ? props.theme === defaultProps.theme : false;\n    var theme = props.theme && !isDefaultTheme ? props.theme : fallbackTheme || defaultProps.theme;\n    /* eslint-enable */ return theme;\n};\n// \nvar escapeRegex = /[[\\].#*$><+~=|^:(),\"'`-]+/g;\nvar dashesAtEnds = /(^-|-$)/g;\n/**\n * TODO: Explore using CSS.escape when it becomes more available\n * in evergreen browsers.\n */ function escape(str) {\n    return str// Replace all possible CSS selectors\n    .replace(escapeRegex, \"-\")// Remove extraneous hyphens at the start and end\n    .replace(dashesAtEnds, \"\");\n}\n// \nfunction isTag(target) {\n    return typeof target === \"string\" && ( true ? target.charAt(0) === target.charAt(0).toLowerCase() : 0);\n}\n// \nfunction generateDisplayName(target) {\n    // $FlowFixMe\n    return isTag(target) ? \"styled.\" + target : \"Styled(\" + getComponentName(target) + \")\";\n}\nvar _TYPE_STATICS;\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDerivedStateFromProps: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar TYPE_STATICS = (_TYPE_STATICS = {}, _TYPE_STATICS[react_is__WEBPACK_IMPORTED_MODULE_4__.ForwardRef] = {\n    $$typeof: true,\n    render: true\n}, _TYPE_STATICS);\nvar defineProperty$1 = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, _Object$getOwnPropert = Object.getOwnPropertySymbols, getOwnPropertySymbols = _Object$getOwnPropert === undefined ? function() {\n    return [];\n} : _Object$getOwnPropert, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = Object.prototype;\nvar arrayPrototype = Array.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== \"string\") {\n        // don't hoist over string (html) components\n        var inheritedComponent = getPrototypeOf(sourceComponent);\n        if (inheritedComponent && inheritedComponent !== objectPrototype) {\n            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n        }\n        var keys = arrayPrototype.concat(getOwnPropertyNames(sourceComponent), // $FlowFixMe\n        getOwnPropertySymbols(sourceComponent));\n        var targetStatics = TYPE_STATICS[targetComponent.$$typeof] || REACT_STATICS;\n        var sourceStatics = TYPE_STATICS[sourceComponent.$$typeof] || REACT_STATICS;\n        var i = keys.length;\n        var descriptor = void 0;\n        var key = void 0;\n        // eslint-disable-next-line no-plusplus\n        while(i--){\n            key = keys[i];\n            if (// $FlowFixMe\n            !KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && // $FlowFixMe\n            !(targetStatics && targetStatics[key])) {\n                descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                if (descriptor) {\n                    try {\n                        // Avoid failures from read-only properties\n                        defineProperty$1(targetComponent, key, descriptor);\n                    } catch (e) {\n                    /* fail silently */ }\n                }\n            }\n        }\n        return targetComponent;\n    }\n    return targetComponent;\n}\n// \nfunction isDerivedReactComponent(fn) {\n    return !!(fn && fn.prototype && fn.prototype.isReactComponent);\n}\n// \n// Helper to call a given function, only once\nvar once = function(cb) {\n    var called = false;\n    return function() {\n        if (!called) {\n            called = true;\n            cb.apply(undefined, arguments);\n        }\n    };\n};\n// \nvar ThemeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)();\nvar ThemeConsumer = ThemeContext.Consumer;\n/**\n * Provide a theme to an entire react component tree via context\n */ var ThemeProvider = function(_Component) {\n    inherits(ThemeProvider, _Component);\n    function ThemeProvider(props) {\n        classCallCheck(this, ThemeProvider);\n        var _this = possibleConstructorReturn(this, _Component.call(this, props));\n        _this.getContext = (0,memoize_one__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(_this.getContext.bind(_this));\n        _this.renderInner = _this.renderInner.bind(_this);\n        return _this;\n    }\n    ThemeProvider.prototype.render = function render() {\n        if (!this.props.children) return null;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeContext.Consumer, null, this.renderInner);\n    };\n    ThemeProvider.prototype.renderInner = function renderInner(outerTheme) {\n        var context = this.getContext(this.props.theme, outerTheme);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeContext.Provider, {\n            value: context\n        }, this.props.children);\n    };\n    /**\n   * Get the theme from the props, supporting both (outerTheme) => {}\n   * as well as object notation\n   */ ThemeProvider.prototype.getTheme = function getTheme(theme, outerTheme) {\n        if (isFunction(theme)) {\n            var mergedTheme = theme(outerTheme);\n            if ( true && (mergedTheme === null || Array.isArray(mergedTheme) || (typeof mergedTheme === \"undefined\" ? \"undefined\" : _typeof(mergedTheme)) !== \"object\")) {\n                throw new StyledComponentsError(7);\n            }\n            return mergedTheme;\n        }\n        if (theme === null || Array.isArray(theme) || (typeof theme === \"undefined\" ? \"undefined\" : _typeof(theme)) !== \"object\") {\n            throw new StyledComponentsError(8);\n        }\n        return _extends({}, outerTheme, theme);\n    };\n    ThemeProvider.prototype.getContext = function getContext(theme, outerTheme) {\n        return this.getTheme(theme, outerTheme);\n    };\n    return ThemeProvider;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\n// \nvar CLOSING_TAG_R = /^\\s*<\\/[a-z]/i;\nvar ServerStyleSheet = function() {\n    function ServerStyleSheet() {\n        classCallCheck(this, ServerStyleSheet);\n        /* The master sheet might be reset, so keep a reference here */ this.masterSheet = StyleSheet.master;\n        this.instance = this.masterSheet.clone();\n        this.sealed = false;\n    }\n    /**\n   * Mark the ServerStyleSheet as being fully emitted and manually GC it from the\n   * StyleSheet singleton.\n   */ ServerStyleSheet.prototype.seal = function seal() {\n        if (!this.sealed) {\n            /* Remove sealed StyleSheets from the master sheet */ var index = this.masterSheet.clones.indexOf(this.instance);\n            this.masterSheet.clones.splice(index, 1);\n            this.sealed = true;\n        }\n    };\n    ServerStyleSheet.prototype.collectStyles = function collectStyles(children) {\n        if (this.sealed) {\n            throw new StyledComponentsError(2);\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(StyleSheetManager, {\n            sheet: this.instance\n        }, children);\n    };\n    ServerStyleSheet.prototype.getStyleTags = function getStyleTags() {\n        this.seal();\n        return this.instance.toHTML();\n    };\n    ServerStyleSheet.prototype.getStyleElement = function getStyleElement() {\n        this.seal();\n        return this.instance.toReactElements();\n    };\n    ServerStyleSheet.prototype.interleaveWithNodeStream = function interleaveWithNodeStream(readableStream) {\n        var _this = this;\n        if (IS_BROWSER) {\n            throw new StyledComponentsError(3);\n        }\n        /* the tag index keeps track of which tags have already been emitted */ var instance = this.instance;\n        var instanceTagIndex = 0;\n        var streamAttr = SC_STREAM_ATTR + '=\"true\"';\n        var transformer = new (stream__WEBPACK_IMPORTED_MODULE_5___default().Transform)({\n            transform: function appendStyleChunks(chunk, /* encoding */ _, callback) {\n                var tags = instance.tags;\n                var html = \"\";\n                /* retrieve html for each new style tag */ for(; instanceTagIndex < tags.length; instanceTagIndex += 1){\n                    var tag = tags[instanceTagIndex];\n                    html += tag.toHTML(streamAttr);\n                }\n                /* force our StyleSheets to emit entirely new tags */ instance.sealAllTags();\n                var renderedHtml = chunk.toString();\n                /* prepend style html to chunk, unless the start of the chunk is a closing tag in which case append right after that */ if (CLOSING_TAG_R.test(renderedHtml)) {\n                    var endOfClosingTag = renderedHtml.indexOf(\">\");\n                    this.push(renderedHtml.slice(0, endOfClosingTag + 1) + html + renderedHtml.slice(endOfClosingTag + 1));\n                } else this.push(html + renderedHtml);\n                callback();\n            }\n        });\n        readableStream.on(\"end\", function() {\n            return _this.seal();\n        });\n        readableStream.on(\"error\", function(err) {\n            _this.seal();\n            // forward the error to the transform stream\n            transformer.emit(\"error\", err);\n        });\n        return readableStream.pipe(transformer);\n    };\n    return ServerStyleSheet;\n}();\n// \nvar StyleSheetContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)();\nvar StyleSheetConsumer = StyleSheetContext.Consumer;\nvar StyleSheetManager = function(_Component) {\n    inherits(StyleSheetManager, _Component);\n    function StyleSheetManager(props) {\n        classCallCheck(this, StyleSheetManager);\n        var _this = possibleConstructorReturn(this, _Component.call(this, props));\n        _this.getContext = (0,memoize_one__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(_this.getContext);\n        return _this;\n    }\n    StyleSheetManager.prototype.getContext = function getContext(sheet, target) {\n        if (sheet) {\n            return sheet;\n        } else if (target) {\n            return new StyleSheet(target);\n        } else {\n            throw new StyledComponentsError(4);\n        }\n    };\n    StyleSheetManager.prototype.render = function render() {\n        var _props = this.props, children = _props.children, sheet = _props.sheet, target = _props.target;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(StyleSheetContext.Provider, {\n            value: this.getContext(sheet, target)\n        },  true ? react__WEBPACK_IMPORTED_MODULE_2___default().Children.only(children) : 0);\n    };\n    return StyleSheetManager;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\n true ? StyleSheetManager.propTypes = {\n    sheet: prop_types__WEBPACK_IMPORTED_MODULE_9___default().oneOfType([\n        prop_types__WEBPACK_IMPORTED_MODULE_9___default().instanceOf(StyleSheet),\n        prop_types__WEBPACK_IMPORTED_MODULE_9___default().instanceOf(ServerStyleSheet)\n    ]),\n    target: prop_types__WEBPACK_IMPORTED_MODULE_9___default().shape({\n        appendChild: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func).isRequired\n    })\n} : 0;\n// \nvar identifiers = {};\n/* We depend on components having unique IDs */ function generateId(_ComponentStyle, _displayName, parentComponentId) {\n    var displayName = typeof _displayName !== \"string\" ? \"sc\" : escape(_displayName);\n    /**\n   * This ensures uniqueness if two components happen to share\n   * the same displayName.\n   */ var nr = (identifiers[displayName] || 0) + 1;\n    identifiers[displayName] = nr;\n    var componentId = displayName + \"-\" + _ComponentStyle.generateName(displayName + nr);\n    return parentComponentId ? parentComponentId + \"-\" + componentId : componentId;\n}\n// $FlowFixMe\nvar StyledComponent = function(_Component) {\n    inherits(StyledComponent, _Component);\n    function StyledComponent() {\n        classCallCheck(this, StyledComponent);\n        var _this = possibleConstructorReturn(this, _Component.call(this));\n        _this.attrs = {};\n        _this.renderOuter = _this.renderOuter.bind(_this);\n        _this.renderInner = _this.renderInner.bind(_this);\n        if (true) {\n            _this.warnInnerRef = once(function(displayName) {\n                return(// eslint-disable-next-line no-console\n                console.warn('The \"innerRef\" API has been removed in styled-components v4 in favor of React 16 ref forwarding, use \"ref\" instead like a typical component. \"innerRef\" was detected on component \"' + displayName + '\".'));\n            });\n            _this.warnAttrsFnObjectKeyDeprecated = once(function(key, displayName) {\n                return(// eslint-disable-next-line no-console\n                console.warn('Functions as object-form attrs({}) keys are now deprecated and will be removed in a future version of styled-components. Switch to the new attrs(props => ({})) syntax instead for easier and more powerful composition. The attrs key in question is \"' + key + '\" on component \"' + displayName + '\".', \"\\n \" + new Error().stack));\n            });\n            _this.warnNonStyledComponentAttrsObjectKey = once(function(key, displayName) {\n                return(// eslint-disable-next-line no-console\n                console.warn(\"It looks like you've used a non styled-component as the value for the \\\"\" + key + '\" prop in an object-form attrs constructor of \"' + displayName + '\".\\n' + \"You should use the new function-form attrs constructor which avoids this issue: attrs(props => ({ yourStuff }))\\n\" + \"To continue using the deprecated object syntax, you'll need to wrap your component prop in a function to make it available inside the styled component (you'll still get the deprecation warning though.)\\n\" + (\"For example, { \" + key + \": () => InnerComponent } instead of { \" + key + \": InnerComponent }\")));\n            });\n        }\n        return _this;\n    }\n    StyledComponent.prototype.render = function render() {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(StyleSheetConsumer, null, this.renderOuter);\n    };\n    StyledComponent.prototype.renderOuter = function renderOuter() {\n        var styleSheet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : StyleSheet.master;\n        this.styleSheet = styleSheet;\n        // No need to subscribe a static component to theme changes, it won't change anything\n        if (this.props.forwardedComponent.componentStyle.isStatic) return this.renderInner();\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeConsumer, null, this.renderInner);\n    };\n    StyledComponent.prototype.renderInner = function renderInner(theme) {\n        var _props$forwardedCompo = this.props.forwardedComponent, componentStyle = _props$forwardedCompo.componentStyle, defaultProps = _props$forwardedCompo.defaultProps, displayName = _props$forwardedCompo.displayName, foldedComponentIds = _props$forwardedCompo.foldedComponentIds, styledComponentId = _props$forwardedCompo.styledComponentId, target = _props$forwardedCompo.target;\n        var generatedClassName = void 0;\n        if (componentStyle.isStatic) {\n            generatedClassName = this.generateAndInjectStyles(EMPTY_OBJECT, this.props);\n        } else {\n            generatedClassName = this.generateAndInjectStyles(determineTheme(this.props, theme, defaultProps) || EMPTY_OBJECT, this.props);\n        }\n        var elementToBeCreated = this.props.as || this.attrs.as || target;\n        var isTargetTag = isTag(elementToBeCreated);\n        var propsForElement = {};\n        var computedProps = _extends({}, this.props, this.attrs);\n        var key = void 0;\n        // eslint-disable-next-line guard-for-in\n        for(key in computedProps){\n            if ( true && key === \"innerRef\" && isTargetTag) {\n                this.warnInnerRef(displayName);\n            }\n            if (key === \"forwardedComponent\" || key === \"as\") {\n                continue;\n            } else if (key === \"forwardedRef\") propsForElement.ref = computedProps[key];\n            else if (key === \"forwardedAs\") propsForElement.as = computedProps[key];\n            else if (!isTargetTag || (0,_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(key)) {\n                // Don't pass through non HTML tags through to HTML elements\n                propsForElement[key] = computedProps[key];\n            }\n        }\n        if (this.props.style && this.attrs.style) {\n            propsForElement.style = _extends({}, this.attrs.style, this.props.style);\n        }\n        propsForElement.className = Array.prototype.concat(foldedComponentIds, styledComponentId, generatedClassName !== styledComponentId ? generatedClassName : null, this.props.className, this.attrs.className).filter(Boolean).join(\" \");\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)(elementToBeCreated, propsForElement);\n    };\n    StyledComponent.prototype.buildExecutionContext = function buildExecutionContext(theme, props, attrs) {\n        var _this2 = this;\n        var context = _extends({}, props, {\n            theme: theme\n        });\n        if (!attrs.length) return context;\n        this.attrs = {};\n        attrs.forEach(function(attrDef) {\n            var resolvedAttrDef = attrDef;\n            var attrDefWasFn = false;\n            var attr = void 0;\n            var key = void 0;\n            if (isFunction(resolvedAttrDef)) {\n                // $FlowFixMe\n                resolvedAttrDef = resolvedAttrDef(context);\n                attrDefWasFn = true;\n            }\n            /* eslint-disable guard-for-in */ // $FlowFixMe\n            for(key in resolvedAttrDef){\n                attr = resolvedAttrDef[key];\n                if (!attrDefWasFn) {\n                    if (isFunction(attr) && !isDerivedReactComponent(attr) && !isStyledComponent(attr)) {\n                        if (true) {\n                            _this2.warnAttrsFnObjectKeyDeprecated(key, props.forwardedComponent.displayName);\n                        }\n                        attr = attr(context);\n                        if ( true && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().isValidElement(attr)) {\n                            _this2.warnNonStyledComponentAttrsObjectKey(key, props.forwardedComponent.displayName);\n                        }\n                    }\n                }\n                _this2.attrs[key] = attr;\n                context[key] = attr;\n            }\n        /* eslint-enable */ });\n        return context;\n    };\n    StyledComponent.prototype.generateAndInjectStyles = function generateAndInjectStyles(theme, props) {\n        var _props$forwardedCompo2 = props.forwardedComponent, attrs = _props$forwardedCompo2.attrs, componentStyle = _props$forwardedCompo2.componentStyle, warnTooManyClasses = _props$forwardedCompo2.warnTooManyClasses;\n        // statically styled-components don't need to build an execution context object,\n        // and shouldn't be increasing the number of class names\n        if (componentStyle.isStatic && !attrs.length) {\n            return componentStyle.generateAndInjectStyles(EMPTY_OBJECT, this.styleSheet);\n        }\n        var className = componentStyle.generateAndInjectStyles(this.buildExecutionContext(theme, props, attrs), this.styleSheet);\n        if ( true && warnTooManyClasses) warnTooManyClasses(className);\n        return className;\n    };\n    return StyledComponent;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\nfunction createStyledComponent(target, options, rules) {\n    var isTargetStyledComp = isStyledComponent(target);\n    var isClass = !isTag(target);\n    var _options$displayName = options.displayName, displayName = _options$displayName === undefined ? generateDisplayName(target) : _options$displayName, _options$componentId = options.componentId, componentId = _options$componentId === undefined ? generateId(ComponentStyle, options.displayName, options.parentComponentId) : _options$componentId, _options$ParentCompon = options.ParentComponent, ParentComponent = _options$ParentCompon === undefined ? StyledComponent : _options$ParentCompon, _options$attrs = options.attrs, attrs = _options$attrs === undefined ? EMPTY_ARRAY : _options$attrs;\n    var styledComponentId = options.displayName && options.componentId ? escape(options.displayName) + \"-\" + options.componentId : options.componentId || componentId;\n    // fold the underlying StyledComponent attrs up (implicit extend)\n    var finalAttrs = // $FlowFixMe\n    isTargetStyledComp && target.attrs ? Array.prototype.concat(target.attrs, attrs).filter(Boolean) : attrs;\n    var componentStyle = new ComponentStyle(isTargetStyledComp ? // $FlowFixMe\n    target.componentStyle.rules.concat(rules) : rules, finalAttrs, styledComponentId);\n    /**\n   * forwardRef creates a new interim component, which we'll take advantage of\n   * instead of extending ParentComponent to create _another_ interim class\n   */ var WrappedStyledComponent = void 0;\n    var forwardRef = function forwardRef(props, ref) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ParentComponent, _extends({}, props, {\n            forwardedComponent: WrappedStyledComponent,\n            forwardedRef: ref\n        }));\n    };\n    forwardRef.displayName = displayName;\n    WrappedStyledComponent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().forwardRef(forwardRef);\n    WrappedStyledComponent.displayName = displayName;\n    // $FlowFixMe\n    WrappedStyledComponent.attrs = finalAttrs;\n    // $FlowFixMe\n    WrappedStyledComponent.componentStyle = componentStyle;\n    // $FlowFixMe\n    WrappedStyledComponent.foldedComponentIds = isTargetStyledComp ? Array.prototype.concat(target.foldedComponentIds, target.styledComponentId) : EMPTY_ARRAY;\n    // $FlowFixMe\n    WrappedStyledComponent.styledComponentId = styledComponentId;\n    // fold the underlying StyledComponent target up since we folded the styles\n    // $FlowFixMe\n    WrappedStyledComponent.target = isTargetStyledComp ? target.target : target;\n    // $FlowFixMe\n    WrappedStyledComponent.withComponent = function withComponent(tag) {\n        var previousComponentId = options.componentId, optionsToCopy = objectWithoutProperties(options, [\n            \"componentId\"\n        ]);\n        var newComponentId = previousComponentId && previousComponentId + \"-\" + (isTag(tag) ? tag : escape(getComponentName(tag)));\n        var newOptions = _extends({}, optionsToCopy, {\n            attrs: finalAttrs,\n            componentId: newComponentId,\n            ParentComponent: ParentComponent\n        });\n        return createStyledComponent(tag, newOptions, rules);\n    };\n    // $FlowFixMe\n    Object.defineProperty(WrappedStyledComponent, \"defaultProps\", {\n        get: function get$$1() {\n            return this._foldedDefaultProps;\n        },\n        set: function set$$1(obj) {\n            // $FlowFixMe\n            this._foldedDefaultProps = isTargetStyledComp ? (0,merge_anything__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(target.defaultProps, obj) : obj;\n        }\n    });\n    if (true) {\n        // $FlowFixMe\n        WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName);\n    }\n    // $FlowFixMe\n    WrappedStyledComponent.toString = function() {\n        return \".\" + WrappedStyledComponent.styledComponentId;\n    };\n    if (isClass) {\n        hoistNonReactStatics(WrappedStyledComponent, target, {\n            // all SC-specific things should not be hoisted\n            attrs: true,\n            componentStyle: true,\n            displayName: true,\n            foldedComponentIds: true,\n            styledComponentId: true,\n            target: true,\n            withComponent: true\n        });\n    }\n    return WrappedStyledComponent;\n}\n// \n// Thanks to ReactDOMFactories for this handy list!\nvar domElements = [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"base\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"keygen\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meta\",\n    \"meter\",\n    \"nav\",\n    \"noscript\",\n    \"object\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"param\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"script\",\n    \"section\",\n    \"select\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"title\",\n    \"tr\",\n    \"track\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\",\n    // SVG\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"ellipse\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"marker\",\n    \"mask\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"text\",\n    \"tspan\"\n];\n// \nvar styled = function styled(tag) {\n    return constructWithOptions(createStyledComponent, tag);\n};\n// Shorthands for all valid HTML Elements\ndomElements.forEach(function(domElement) {\n    styled[domElement] = styled(domElement);\n});\n// \nvar GlobalStyle = function() {\n    function GlobalStyle(rules, componentId) {\n        classCallCheck(this, GlobalStyle);\n        this.rules = rules;\n        this.componentId = componentId;\n        this.isStatic = isStaticRules(rules, EMPTY_ARRAY);\n        if (!StyleSheet.master.hasId(componentId)) {\n            StyleSheet.master.deferredInject(componentId, []);\n        }\n    }\n    GlobalStyle.prototype.createStyles = function createStyles(executionContext, styleSheet) {\n        var flatCSS = flatten(this.rules, executionContext, styleSheet);\n        var css = stringifyRules(flatCSS, \"\");\n        styleSheet.inject(this.componentId, css);\n    };\n    GlobalStyle.prototype.removeStyles = function removeStyles(styleSheet) {\n        var componentId = this.componentId;\n        if (styleSheet.hasId(componentId)) {\n            styleSheet.remove(componentId);\n        }\n    };\n    // TODO: overwrite in-place instead of remove+create?\n    GlobalStyle.prototype.renderStyles = function renderStyles(executionContext, styleSheet) {\n        this.removeStyles(styleSheet);\n        this.createStyles(executionContext, styleSheet);\n    };\n    return GlobalStyle;\n}();\n// \n// place our cache into shared context so it'll persist between HMRs\nif (IS_BROWSER) {\n    window.scCGSHMRCache = {};\n}\nfunction createGlobalStyle(strings) {\n    for(var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        interpolations[_key - 1] = arguments[_key];\n    }\n    var rules = css.apply(undefined, [\n        strings\n    ].concat(interpolations));\n    var id = \"sc-global-\" + murmurhash(JSON.stringify(rules));\n    var style = new GlobalStyle(rules, id);\n    var GlobalStyleComponent = function(_React$Component) {\n        inherits(GlobalStyleComponent, _React$Component);\n        function GlobalStyleComponent(props) {\n            classCallCheck(this, GlobalStyleComponent);\n            var _this = possibleConstructorReturn(this, _React$Component.call(this, props));\n            var _this$constructor = _this.constructor, globalStyle = _this$constructor.globalStyle, styledComponentId = _this$constructor.styledComponentId;\n            if (IS_BROWSER) {\n                window.scCGSHMRCache[styledComponentId] = (window.scCGSHMRCache[styledComponentId] || 0) + 1;\n            }\n            /**\n       * This fixes HMR compatibility. Don't ask me why, but this combination of\n       * caching the closure variables via statics and then persisting the statics in\n       * state works across HMR where no other combination did. \\_()_/\n       */ _this.state = {\n                globalStyle: globalStyle,\n                styledComponentId: styledComponentId\n            };\n            return _this;\n        }\n        GlobalStyleComponent.prototype.componentWillUnmount = function componentWillUnmount() {\n            if (window.scCGSHMRCache[this.state.styledComponentId]) {\n                window.scCGSHMRCache[this.state.styledComponentId] -= 1;\n            }\n            /**\n       * Depending on the order \"render\" is called this can cause the styles to be lost\n       * until the next render pass of the remaining instance, which may\n       * not be immediate.\n       */ if (window.scCGSHMRCache[this.state.styledComponentId] === 0) {\n                this.state.globalStyle.removeStyles(this.styleSheet);\n            }\n        };\n        GlobalStyleComponent.prototype.render = function render() {\n            var _this2 = this;\n            if ( true && react__WEBPACK_IMPORTED_MODULE_2___default().Children.count(this.props.children)) {\n                // eslint-disable-next-line no-console\n                console.warn(\"The global style component \" + this.state.styledComponentId + \" was given child JSX. createGlobalStyle does not render children.\");\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(StyleSheetConsumer, null, function(styleSheet) {\n                _this2.styleSheet = styleSheet || StyleSheet.master;\n                var globalStyle = _this2.state.globalStyle;\n                if (globalStyle.isStatic) {\n                    globalStyle.renderStyles(STATIC_EXECUTION_CONTEXT, _this2.styleSheet);\n                    return null;\n                } else {\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeConsumer, null, function(theme) {\n                        // $FlowFixMe\n                        var defaultProps = _this2.constructor.defaultProps;\n                        var context = _extends({}, _this2.props);\n                        if (typeof theme !== \"undefined\") {\n                            context.theme = determineTheme(_this2.props, theme, defaultProps);\n                        }\n                        globalStyle.renderStyles(context, _this2.styleSheet);\n                        return null;\n                    });\n                }\n            });\n        };\n        return GlobalStyleComponent;\n    }((react__WEBPACK_IMPORTED_MODULE_2___default().Component));\n    GlobalStyleComponent.globalStyle = style;\n    GlobalStyleComponent.styledComponentId = id;\n    return GlobalStyleComponent;\n}\n// \nvar replaceWhitespace = function replaceWhitespace(str) {\n    return str.replace(/\\s|\\\\n/g, \"\");\n};\nfunction keyframes(strings) {\n    /* Warning if you've used keyframes on React Native */ if ( true && typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n        // eslint-disable-next-line no-console\n        console.warn(\"`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.\");\n    }\n    for(var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        interpolations[_key - 1] = arguments[_key];\n    }\n    var rules = css.apply(undefined, [\n        strings\n    ].concat(interpolations));\n    var name = generateAlphabeticName(murmurhash(replaceWhitespace(JSON.stringify(rules))));\n    return new Keyframes(name, stringifyRules(rules, name, \"@keyframes\"));\n}\n// \nvar withTheme = function(Component$$1) {\n    var WithTheme = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().forwardRef(function(props, ref) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeConsumer, null, function(theme) {\n            // $FlowFixMe\n            var defaultProps = Component$$1.defaultProps;\n            var themeProp = determineTheme(props, theme, defaultProps);\n            if ( true && themeProp === undefined) {\n                // eslint-disable-next-line no-console\n                console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class \"' + getComponentName(Component$$1) + '\"');\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(Component$$1, _extends({}, props, {\n                theme: themeProp,\n                ref: ref\n            }));\n        });\n    });\n    hoistNonReactStatics(WithTheme, Component$$1);\n    WithTheme.displayName = \"WithTheme(\" + getComponentName(Component$$1) + \")\";\n    return WithTheme;\n};\n// \n/* eslint-disable */ var __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = {\n    StyleSheet: StyleSheet\n};\n// \n/* Warning if you've imported this file on React Native */ if ( true && typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    // eslint-disable-next-line no-console\n    console.warn(\"It looks like you've imported 'styled-components' on React Native.\\n\" + \"Perhaps you're looking to import 'styled-components/native'?\\n\" + \"Read more about this at https://www.styled-components.com/docs/basics#react-native\");\n}\n/* Warning if there are several instances of styled-components */ if (false) {}\n//\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styled);\n //# sourceMappingURL=styled-components.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9kaXN0L3N0eWxlZC1jb21wb25lbnRzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1QztBQUNXO0FBQ21DO0FBQzVDO0FBQzRCO0FBQ25DO0FBQ047QUFDTztBQUNZO0FBQ1o7QUFFbkMsR0FBRztBQUVILElBQUlnQixhQUFjLFNBQVVDLE9BQU8sRUFBRUMsY0FBYztJQUNqRCxJQUFJQyxTQUFTO1FBQUNGLE9BQU8sQ0FBQyxFQUFFO0tBQUM7SUFFekIsSUFBSyxJQUFJRyxJQUFJLEdBQUdDLE1BQU1ILGVBQWVJLE1BQU0sRUFBRUYsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1FBQzVERCxPQUFPSSxJQUFJLENBQUNMLGNBQWMsQ0FBQ0UsRUFBRSxFQUFFSCxPQUFPLENBQUNHLElBQUksRUFBRTtJQUMvQztJQUVBLE9BQU9EO0FBQ1Q7QUFFQSxJQUFJSyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssV0FBVyxTQUFVQyxHQUFHO0lBQy9GLE9BQU8sT0FBT0E7QUFDaEIsSUFBSSxTQUFVQSxHQUFHO0lBQ2YsT0FBT0EsT0FBTyxPQUFPRixXQUFXLGNBQWNFLElBQUlDLFdBQVcsS0FBS0gsVUFBVUUsUUFBUUYsT0FBT0ksU0FBUyxHQUFHLFdBQVcsT0FBT0Y7QUFDM0g7QUFFQSxJQUFJRyxpQkFBaUIsU0FBVUMsUUFBUSxFQUFFQyxXQUFXO0lBQ2xELElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFDdEMsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0FBQ0Y7QUFFQSxJQUFJQyxjQUFjO0lBQ2hCLFNBQVNDLGlCQUFpQkMsTUFBTSxFQUFFQyxLQUFLO1FBQ3JDLElBQUssSUFBSWpCLElBQUksR0FBR0EsSUFBSWlCLE1BQU1mLE1BQU0sRUFBRUYsSUFBSztZQUNyQyxJQUFJa0IsYUFBYUQsS0FBSyxDQUFDakIsRUFBRTtZQUN6QmtCLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1lBQ2pERCxXQUFXRSxZQUFZLEdBQUc7WUFDMUIsSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7WUFDakRDLE9BQU9DLGNBQWMsQ0FBQ1AsUUFBUUUsV0FBV00sR0FBRyxFQUFFTjtRQUNoRDtJQUNGO0lBRUEsT0FBTyxTQUFVTixXQUFXLEVBQUVhLFVBQVUsRUFBRUMsV0FBVztRQUNuRCxJQUFJRCxZQUFZVixpQkFBaUJILFlBQVlILFNBQVMsRUFBRWdCO1FBQ3hELElBQUlDLGFBQWFYLGlCQUFpQkgsYUFBYWM7UUFDL0MsT0FBT2Q7SUFDVDtBQUNGO0FBRUEsSUFBSWUsV0FBV0wsT0FBT00sTUFBTSxJQUFJLFNBQVVaLE1BQU07SUFDOUMsSUFBSyxJQUFJaEIsSUFBSSxHQUFHQSxJQUFJNkIsVUFBVTNCLE1BQU0sRUFBRUYsSUFBSztRQUN6QyxJQUFJOEIsU0FBU0QsU0FBUyxDQUFDN0IsRUFBRTtRQUV6QixJQUFLLElBQUl3QixPQUFPTSxPQUFRO1lBQ3RCLElBQUlSLE9BQU9iLFNBQVMsQ0FBQ3NCLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDRixRQUFRTixNQUFNO2dCQUNyRFIsTUFBTSxDQUFDUSxJQUFJLEdBQUdNLE1BQU0sQ0FBQ04sSUFBSTtZQUMzQjtRQUNGO0lBQ0Y7SUFFQSxPQUFPUjtBQUNUO0FBRUEsSUFBSWlCLFdBQVcsU0FBVUMsUUFBUSxFQUFFQyxVQUFVO0lBQzNDLElBQUksT0FBT0EsZUFBZSxjQUFjQSxlQUFlLE1BQU07UUFDM0QsTUFBTSxJQUFJdEIsVUFBVSw2REFBNkQsT0FBT3NCO0lBQzFGO0lBRUFELFNBQVN6QixTQUFTLEdBQUdhLE9BQU9jLE1BQU0sQ0FBQ0QsY0FBY0EsV0FBVzFCLFNBQVMsRUFBRTtRQUNyRUQsYUFBYTtZQUNYNkIsT0FBT0g7WUFDUGYsWUFBWTtZQUNaRSxVQUFVO1lBQ1ZELGNBQWM7UUFDaEI7SUFDRjtJQUNBLElBQUllLFlBQVliLE9BQU9nQixjQUFjLEdBQUdoQixPQUFPZ0IsY0FBYyxDQUFDSixVQUFVQyxjQUFjRCxTQUFTSyxTQUFTLEdBQUdKO0FBQzdHO0FBRUEsSUFBSUssMEJBQTBCLFNBQVVqQyxHQUFHLEVBQUVrQyxJQUFJO0lBQy9DLElBQUl6QixTQUFTLENBQUM7SUFFZCxJQUFLLElBQUloQixLQUFLTyxJQUFLO1FBQ2pCLElBQUlrQyxLQUFLQyxPQUFPLENBQUMxQyxNQUFNLEdBQUc7UUFDMUIsSUFBSSxDQUFDc0IsT0FBT2IsU0FBUyxDQUFDc0IsY0FBYyxDQUFDQyxJQUFJLENBQUN6QixLQUFLUCxJQUFJO1FBQ25EZ0IsTUFBTSxDQUFDaEIsRUFBRSxHQUFHTyxHQUFHLENBQUNQLEVBQUU7SUFDcEI7SUFFQSxPQUFPZ0I7QUFDVDtBQUVBLElBQUkyQiw0QkFBNEIsU0FBVUMsSUFBSSxFQUFFWixJQUFJO0lBQ2xELElBQUksQ0FBQ1ksTUFBTTtRQUNULE1BQU0sSUFBSUMsZUFBZTtJQUMzQjtJQUVBLE9BQU9iLFFBQVMsUUFBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsVUFBUyxJQUFLQSxPQUFPWTtBQUNuRjtBQUVBLEdBQUc7QUFDSCxJQUFJRSxnQkFBaUIsU0FBVUMsQ0FBQztJQUM5QixPQUFPLENBQUMsT0FBT0EsTUFBTSxjQUFjLGNBQWMzQyxRQUFRMkMsRUFBQyxNQUFPLFlBQVlBLEVBQUV2QyxXQUFXLEtBQUtjO0FBQ2pHO0FBRUEsR0FBRztBQUNILElBQUkwQixjQUFjMUIsT0FBTzJCLE1BQU0sQ0FBQyxFQUFFO0FBQ2xDLElBQUlDLGVBQWU1QixPQUFPMkIsTUFBTSxDQUFDLENBQUM7QUFFbEMsR0FBRztBQUNILFNBQVNFLFdBQVdDLElBQUk7SUFDdEIsT0FBTyxPQUFPQSxTQUFTO0FBQ3pCO0FBRUEsR0FBRztBQUVILFNBQVNDLGlCQUFpQnJDLE1BQU07SUFDOUIsT0FBTyxDQUFDc0MsS0FBeUIsR0FBZSxPQUFPdEMsV0FBVyxZQUFZQSxTQUFTLENBQUksS0FBTUEsT0FBT3VDLFdBQVcsSUFBSXZDLE9BQU93QyxJQUFJLElBQUk7QUFDeEk7QUFFQSxHQUFHO0FBQ0gsU0FBU0Msb0JBQW9CTCxJQUFJO0lBQy9CLE9BQU8sT0FBT0EsU0FBUyxjQUFjLENBQUVBLENBQUFBLEtBQUszQyxTQUFTLElBQUkyQyxLQUFLM0MsU0FBUyxDQUFDaUQsZ0JBQWdCO0FBQzFGO0FBRUEsR0FBRztBQUNILFNBQVNDLGtCQUFrQjNDLE1BQU07SUFDL0IsT0FBT0EsVUFBVSxPQUFPQSxPQUFPNEMsaUJBQWlCLEtBQUs7QUFDdkQ7QUFFQSxHQUFHO0FBRUgsSUFBSUMsVUFBVSxPQUFPUCxZQUFZLGVBQWdCQSxDQUFBQSxRQUFRUSxHQUFHLENBQUNDLGlCQUFpQixJQUFJVCxRQUFRUSxHQUFHLENBQUNELE9BQU8sS0FBSztBQUUxRyxJQUFJRyxrQkFBa0I7QUFFdEIsSUFBSUMsaUJBQWlCO0FBRXJCLElBQUlDLGFBQWEsTUFBa0IsSUFBZSxDQUF1QkM7QUFFekUsSUFBSUMsaUJBQWlCLE9BQU9DLHNCQUFzQixhQUFhQSxxQkFBcUIsT0FBT2YsWUFBWSxlQUFnQkEsQ0FBQUEsUUFBUVEsR0FBRyxDQUFDUSwyQkFBMkIsSUFBSWhCLFFBQVFRLEdBQUcsQ0FBQ08saUJBQWlCLEtBQUtmLGtCQUF5QjtBQUU3TiwrREFBK0Q7QUFDL0QsSUFBSWlCLDJCQUEyQixDQUFDO0FBRWhDLEdBQUc7QUFHSDs7Q0FFQyxHQUNELElBQUlDLFNBQVNsQixLQUF5QixHQUFlO0lBQ25ELEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07QUFDUixJQUFJLENBQUU7QUFFTjs7Q0FFQyxHQUNELFNBQVNtQjtJQUNQLElBQUlDLElBQUk3QyxVQUFVM0IsTUFBTSxJQUFJLElBQUl5RSxZQUFZOUMsU0FBUyxDQUFDLEVBQUU7SUFDeEQsSUFBSStDLElBQUksRUFBRTtJQUVWLElBQUssSUFBSUMsSUFBSSxHQUFHNUUsTUFBTTRCLFVBQVUzQixNQUFNLEVBQUUyRSxJQUFJNUUsS0FBSzRFLEtBQUssRUFBRztRQUN2REQsRUFBRXpFLElBQUksQ0FBQzBCLFVBQVUzQixNQUFNLElBQUkyRSxJQUFJRixZQUFZOUMsU0FBUyxDQUFDZ0QsRUFBRTtJQUN6RDtJQUVBRCxFQUFFRSxPQUFPLENBQUMsU0FBVUMsQ0FBQztRQUNuQkwsSUFBSUEsRUFBRU0sT0FBTyxDQUFDLFVBQVVEO0lBQzFCO0lBRUEsT0FBT0w7QUFDVDtBQUVBOzs7Q0FHQyxHQUVELElBQUlPLHdCQUF3QixTQUFVQyxNQUFNO0lBQzFDakQsU0FBU2dELHVCQUF1QkM7SUFFaEMsU0FBU0Qsc0JBQXNCRSxJQUFJO1FBQ2pDekUsZUFBZSxJQUFJLEVBQUV1RTtRQUVyQixJQUFLLElBQUlHLE9BQU92RCxVQUFVM0IsTUFBTSxFQUFFSixpQkFBaUJ1RixNQUFNRCxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJRSxPQUFPLEdBQUdBLE9BQU9GLE1BQU1FLE9BQVE7WUFDaEh4RixjQUFjLENBQUN3RixPQUFPLEVBQUUsR0FBR3pELFNBQVMsQ0FBQ3lELEtBQUs7UUFDNUM7UUFFQSxJQUFJaEMsS0FBeUIsRUFBYyxjQUUxQyxNQUFNO1lBQ0wsSUFBSWlDLFFBQVE1QywwQkFBMEIsSUFBSSxFQUFFdUMsT0FBT2xELElBQUksQ0FBQyxJQUFJLEVBQUV5QyxPQUFPZ0IsS0FBSyxDQUFDZCxXQUFXO2dCQUFDSCxNQUFNLENBQUNXLEtBQUs7YUFBQyxDQUFDTyxNQUFNLENBQUM1RixpQkFBaUI2RixJQUFJO1FBQ25JO1FBQ0EsT0FBT2hELDBCQUEwQjRDO0lBQ25DO0lBRUEsT0FBT047QUFDVCxFQUFFVztBQUVGLEdBQUc7QUFDSCxJQUFJQyxrQkFBa0I7QUFFdEIsSUFBSUMsZUFBZ0IsU0FBVUMsUUFBUTtJQUNwQyxJQUFJQyxNQUFNLEtBQU1ELENBQUFBLFlBQVksRUFBQyxHQUFJLG1DQUFtQztJQUNwRSxJQUFJRSxxQkFBcUIsRUFBRTtJQUMzQkQsSUFBSWhCLE9BQU8sQ0FBQ2EsaUJBQWlCLFNBQVVLLEtBQUssRUFBRUMsV0FBVyxFQUFFQyxVQUFVO1FBQ25FSCxtQkFBbUI5RixJQUFJLENBQUM7WUFBRWdHLGFBQWFBO1lBQWFDLFlBQVlBO1FBQVc7UUFDM0UsT0FBT0Y7SUFDVDtJQUNBLE9BQU9ELG1CQUFtQkksR0FBRyxDQUFDLFNBQVVDLElBQUksRUFBRXRHLENBQUM7UUFDN0MsSUFBSW1HLGNBQWNHLEtBQUtILFdBQVcsRUFDOUJDLGFBQWFFLEtBQUtGLFVBQVU7UUFFaEMsSUFBSUcsV0FBV04sa0JBQWtCLENBQUNqRyxJQUFJLEVBQUU7UUFDeEMsSUFBSXdHLGFBQWFELFdBQVdQLElBQUlTLEtBQUssQ0FBQ0wsWUFBWUcsU0FBU0gsVUFBVSxJQUFJSixJQUFJUyxLQUFLLENBQUNMO1FBQ25GLE9BQU87WUFBRUQsYUFBYUE7WUFBYUssWUFBWUE7UUFBVztJQUM1RDtBQUNGO0FBRUEsR0FBRztBQUVILElBQUlFLGdCQUFnQjtBQUVwQiwrRUFBK0U7QUFDL0UsSUFBSUMsaUJBQWlCLElBQUkvSCwwREFBTUEsQ0FBQztJQUM5QmdJLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsVUFBVTtJQUNWQyxXQUFXO0FBQ2I7QUFFQSxJQUFJQyxTQUFTLElBQUl0SSwwREFBTUEsQ0FBQztJQUN0QmdJLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsVUFBVTtJQUNWQyxXQUFXLE1BQU0scURBQXFEO0FBQ3hFO0FBRUEsbURBQW1EO0FBQ25ELHlEQUF5RDtBQUN6RCw2REFBNkQ7QUFFN0QsSUFBSUUsZUFBZSxFQUFFO0FBRXJCLDZDQUE2QztBQUM3QyxJQUFJQyxvQkFBb0IsU0FBU0Esa0JBQWtCQyxPQUFPO0lBQ3hELElBQUlBLFlBQVksQ0FBQyxHQUFHO1FBQ2xCLElBQUlDLGNBQWNIO1FBQ2xCQSxlQUFlLEVBQUU7UUFDakIsT0FBT0c7SUFDVDtBQUNGO0FBRUEsSUFBSUMsbUJBQW1CMUksd0RBQWlCQSxDQUFDLFNBQVUySSxJQUFJO0lBQ3JETCxhQUFhaEgsSUFBSSxDQUFDcUg7QUFDcEI7QUFFQSxJQUFJQyxlQUFlLEtBQUs7QUFDeEIsSUFBSUMsWUFBWSxLQUFLO0FBQ3JCLElBQUlDLGtCQUFrQixLQUFLO0FBRTNCLElBQUlDLHdCQUF3QixTQUFTQSxzQkFBc0IxQixLQUFLLEVBQUUyQixNQUFNLEVBQUVDLE1BQU07SUFDOUUsSUFDQSx5Q0FBeUM7SUFDekNELFNBQVMsS0FDVCx1RUFBdUU7SUFDdkVDLE9BQU9yQixLQUFLLENBQUMsR0FBR29CLFFBQVFuRixPQUFPLENBQUNnRixlQUFlLENBQUMsS0FDaEQsc0ZBQXNGO0lBQ3RGSSxPQUFPckIsS0FBSyxDQUFDb0IsU0FBU0gsVUFBVXhILE1BQU0sRUFBRTJILFlBQVlILFdBQVc7UUFDN0QsT0FBTyxNQUFNRDtJQUNmO0lBRUEsT0FBT3ZCO0FBQ1Q7QUFFQTs7Ozs7Ozs7O0NBU0MsR0FDRCxJQUFJNkIsaUNBQWlDLFNBQVNBLCtCQUErQlYsT0FBTyxFQUFFVyxDQUFDLEVBQUVDLFNBQVM7SUFDaEcsSUFBSVosWUFBWSxLQUFLWSxVQUFVL0gsTUFBTSxJQUFJK0gsU0FBUyxDQUFDLEVBQUUsQ0FBQ0MsV0FBVyxDQUFDUixhQUFhLEdBQUc7UUFDaEYsNkNBQTZDO1FBQzdDTyxTQUFTLENBQUMsRUFBRSxHQUFHQSxTQUFTLENBQUMsRUFBRSxDQUFDakQsT0FBTyxDQUFDMkMsaUJBQWlCQztJQUN2RDtBQUNGO0FBRUFWLE9BQU9pQixHQUFHLENBQUM7SUFBQ0o7SUFBZ0NSO0lBQWtCSDtDQUFrQjtBQUNoRlQsZUFBZXdCLEdBQUcsQ0FBQztJQUFDWjtJQUFrQkg7Q0FBa0I7QUFFeEQsSUFBSWdCLGVBQWUsU0FBU0EsYUFBYXBDLEdBQUc7SUFDMUMsT0FBT1csZUFBZSxJQUFJWDtBQUM1QjtBQUVBLFNBQVNxQyxlQUFlQyxLQUFLLEVBQUVDLFFBQVEsRUFBRXhCLE1BQU07SUFDN0MsSUFBSVosY0FBY3RFLFVBQVUzQixNQUFNLEdBQUcsS0FBSzJCLFNBQVMsQ0FBQyxFQUFFLEtBQUs4QyxZQUFZOUMsU0FBUyxDQUFDLEVBQUUsR0FBRztJQUV0RixJQUFJMkcsVUFBVUYsTUFBTTlDLElBQUksQ0FBQyxJQUFJUixPQUFPLENBQUMwQixlQUFlLEtBQUssc0JBQXNCO0lBRS9FLElBQUkrQixTQUFTRixZQUFZeEIsU0FBU0EsU0FBUyxNQUFNd0IsV0FBVyxRQUFRQyxVQUFVLE9BQU9BO0lBRXJGLHlEQUF5RDtJQUN6RCxpRUFBaUU7SUFDakUsNERBQTREO0lBQzVEZixlQUFldEI7SUFDZnVCLFlBQVlhO0lBQ1paLGtCQUFrQixJQUFJZSxPQUFPLE9BQU9oQixZQUFZLE9BQU87SUFFdkQsT0FBT1IsT0FBT0gsVUFBVSxDQUFDd0IsV0FBVyxLQUFLQSxVQUFVRTtBQUNyRDtBQUVBLEdBQUc7QUFDSCxzQ0FBc0MsR0FFdEMsSUFBSUUsV0FBWTtJQUNkLE9BQU8sS0FBNkIsR0FBY0Msc0JBQWlCQSxHQUFHLENBQUk7QUFDNUU7QUFFQSxHQUFHO0FBQ0g7Ozs7b0NBSW9DLEdBRXBDLG9EQUFvRCxHQUNwRCxJQUFJQyxlQUFlLFNBQVNBLGFBQWFDLEtBQUssRUFBRUMsRUFBRSxFQUFFdkYsSUFBSTtJQUN0RCxJQUFJQSxNQUFNO1FBQ1IsNkNBQTZDO1FBQzdDLElBQUl3RixhQUFhRixLQUFLLENBQUNDLEdBQUcsSUFBS0QsQ0FBQUEsS0FBSyxDQUFDQyxHQUFHLEdBQUd6SCxPQUFPYyxNQUFNLENBQUMsS0FBSTtRQUM3RDRHLFVBQVUsQ0FBQ3hGLEtBQUssR0FBRztJQUNyQjtBQUNGO0FBRUEsNkRBQTZELEdBQzdELElBQUl5RixlQUFlLFNBQVNBLGFBQWFILEtBQUssRUFBRUMsRUFBRTtJQUNoRCw2Q0FBNkM7SUFDN0NELEtBQUssQ0FBQ0MsR0FBRyxHQUFHekgsT0FBT2MsTUFBTSxDQUFDO0FBQzVCO0FBRUEsK0VBQStFLEdBQy9FLElBQUk4RyxlQUFlLFNBQVNBLGFBQWFKLEtBQUs7SUFDNUMsT0FBTyxTQUFVQyxFQUFFLEVBQUV2RixJQUFJO1FBQ3ZCLE9BQU9zRixLQUFLLENBQUNDLEdBQUcsS0FBS3BFLGFBQWFtRSxLQUFLLENBQUNDLEdBQUcsQ0FBQ3ZGLEtBQUs7SUFDbkQ7QUFDRjtBQUVBLGlEQUFpRCxHQUNqRCxJQUFJMkYsaUJBQWlCLFNBQVNBLGVBQWVMLEtBQUs7SUFDaEQsSUFBSU0sTUFBTTtJQUNWLHdDQUF3QztJQUN4QyxJQUFLLElBQUlMLE1BQU1ELE1BQU87UUFDcEJNLE9BQU85SCxPQUFPbUIsSUFBSSxDQUFDcUcsS0FBSyxDQUFDQyxHQUFHLEVBQUV2RCxJQUFJLENBQUMsT0FBTztJQUM1QztJQUNBLE9BQU80RCxJQUFJekQsSUFBSTtBQUNqQjtBQUVBLHNDQUFzQyxHQUN0QyxJQUFJMEQsYUFBYSxTQUFTQSxXQUFXUCxLQUFLO0lBQ3hDLElBQUlRLFFBQVFoSSxPQUFPYyxNQUFNLENBQUM7SUFDMUIsd0NBQXdDO0lBQ3hDLElBQUssSUFBSTJHLE1BQU1ELE1BQU87UUFDcEJRLEtBQUssQ0FBQ1AsR0FBRyxHQUFHcEgsU0FBUyxDQUFDLEdBQUdtSCxLQUFLLENBQUNDLEdBQUc7SUFDcEM7SUFDQSxPQUFPTztBQUNUO0FBRUEsR0FBRztBQUVIOztDQUVDLEdBRUQsMENBQTBDLEdBQzFDLElBQUlDLGNBQWMsU0FBU0EsWUFBWUMsR0FBRztJQUN4QyxhQUFhO0lBQ2IsSUFBSUEsSUFBSUMsS0FBSyxFQUFFLE9BQU9ELElBQUlDLEtBQUs7SUFFL0IsZ0dBQWdHLEdBQ2hHLElBQUlDLE9BQU9GLElBQUlHLGFBQWEsQ0FBQ0MsV0FBVyxDQUFDMUosTUFBTTtJQUMvQyxJQUFLLElBQUlGLElBQUksR0FBR0EsSUFBSTBKLE1BQU0xSixLQUFLLEVBQUc7UUFDaEMsSUFBSXlKLFFBQVFELElBQUlHLGFBQWEsQ0FBQ0MsV0FBVyxDQUFDNUosRUFBRTtRQUM1QyxhQUFhO1FBQ2IsSUFBSXlKLE1BQU1JLFNBQVMsS0FBS0wsS0FBSyxPQUFPQztJQUN0QztJQUVBLDBDQUEwQyxHQUMxQyxNQUFNLElBQUl4RSxzQkFBc0I7QUFDbEM7QUFFQSxvRUFBb0UsR0FDcEUsSUFBSTZFLGlCQUFpQixTQUFTQSxlQUFlTCxLQUFLLEVBQUVNLE9BQU8sRUFBRUMsS0FBSztJQUNoRSwwQ0FBMEMsR0FDMUMsSUFBSSxDQUFDRCxTQUFTLE9BQU87SUFFckIsSUFBSUUsV0FBV1IsTUFBTVMsUUFBUSxDQUFDaEssTUFBTTtJQUVwQyxJQUFJO1FBQ0Ysc0VBQXNFLEdBQ3RFdUosTUFBTVUsVUFBVSxDQUFDSixTQUFTQyxTQUFTQyxXQUFXRCxRQUFRQztJQUN4RCxFQUFFLE9BQU9HLEtBQUs7UUFDWix1Q0FBdUMsR0FDdkMsT0FBTztJQUNUO0lBRUEsT0FBTztBQUNUO0FBRUEscURBQXFELEdBQ3JELElBQUlDLGNBQWMsU0FBU0EsWUFBWVosS0FBSyxFQUFFYSxZQUFZLEVBQUVaLElBQUk7SUFDOUQsSUFBSWEsYUFBYUQsZUFBZVo7SUFDaEMsSUFBSyxJQUFJMUosSUFBSXNLLGNBQWN0SyxJQUFJdUssWUFBWXZLLEtBQUssRUFBRztRQUNqRHlKLE1BQU1lLFVBQVUsQ0FBQ3hLO0lBQ25CO0FBQ0Y7QUFFQSxHQUFHO0FBRUgsMkVBQTJFLEdBQzNFLElBQUl5SyxpQkFBaUIsU0FBU0EsZUFBZTFCLEVBQUU7SUFDN0MsT0FBTywyQkFBMkJBLEtBQUs7QUFDekM7QUFFQSxnRUFBZ0UsR0FDaEUsSUFBSTJCLGtCQUFrQixTQUFTQSxnQkFBZ0JDLEtBQUssRUFBRVgsS0FBSztJQUN6RCxJQUFJWSxpQkFBaUI7SUFDckIsSUFBSyxJQUFJNUssSUFBSSxHQUFHQSxLQUFLZ0ssT0FBT2hLLEtBQUssRUFBRztRQUNsQzRLLGtCQUFrQkQsS0FBSyxDQUFDM0ssRUFBRTtJQUM1QjtJQUVBLE9BQU80SztBQUNUO0FBRUEsdUNBQXVDLEdBQ3ZDLElBQUlDLGVBQWUsU0FBU0EsYUFBYTdKLE1BQU0sRUFBRThKLEtBQUssRUFBRUMsWUFBWTtJQUNsRSxJQUFJQyxpQkFBaUJDO0lBQ3JCLElBQUlqSyxRQUFRZ0ssaUJBQWlCaEssT0FBTzJJLGFBQWE7U0FBTSxJQUFJbUIsT0FBT0UsaUJBQWlCRixNQUFNbkIsYUFBYTtJQUV0RyxJQUFJdUIsS0FBS0YsZUFBZTlMLGFBQWEsQ0FBQztJQUN0Q2dNLEdBQUdDLFlBQVksQ0FBQ3RILFNBQVM7SUFDekJxSCxHQUFHQyxZQUFZLENBQUNuSCxpQkFBaUI7SUFFakMsSUFBSW9ILFFBQVF6QztJQUNaLElBQUl5QyxPQUFPO1FBQ1RGLEdBQUdDLFlBQVksQ0FBQyxTQUFTQztJQUMzQjtJQUVBLDRDQUE0QyxHQUM1Q0YsR0FBR0csV0FBVyxDQUFDTCxlQUFlTSxjQUFjLENBQUM7SUFFN0MsSUFBSXRLLFVBQVUsQ0FBQzhKLE9BQU87UUFDcEIsd0RBQXdELEdBQ3hEOUosT0FBT3FLLFdBQVcsQ0FBQ0g7SUFDckIsT0FBTztRQUNMLElBQUksQ0FBQ0osU0FBUyxDQUFDOUosVUFBVSxDQUFDOEosTUFBTVMsVUFBVSxFQUFFO1lBQzFDLE1BQU0sSUFBSXRHLHNCQUFzQjtRQUNsQztRQUVBLCtDQUErQyxHQUMvQzZGLE1BQU1TLFVBQVUsQ0FBQ1IsWUFBWSxDQUFDRyxJQUFJSCxlQUFlRCxRQUFRQSxNQUFNVSxXQUFXO0lBQzVFO0lBRUEsT0FBT047QUFDVDtBQUVBLHVFQUF1RSxHQUN2RSxJQUFJTyxnQkFBZ0IsU0FBU0EsY0FBY3pGLEdBQUcsRUFBRThDLEtBQUs7SUFDbkQsT0FBTyxTQUFVNEMsZUFBZTtRQUM5QixJQUFJTixRQUFRekM7UUFDWixJQUFJZ0QsUUFBUTtZQUFDUCxTQUFTLFlBQVlBLFFBQVE7WUFBS3ZILFVBQVUsT0FBT3NGLGVBQWVMLFNBQVM7WUFBSzlFLGtCQUFrQixPQUFPLFVBQVU7WUFBSzBIO1NBQWdCO1FBRXJKLElBQUlFLFdBQVdELE1BQU1FLE1BQU0sQ0FBQ0MsU0FBU3RHLElBQUksQ0FBQztRQUMxQyxPQUFPLFlBQVlvRyxXQUFXLE1BQU01RixRQUFRO0lBQzlDO0FBQ0Y7QUFFQSwrREFBK0QsR0FDL0QsSUFBSStGLGdCQUFnQixTQUFTQSxjQUFjL0YsR0FBRyxFQUFFOEMsS0FBSztJQUNuRCxPQUFPO1FBQ0wsSUFBSWtEO1FBRUosSUFBSS9LLFFBQVMrSyxDQUFBQSxTQUFTLENBQUMsR0FBR0EsTUFBTSxDQUFDbkksUUFBUSxHQUFHc0YsZUFBZUwsUUFBUWtELE1BQU0sQ0FBQ2hJLGdCQUFnQixHQUFHLFNBQVNnSSxNQUFLO1FBRTNHLElBQUlaLFFBQVF6QztRQUNaLElBQUl5QyxPQUFPO1lBQ1QsYUFBYTtZQUNibkssTUFBTW1LLEtBQUssR0FBR0E7UUFDaEI7UUFFQSwyQ0FBMkM7UUFDM0MscUJBQU90TSwwREFBbUIsQ0FBQyxTQUFTNkMsU0FBUyxDQUFDLEdBQUdWLE9BQU87WUFBRWdMLHlCQUF5QjtnQkFBRUMsUUFBUWxHO1lBQU07UUFBRTtJQUN2RztBQUNGO0FBRUEsSUFBSW1HLDJCQUEyQixTQUFTQSx5QkFBeUJDLE9BQU87SUFDdEUsT0FBTztRQUNMLE9BQU85SyxPQUFPbUIsSUFBSSxDQUFDMko7SUFDckI7QUFDRjtBQUVBLGtDQUFrQyxHQUNsQyxJQUFJQyxnQkFBZ0IsU0FBU0EsY0FBY25CLEVBQUUsRUFBRW9CLGdCQUFnQjtJQUM3RCxJQUFJeEQsUUFBUXhILE9BQU9jLE1BQU0sQ0FBQztJQUMxQixJQUFJZ0ssVUFBVTlLLE9BQU9jLE1BQU0sQ0FBQztJQUM1QixJQUFJdUksUUFBUSxFQUFFO0lBRWQsSUFBSTRCLGdCQUFnQkQscUJBQXFCM0g7SUFDekMsaURBQWlELEdBQ2pELElBQUk2SCxvQkFBb0I7SUFFeEIsSUFBSUMsZUFBZSxTQUFTQSxhQUFhMUQsRUFBRTtRQUN6QyxJQUFJMkQsT0FBT04sT0FBTyxDQUFDckQsR0FBRztRQUN0QixJQUFJMkQsU0FBUy9ILFdBQVc7WUFDdEIsT0FBTytIO1FBQ1Q7UUFFQU4sT0FBTyxDQUFDckQsR0FBRyxHQUFHNEIsTUFBTXpLLE1BQU07UUFDMUJ5SyxNQUFNeEssSUFBSSxDQUFDO1FBQ1g4SSxhQUFhSCxPQUFPQztRQUVwQixPQUFPcUQsT0FBTyxDQUFDckQsR0FBRztJQUNwQjtJQUVBLElBQUk0RCxjQUFjLFNBQVNBLFlBQVk1RCxFQUFFLEVBQUVtQixRQUFRLEVBQUUxRyxJQUFJO1FBQ3ZELElBQUlvSixTQUFTSCxhQUFhMUQ7UUFDMUIsSUFBSVUsUUFBUUYsWUFBWTJCO1FBQ3hCLElBQUkyQixjQUFjbkMsZ0JBQWdCQyxPQUFPaUM7UUFFekMsSUFBSUUsZ0JBQWdCO1FBQ3BCLElBQUlDLGNBQWMsRUFBRTtRQUNwQixJQUFJQyxlQUFlOUMsU0FBU2hLLE1BQU07UUFFbEMsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUlnTixjQUFjaE4sS0FBSyxFQUFHO1lBQ3hDLElBQUkrSixVQUFVRyxRQUFRLENBQUNsSyxFQUFFO1lBQ3pCLElBQUlpTixnQkFBZ0JWLGVBQWUsK0NBQStDO1lBQ2xGLElBQUlVLGlCQUFpQmxELFFBQVFySCxPQUFPLENBQUMsZUFBZSxDQUFDLEdBQUc7Z0JBQ3REcUssWUFBWTVNLElBQUksQ0FBQzRKO1lBQ25CLE9BQU8sSUFBSUQsZUFBZUwsT0FBT00sU0FBUzhDLGNBQWNDLGdCQUFnQjtnQkFDdEVHLGdCQUFnQjtnQkFDaEJILGlCQUFpQjtZQUNuQjtRQUNGO1FBRUEsSUFBSVAsaUJBQWlCUSxZQUFZN00sTUFBTSxHQUFHLEdBQUc7WUFDM0NzTSxvQkFBb0I7WUFDcEIsYUFBYTtZQUNiRixtQkFBbUJLLFdBQVcsQ0FBQzVELEtBQUssV0FBV2dFO1FBQ2pEO1FBRUFwQyxLQUFLLENBQUNpQyxPQUFPLElBQUlFLGVBQWUsK0JBQStCO1FBQy9EakUsYUFBYUMsT0FBT0MsSUFBSXZGO0lBQzFCO0lBRUEsSUFBSTBKLGNBQWMsU0FBU0EsWUFBWW5FLEVBQUU7UUFDdkMsSUFBSTZELFNBQVNSLE9BQU8sQ0FBQ3JELEdBQUc7UUFDeEIsSUFBSTZELFdBQVdqSSxXQUFXO1FBQzFCLGFBQWE7UUFDYixJQUFJdUcsR0FBR2lDLFdBQVcsS0FBSyxPQUFPO1FBRTlCLElBQUl6RCxPQUFPaUIsS0FBSyxDQUFDaUMsT0FBTztRQUN4QixJQUFJbkQsUUFBUUYsWUFBWTJCO1FBQ3hCLElBQUlaLGVBQWVJLGdCQUFnQkMsT0FBT2lDLFVBQVU7UUFDcER2QyxZQUFZWixPQUFPYSxjQUFjWjtRQUNqQ2lCLEtBQUssQ0FBQ2lDLE9BQU8sR0FBRztRQUNoQjNELGFBQWFILE9BQU9DO1FBRXBCLElBQUl3RCxpQkFBaUJDLG1CQUFtQjtZQUN0QyxhQUFhO1lBQ2JGLG1CQUFtQlksV0FBVyxDQUFDbkUsS0FBSztRQUN0QztJQUNGO0lBRUEsSUFBSS9DLE1BQU0sU0FBU0E7UUFDakIsSUFBSW9ILGVBQWU3RCxZQUFZMkIsS0FDM0JoQixXQUFXa0QsYUFBYWxELFFBQVE7UUFFcEMsSUFBSWQsTUFBTTtRQUVWLHdDQUF3QztRQUN4QyxJQUFLLElBQUlMLE1BQU1xRCxRQUFTO1lBQ3RCaEQsT0FBT3FCLGVBQWUxQjtZQUN0QixJQUFJNkQsU0FBU1IsT0FBTyxDQUFDckQsR0FBRztZQUN4QixJQUFJc0UsTUFBTTNDLGdCQUFnQkMsT0FBT2lDO1lBQ2pDLElBQUlsRCxPQUFPaUIsS0FBSyxDQUFDaUMsT0FBTztZQUN4QixJQUFLLElBQUk1TSxJQUFJcU4sTUFBTTNELE1BQU0xSixJQUFJcU4sS0FBS3JOLEtBQUssRUFBRztnQkFDeEMsSUFBSXdILE9BQU8wQyxRQUFRLENBQUNsSyxFQUFFO2dCQUN0QixJQUFJd0gsU0FBUzdDLFdBQVc7b0JBQ3RCeUUsT0FBTzVCLEtBQUs4RixPQUFPO2dCQUNyQjtZQUNGO1FBQ0Y7UUFFQSxPQUFPbEU7SUFDVDtJQUVBLE9BQU87UUFDTEUsT0FBTyxTQUFTQTtZQUNkLE1BQU0sSUFBSXJFLHNCQUFzQjtRQUNsQztRQUVBZSxLQUFLQTtRQUNMdUgsUUFBUXBCLHlCQUF5QkM7UUFDakNsRCxjQUFjQSxhQUFhSjtRQUMzQjJELGNBQWNBO1FBQ2RFLGFBQWFBO1FBQ2JPLGFBQWFBO1FBQ2JNLFFBQVE7UUFDUkMsVUFBVXZDO1FBQ1Z3QyxXQUFXM0IsY0FBYy9GLEtBQUs4QztRQUM5QjZFLFFBQVFsQyxjQUFjekYsS0FBSzhDO0lBQzdCO0FBQ0Y7QUFFQSxJQUFJOEUsZUFBZSxTQUFTQSxhQUFhNUMsY0FBYyxFQUFFakMsRUFBRTtJQUN6RCxPQUFPaUMsZUFBZU0sY0FBYyxDQUFDYixlQUFlMUI7QUFDdEQ7QUFFQSxJQUFJOEUsaUJBQWlCLFNBQVNBLGVBQWUzQyxFQUFFLEVBQUVvQixnQkFBZ0I7SUFDL0QsSUFBSXhELFFBQVF4SCxPQUFPYyxNQUFNLENBQUM7SUFDMUIsSUFBSWdLLFVBQVU5SyxPQUFPYyxNQUFNLENBQUM7SUFFNUIsSUFBSW1LLGdCQUFnQkQscUJBQXFCM0g7SUFFekMsaURBQWlELEdBQ2pELElBQUk2SCxvQkFBb0I7SUFFeEIsSUFBSUMsZUFBZSxTQUFTQSxhQUFhMUQsRUFBRTtRQUN6QyxJQUFJMkQsT0FBT04sT0FBTyxDQUFDckQsR0FBRztRQUN0QixJQUFJMkQsU0FBUy9ILFdBQVc7WUFDdEIsT0FBTytIO1FBQ1Q7UUFFQU4sT0FBTyxDQUFDckQsR0FBRyxHQUFHNkUsYUFBYTFDLEdBQUd2QixhQUFhLEVBQUVaO1FBQzdDbUMsR0FBR0csV0FBVyxDQUFDZSxPQUFPLENBQUNyRCxHQUFHO1FBQzFCRCxLQUFLLENBQUNDLEdBQUcsR0FBR3pILE9BQU9jLE1BQU0sQ0FBQztRQUUxQixPQUFPZ0ssT0FBTyxDQUFDckQsR0FBRztJQUNwQjtJQUVBLElBQUk0RCxjQUFjLFNBQVNBLFlBQVk1RCxFQUFFLEVBQUVtQixRQUFRLEVBQUUxRyxJQUFJO1FBQ3ZELElBQUlvSixTQUFTSCxhQUFhMUQ7UUFDMUIsSUFBSWdFLGNBQWMsRUFBRTtRQUNwQixJQUFJQyxlQUFlOUMsU0FBU2hLLE1BQU07UUFFbEMsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUlnTixjQUFjaE4sS0FBSyxFQUFHO1lBQ3hDLElBQUl3SCxPQUFPMEMsUUFBUSxDQUFDbEssRUFBRTtZQUN0QixJQUFJaU4sZ0JBQWdCVjtZQUNwQixJQUFJVSxpQkFBaUJ6RixLQUFLOUUsT0FBTyxDQUFDLGVBQWUsQ0FBQyxHQUFHO2dCQUNuRHFLLFlBQVk1TSxJQUFJLENBQUNxSDtZQUNuQixPQUFPO2dCQUNMeUYsZ0JBQWdCO2dCQUNoQixJQUFJYSxZQUFZOU4sTUFBTWdOLGVBQWUsSUFBSSxLQUFLO2dCQUM5Q0osT0FBT21CLFVBQVUsQ0FBQyxLQUFLdkcsT0FBT3NHO1lBQ2hDO1FBQ0Y7UUFFQWpGLGFBQWFDLE9BQU9DLElBQUl2RjtRQUV4QixJQUFJK0ksaUJBQWlCUSxZQUFZN00sTUFBTSxHQUFHLEdBQUc7WUFDM0NzTSxvQkFBb0I7WUFDcEIsYUFBYTtZQUNiRixtQkFBbUJLLFdBQVcsQ0FBQzVELEtBQUssV0FBV2dFO1FBQ2pEO0lBQ0Y7SUFFQSxJQUFJRyxjQUFjLFNBQVNBLFlBQVluRSxFQUFFO1FBQ3ZDLElBQUk2RCxTQUFTUixPQUFPLENBQUNyRCxHQUFHO1FBQ3hCLElBQUk2RCxXQUFXakksV0FBVztRQUUxQiwwREFBMEQsR0FDMUQsSUFBSXFKLFlBQVlKLGFBQWExQyxHQUFHdkIsYUFBYSxFQUFFWjtRQUMvQ21DLEdBQUcrQyxZQUFZLENBQUNELFdBQVdwQjtRQUMzQlIsT0FBTyxDQUFDckQsR0FBRyxHQUFHaUY7UUFDZC9FLGFBQWFILE9BQU9DO1FBRXBCLElBQUl3RCxpQkFBaUJDLG1CQUFtQjtZQUN0QyxhQUFhO1lBQ2JGLG1CQUFtQlksV0FBVyxDQUFDbkUsS0FBSztRQUN0QztJQUNGO0lBRUEsSUFBSS9DLE1BQU0sU0FBU0E7UUFDakIsSUFBSW9ELE1BQU07UUFFVix3Q0FBd0M7UUFDeEMsSUFBSyxJQUFJTCxNQUFNcUQsUUFBUztZQUN0QmhELE9BQU9nRCxPQUFPLENBQUNyRCxHQUFHLENBQUNtRixJQUFJO1FBQ3pCO1FBRUEsT0FBTzlFO0lBQ1Q7SUFFQSxPQUFPO1FBQ0xFLE9BQU8sU0FBU0E7WUFDZCxNQUFNLElBQUlyRSxzQkFBc0I7UUFDbEM7UUFFQWUsS0FBS0E7UUFDTHVILFFBQVFwQix5QkFBeUJDO1FBQ2pDbEQsY0FBY0EsYUFBYUo7UUFDM0IyRCxjQUFjQTtRQUNkRSxhQUFhQTtRQUNiTyxhQUFhQTtRQUNiTSxRQUFRO1FBQ1JDLFVBQVV2QztRQUNWd0MsV0FBVzNCLGNBQWMvRixLQUFLOEM7UUFDOUI2RSxRQUFRbEMsY0FBY3pGLEtBQUs4QztJQUM3QjtBQUNGO0FBRUEsSUFBSXFGLGdCQUFnQixTQUFTQSxjQUFjQyxRQUFRLEVBQUVDLFVBQVU7SUFDN0QsSUFBSXZGLFFBQVFzRixhQUFhekosWUFBWXJELE9BQU9jLE1BQU0sQ0FBQyxRQUFRZ007SUFDM0QsSUFBSWhDLFVBQVVpQyxlQUFlMUosWUFBWXJELE9BQU9jLE1BQU0sQ0FBQyxRQUFRaU07SUFFL0QsSUFBSTVCLGVBQWUsU0FBU0EsYUFBYTFELEVBQUU7UUFDekMsSUFBSTJELE9BQU9OLE9BQU8sQ0FBQ3JELEdBQUc7UUFDdEIsSUFBSTJELFNBQVMvSCxXQUFXO1lBQ3RCLE9BQU8rSDtRQUNUO1FBRUEsT0FBT04sT0FBTyxDQUFDckQsR0FBRyxHQUFHO1lBQUM7U0FBRztJQUMzQjtJQUVBLElBQUk0RCxjQUFjLFNBQVNBLFlBQVk1RCxFQUFFLEVBQUVtQixRQUFRLEVBQUUxRyxJQUFJO1FBQ3ZELElBQUlvSixTQUFTSCxhQUFhMUQ7UUFDMUI2RCxNQUFNLENBQUMsRUFBRSxJQUFJMUMsU0FBUzFFLElBQUksQ0FBQztRQUMzQnFELGFBQWFDLE9BQU9DLElBQUl2RjtJQUMxQjtJQUVBLElBQUkwSixjQUFjLFNBQVNBLFlBQVluRSxFQUFFO1FBQ3ZDLElBQUk2RCxTQUFTUixPQUFPLENBQUNyRCxHQUFHO1FBQ3hCLElBQUk2RCxXQUFXakksV0FBVztRQUMxQmlJLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDWjNELGFBQWFILE9BQU9DO0lBQ3RCO0lBRUEsSUFBSS9DLE1BQU0sU0FBU0E7UUFDakIsSUFBSW9ELE1BQU07UUFDVix3Q0FBd0M7UUFDeEMsSUFBSyxJQUFJTCxNQUFNcUQsUUFBUztZQUN0QixJQUFJa0MsV0FBV2xDLE9BQU8sQ0FBQ3JELEdBQUcsQ0FBQyxFQUFFO1lBQzdCLElBQUl1RixVQUFVO2dCQUNabEYsT0FBT3FCLGVBQWUxQixNQUFNdUY7WUFDOUI7UUFDRjtRQUNBLE9BQU9sRjtJQUNUO0lBRUEsSUFBSUUsUUFBUSxTQUFTQTtRQUNuQixJQUFJaUYsYUFBYWxGLFdBQVdQO1FBQzVCLElBQUkwRixlQUFlbE4sT0FBT2MsTUFBTSxDQUFDO1FBRWpDLHdDQUF3QztRQUN4QyxJQUFLLElBQUkyRyxNQUFNcUQsUUFBUztZQUN0Qm9DLFlBQVksQ0FBQ3pGLEdBQUcsR0FBRztnQkFBQ3FELE9BQU8sQ0FBQ3JELEdBQUcsQ0FBQyxFQUFFO2FBQUM7UUFDckM7UUFFQSxPQUFPb0YsY0FBY0ksWUFBWUM7SUFDbkM7SUFFQSxJQUFJaEYsTUFBTTtRQUNSRixPQUFPQTtRQUNQdEQsS0FBS0E7UUFDTHVILFFBQVFwQix5QkFBeUJDO1FBQ2pDbEQsY0FBY0EsYUFBYUo7UUFDM0IyRCxjQUFjQTtRQUNkRSxhQUFhQTtRQUNiTyxhQUFhQTtRQUNiTSxRQUFRO1FBQ1JDLFVBQVU7UUFDVkMsV0FBVzNCLGNBQWMvRixLQUFLOEM7UUFDOUI2RSxRQUFRbEMsY0FBY3pGLEtBQUs4QztJQUM3QjtJQUVBLE9BQU9VO0FBQ1Q7QUFFQSxJQUFJaUYsVUFBVSxTQUFTQSxRQUFRek4sTUFBTSxFQUFFOEosS0FBSyxFQUFFNEQsV0FBVyxFQUFFM0QsWUFBWSxFQUFFdUIsZ0JBQWdCO0lBQ3ZGLElBQUlwSSxjQUFjLENBQUN3SyxhQUFhO1FBQzlCLElBQUl4RCxLQUFLTCxhQUFhN0osUUFBUThKLE9BQU9DO1FBRXJDLElBQUkzRyxnQkFBZ0I7WUFDbEIsT0FBT3lKLGVBQWUzQyxJQUFJb0I7UUFDNUIsT0FBTztZQUNMLE9BQU9ELGNBQWNuQixJQUFJb0I7UUFDM0I7SUFDRjtJQUVBLE9BQU82QjtBQUNUO0FBRUEsSUFBSVEsWUFBWSxTQUFTQSxVQUFVbkYsR0FBRyxFQUFFb0YsR0FBRyxFQUFFQyxTQUFTO0lBQ3BELCtDQUErQyxHQUMvQyxJQUFLLElBQUk3TyxJQUFJLEdBQUdDLE1BQU00TyxVQUFVM08sTUFBTSxFQUFFRixJQUFJQyxLQUFLRCxLQUFLLEVBQUc7UUFDdkQsSUFBSThPLGVBQWVELFNBQVMsQ0FBQzdPLEVBQUUsRUFDM0JtRyxjQUFjMkksYUFBYTNJLFdBQVcsRUFDdENLLGFBQWFzSSxhQUFhdEksVUFBVTtRQUV4QyxJQUFJMEQsV0FBVzlCLGFBQWE1QjtRQUM1QmdELElBQUltRCxXQUFXLENBQUN4RyxhQUFhK0Q7SUFDL0I7SUFFQSxpRUFBaUUsR0FDakUsSUFBSyxJQUFJNkUsS0FBSyxHQUFHM0osT0FBT3dKLElBQUkxTyxNQUFNLEVBQUU2TyxLQUFLM0osTUFBTTJKLE1BQU0sRUFBRztRQUN0RCxJQUFJN0QsS0FBSzBELEdBQUcsQ0FBQ0csR0FBRztRQUNoQixJQUFJN0QsR0FBR0ssVUFBVSxFQUFFO1lBQ2pCTCxHQUFHSyxVQUFVLENBQUN5RCxXQUFXLENBQUM5RDtRQUM1QjtJQUNGO0FBQ0Y7QUFFQSxHQUFHO0FBRUgsSUFBSStELGNBQWM7QUFFbEIsc0VBQXNFLEdBQ3RFLElBQUlDLFdBQVcsS0FBSztBQUNwQixJQUFJaEwsWUFBWTtJQUNkLDRGQUE0RixHQUM1RmdMLFdBQVc5SyxpQkFBaUIsS0FBSztBQUNuQyxPQUFPO0lBQ0wsOENBQThDLEdBQzlDOEssV0FBVyxDQUFDO0FBQ2Q7QUFFQSxJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsU0FBUyxLQUFLO0FBRWxCLElBQUlDLGFBQWE7SUFFZiwwQkFBMEIsR0FFMUIsaUNBQWlDLEdBRWpDLDZEQUE2RCxHQUU3RCw0RkFBNEYsR0FFNUYsK0NBQStDLEdBRS9DLDBCQUEwQixHQUUxQixvREFBb0QsR0FFcEQsaUZBQWlGLEdBRWpGLFNBQVNBO1FBQ1AsSUFBSTlKLFFBQVEsSUFBSTtRQUVoQixJQUFJdkUsU0FBU2EsVUFBVTNCLE1BQU0sR0FBRyxLQUFLMkIsU0FBUyxDQUFDLEVBQUUsS0FBSzhDLFlBQVk5QyxTQUFTLENBQUMsRUFBRSxHQUFHcUMsYUFBYStHLFNBQVNxRSxJQUFJLEdBQUc7UUFDOUcsSUFBSVosY0FBYzdNLFVBQVUzQixNQUFNLEdBQUcsS0FBSzJCLFNBQVMsQ0FBQyxFQUFFLEtBQUs4QyxZQUFZOUMsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUN0Rm5CLGVBQWUsSUFBSSxFQUFFMk87UUFFckIsSUFBSSxDQUFDL0MsZ0JBQWdCLEdBQUc7WUFDdEIsSUFBSWlELGdCQUFnQmhLLE1BQU1nSyxhQUFhO1lBRXZDLElBQUlBLGtCQUFrQjVLLFdBQVc7Z0JBQy9CLE9BQU80SztZQUNUO1lBRUEsSUFBSUMsV0FBV2pLLE1BQU1rSyxJQUFJLENBQUMsRUFBRTtZQUM1QixJQUFJMUUsZUFBZTtZQUVuQixPQUFPeEYsTUFBTWdLLGFBQWEsR0FBR2QsUUFBUWxKLE1BQU12RSxNQUFNLEVBQUV3TyxXQUFXQSxTQUFTL0IsUUFBUSxHQUFHLE1BQU1sSSxNQUFNbUosV0FBVyxFQUFFM0Q7UUFDN0c7UUFFQW9FLGtCQUFrQjtRQUNsQixJQUFJLENBQUNwRyxFQUFFLEdBQUdvRztRQUNWLElBQUksQ0FBQ1QsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUMxTixNQUFNLEdBQUcwTixjQUFjLE9BQU8xTjtRQUNuQyxJQUFJLENBQUMwTyxNQUFNLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHLENBQUM7UUFDakIsSUFBSSxDQUFDQyxlQUFlLEdBQUcsQ0FBQztRQUN4QixJQUFJLENBQUNDLHFCQUFxQixHQUFHLENBQUM7UUFDOUIsSUFBSSxDQUFDSixJQUFJLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQ0ssUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7SUFDbEI7SUFFQSxrQ0FBa0MsR0FHbENWLFdBQVc1TyxTQUFTLENBQUNrTyxTQUFTLEdBQUcsU0FBU3FCO1FBQ3hDLElBQUksQ0FBQzlMLGNBQWMsSUFBSSxDQUFDd0ssV0FBVyxFQUFFLE9BQU8sSUFBSTtRQUVoRCxJQUFJRSxNQUFNLEVBQUU7UUFDWixJQUFJQyxZQUFZLEVBQUU7UUFDbEIsSUFBSW9CLGFBQWE7UUFFakIsdURBQXVELEdBQ3ZELElBQUlDLFFBQVFqRixTQUFTa0YsZ0JBQWdCLENBQUMsV0FBV3RNLFVBQVUsT0FBT0csa0JBQWtCLE9BQU8sVUFBVTtRQUVyRyxJQUFJb00sWUFBWUYsTUFBTWhRLE1BQU07UUFFNUIsMERBQTBELEdBQzFELElBQUksQ0FBQ2tRLFdBQVcsT0FBTyxJQUFJO1FBRTNCLElBQUssSUFBSXBRLElBQUksR0FBR0EsSUFBSW9RLFdBQVdwUSxLQUFLLEVBQUc7WUFDckMsSUFBSWtMLEtBQUtnRixLQUFLLENBQUNsUSxFQUFFO1lBRWpCLHdDQUF3QyxHQUN4QyxJQUFJLENBQUNpUSxZQUFZQSxhQUFhLENBQUMsQ0FBQy9FLEdBQUdtRixZQUFZLENBQUNwTTtZQUVoRCxnQ0FBZ0MsR0FDaEMsSUFBSXFNLFVBQVUsQ0FBQ3BGLEdBQUdtRixZQUFZLENBQUN4TSxZQUFZLEVBQUMsRUFBRzhCLElBQUksR0FBRzRLLEtBQUssQ0FBQ3RCO1lBQzVELElBQUl1QixjQUFjRixRQUFRcFEsTUFBTTtZQUNoQyxJQUFLLElBQUl1USxJQUFJLEdBQUdqTixNQUFNaU4sSUFBSUQsYUFBYUMsS0FBSyxFQUFHO2dCQUM3Q2pOLE9BQU84TSxPQUFPLENBQUNHLEVBQUU7Z0JBQ2pCLDBEQUEwRCxHQUMxRCxJQUFJLENBQUNiLGVBQWUsQ0FBQ3BNLEtBQUssR0FBRztZQUMvQjtZQUVBLHdDQUF3QyxHQUN4Q3FMLFVBQVUxTyxJQUFJLENBQUNzRixLQUFLLENBQUNvSixXQUFXL0ksYUFBYW9GLEdBQUd3RixXQUFXO1lBRTNELG1DQUFtQyxHQUNuQzlCLElBQUl6TyxJQUFJLENBQUMrSztRQUNYO1FBRUEsOENBQThDLEdBQzlDLElBQUl5RixnQkFBZ0I5QixVQUFVM08sTUFBTTtRQUNwQyxJQUFJLENBQUN5USxlQUFlLE9BQU8sSUFBSTtRQUUvQiwyQ0FBMkMsR0FDM0MsSUFBSW5ILE1BQU0sSUFBSSxDQUFDaUYsT0FBTyxDQUFDO1FBRXZCRSxVQUFVbkYsS0FBS29GLEtBQUtDO1FBRXBCLDZFQUE2RSxHQUM3RSxJQUFJLENBQUNpQixRQUFRLEdBQUdjLEtBQUtDLEdBQUcsQ0FBQyxHQUFHM0IsV0FBV3lCO1FBQ3ZDLElBQUksQ0FBQ2xCLElBQUksQ0FBQ3RQLElBQUksQ0FBQ3FKO1FBRWYsOEJBQThCLEdBQzlCLElBQUssSUFBSXNILEtBQUssR0FBR0EsS0FBS0gsZUFBZUcsTUFBTSxFQUFHO1lBQzVDLElBQUksQ0FBQ3BCLE1BQU0sQ0FBQ2IsU0FBUyxDQUFDaUMsR0FBRyxDQUFDM0ssV0FBVyxDQUFDLEdBQUdxRDtRQUMzQztRQUVBLE9BQU8sSUFBSTtJQUNiO0lBRUE7O2tDQUVnQyxHQUdoQyx3Q0FBd0MsR0FDeEM2RixXQUFXMEIsS0FBSyxHQUFHLFNBQVNBO1FBQzFCLElBQUlyQyxjQUFjN00sVUFBVTNCLE1BQU0sR0FBRyxLQUFLMkIsU0FBUyxDQUFDLEVBQUUsS0FBSzhDLFlBQVk5QyxTQUFTLENBQUMsRUFBRSxHQUFHO1FBRXRGdU4sU0FBUyxJQUFJQyxXQUFXMUssV0FBVytKLGFBQWFDLFNBQVM7SUFDM0Q7SUFFQTtvREFDa0QsR0FHbERVLFdBQVc1TyxTQUFTLENBQUM2SSxLQUFLLEdBQUcsU0FBU0E7UUFDcEMsSUFBSUcsUUFBUSxJQUFJNEYsV0FBVyxJQUFJLENBQUNyTyxNQUFNLEVBQUUsSUFBSSxDQUFDME4sV0FBVztRQUV4RCxzQkFBc0IsR0FDdEIsSUFBSSxDQUFDcUIsTUFBTSxDQUFDNVAsSUFBSSxDQUFDc0o7UUFFakIsa0JBQWtCLEdBQ2xCQSxNQUFNZ0csSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSSxDQUFDcEosR0FBRyxDQUFDLFNBQVVtRCxHQUFHO1lBQ3RDLElBQUl3SCxNQUFNeEgsSUFBSStELE1BQU07WUFDcEIsSUFBSTBELFNBQVN6SCxJQUFJRixLQUFLO1lBRXRCLHNCQUFzQixHQUN0QixJQUFLLElBQUl0SixJQUFJLEdBQUdBLElBQUlnUixJQUFJOVEsTUFBTSxFQUFFRixLQUFLLEVBQUc7Z0JBQ3RDeUosTUFBTWlHLE1BQU0sQ0FBQ3NCLEdBQUcsQ0FBQ2hSLEVBQUUsQ0FBQyxHQUFHaVI7WUFDekI7WUFFQSxPQUFPQTtRQUNUO1FBRUEsb0JBQW9CLEdBQ3BCeEgsTUFBTW1HLGVBQWUsR0FBR2pPLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQ2lPLGVBQWU7UUFDekRuRyxNQUFNa0csUUFBUSxHQUFHaE8sU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDZ08sUUFBUTtRQUUzQyxPQUFPbEc7SUFDVDtJQUVBLDhEQUE4RCxHQUc5RDRGLFdBQVc1TyxTQUFTLENBQUN5USxXQUFXLEdBQUcsU0FBU0E7UUFDMUMsSUFBSSxDQUFDcEIsUUFBUSxHQUFHO1FBRWhCLElBQUksQ0FBQ0wsSUFBSSxDQUFDM0ssT0FBTyxDQUFDLFNBQVUwRSxHQUFHO1lBQzdCLDZDQUE2QztZQUM3Q0EsSUFBSWdFLE1BQU0sR0FBRztRQUNmO0lBQ0Y7SUFFQTZCLFdBQVc1TyxTQUFTLENBQUNnTyxPQUFPLEdBQUcsU0FBUzBDLFdBQVczSCxHQUFHO1FBQ3BELElBQUk0SCxTQUFTNUgsTUFBTUEsSUFBSWlFLFFBQVEsR0FBRztRQUNsQyxJQUFJMUMsZUFBZTtRQUVuQixPQUFPMEQsUUFBUSxJQUFJLENBQUN6TixNQUFNLEVBQUVvUSxRQUFRLElBQUksQ0FBQzFDLFdBQVcsRUFBRTNELGNBQWMsSUFBSSxDQUFDdUIsZ0JBQWdCO0lBQzNGO0lBRUEsOEVBQThFLEdBQzlFK0MsV0FBVzVPLFNBQVMsQ0FBQzRRLFdBQVcsR0FBRyxTQUFTQSxZQUFZdEksRUFBRTtRQUN4RCxzRUFBc0UsR0FDdEUsSUFBSTJELE9BQU8sSUFBSSxDQUFDZ0QsTUFBTSxDQUFDM0csR0FBRztRQUMxQixJQUFJMkQsU0FBUy9ILGFBQWEsQ0FBQytILEtBQUtjLE1BQU0sRUFBRTtZQUN0QyxPQUFPZDtRQUNUO1FBRUEsSUFBSWxELE1BQU0sSUFBSSxDQUFDaUcsSUFBSSxDQUFDLElBQUksQ0FBQ0EsSUFBSSxDQUFDdlAsTUFBTSxHQUFHLEVBQUU7UUFFekMsbUVBQW1FLEdBQ25FLElBQUksQ0FBQzRQLFFBQVEsSUFBSTtRQUVqQixJQUFJLElBQUksQ0FBQ0EsUUFBUSxLQUFLLEdBQUc7WUFDdkIsSUFBSSxDQUFDQSxRQUFRLEdBQUdaO1lBQ2hCMUYsTUFBTSxJQUFJLENBQUNpRixPQUFPLENBQUNqRjtZQUNuQixJQUFJLENBQUNpRyxJQUFJLENBQUN0UCxJQUFJLENBQUNxSjtRQUNqQjtRQUVBLE9BQU8sSUFBSSxDQUFDa0csTUFBTSxDQUFDM0csR0FBRyxHQUFHUztJQUMzQjtJQUVBLG9EQUFvRCxHQUdwRDZGLFdBQVc1TyxTQUFTLENBQUM2USxLQUFLLEdBQUcsU0FBU0EsTUFBTXZJLEVBQUU7UUFDNUMsT0FBTyxJQUFJLENBQUMyRyxNQUFNLENBQUMzRyxHQUFHLEtBQUtwRTtJQUM3QjtJQUVBLHlGQUF5RixHQUd6RjBLLFdBQVc1TyxTQUFTLENBQUN5SSxZQUFZLEdBQUcsU0FBU0EsYUFBYUgsRUFBRSxFQUFFdkYsSUFBSTtRQUNoRSwrREFBK0QsR0FDL0QsSUFBSSxJQUFJLENBQUNxTSxxQkFBcUIsQ0FBQzlHLEdBQUcsS0FBS3BFLGFBQWEsSUFBSSxDQUFDaUwsZUFBZSxDQUFDcE0sS0FBSyxFQUFFO1lBQzlFLE9BQU87UUFDVDtRQUVBLElBQUlnRyxNQUFNLElBQUksQ0FBQ2tHLE1BQU0sQ0FBQzNHLEdBQUc7UUFDekIsT0FBT1MsUUFBUTdFLGFBQWE2RSxJQUFJTixZQUFZLENBQUNILElBQUl2RjtJQUNuRDtJQUVBLHVEQUF1RCxHQUd2RDZMLFdBQVc1TyxTQUFTLENBQUM4USxjQUFjLEdBQUcsU0FBU0EsZUFBZXhJLEVBQUUsRUFBRW1CLFFBQVE7UUFDeEUsa0RBQWtELEdBQ2xELElBQUksSUFBSSxDQUFDd0YsTUFBTSxDQUFDM0csR0FBRyxLQUFLcEUsV0FBVztRQUVuQyxJQUFJb0wsU0FBUyxJQUFJLENBQUNBLE1BQU07UUFFeEIsSUFBSyxJQUFJL1AsSUFBSSxHQUFHQSxJQUFJK1AsT0FBTzdQLE1BQU0sRUFBRUYsS0FBSyxFQUFHO1lBQ3pDK1AsTUFBTSxDQUFDL1AsRUFBRSxDQUFDdVIsY0FBYyxDQUFDeEksSUFBSW1CO1FBQy9CO1FBRUEsSUFBSSxDQUFDbUgsV0FBVyxDQUFDdEksSUFBSTBELFlBQVksQ0FBQzFEO1FBQ2xDLElBQUksQ0FBQzRHLFFBQVEsQ0FBQzVHLEdBQUcsR0FBR21CO0lBQ3RCO0lBRUEsd0VBQXdFLEdBR3hFbUYsV0FBVzVPLFNBQVMsQ0FBQytRLE1BQU0sR0FBRyxTQUFTQSxPQUFPekksRUFBRSxFQUFFbUIsUUFBUSxFQUFFMUcsSUFBSTtRQUM5RCxJQUFJdU0sU0FBUyxJQUFJLENBQUNBLE1BQU07UUFHeEIsSUFBSyxJQUFJL1AsSUFBSSxHQUFHQSxJQUFJK1AsT0FBTzdQLE1BQU0sRUFBRUYsS0FBSyxFQUFHO1lBQ3pDK1AsTUFBTSxDQUFDL1AsRUFBRSxDQUFDd1IsTUFBTSxDQUFDekksSUFBSW1CLFVBQVUxRztRQUNqQztRQUVBLElBQUlnRyxNQUFNLElBQUksQ0FBQzZILFdBQVcsQ0FBQ3RJO1FBRTNCLG9DQUFvQyxHQUNwQyxJQUFJLElBQUksQ0FBQzRHLFFBQVEsQ0FBQzVHLEdBQUcsS0FBS3BFLFdBQVc7WUFDbkMsNkRBQTZEO1lBQzdELGlFQUFpRTtZQUNqRSxxQ0FBcUM7WUFDckMsSUFBSTJELFFBQVEsSUFBSSxDQUFDcUgsUUFBUSxDQUFDNUcsR0FBRyxDQUFDckQsTUFBTSxDQUFDd0U7WUFDckNWLElBQUltRCxXQUFXLENBQUM1RCxJQUFJVCxPQUFPOUU7WUFFM0IsSUFBSSxDQUFDbU0sUUFBUSxDQUFDNUcsR0FBRyxHQUFHcEU7UUFDdEIsT0FBTztZQUNMNkUsSUFBSW1ELFdBQVcsQ0FBQzVELElBQUltQixVQUFVMUc7UUFDaEM7SUFDRjtJQUVBLG1GQUFtRixHQUduRjZMLFdBQVc1TyxTQUFTLENBQUNnUixNQUFNLEdBQUcsU0FBU0EsT0FBTzFJLEVBQUU7UUFDOUMsSUFBSVMsTUFBTSxJQUFJLENBQUNrRyxNQUFNLENBQUMzRyxHQUFHO1FBQ3pCLElBQUlTLFFBQVE3RSxXQUFXO1FBRXZCLElBQUlvTCxTQUFTLElBQUksQ0FBQ0EsTUFBTTtRQUV4QixJQUFLLElBQUkvUCxJQUFJLEdBQUdBLElBQUkrUCxPQUFPN1AsTUFBTSxFQUFFRixLQUFLLEVBQUc7WUFDekMrUCxNQUFNLENBQUMvUCxFQUFFLENBQUN5UixNQUFNLENBQUMxSTtRQUNuQjtRQUVBLGlDQUFpQyxHQUNqQ1MsSUFBSTBELFdBQVcsQ0FBQ25FO1FBRWhCLG9DQUFvQyxHQUNwQyxJQUFJLENBQUM4RyxxQkFBcUIsQ0FBQzlHLEdBQUcsR0FBRztRQUVqQyxrQ0FBa0MsR0FDbEMsSUFBSSxDQUFDNEcsUUFBUSxDQUFDNUcsR0FBRyxHQUFHcEU7SUFDdEI7SUFFQTBLLFdBQVc1TyxTQUFTLENBQUNrTixNQUFNLEdBQUcsU0FBU0E7UUFDckMsT0FBTyxJQUFJLENBQUM4QixJQUFJLENBQUNwSixHQUFHLENBQUMsU0FBVW1ELEdBQUc7WUFDaEMsT0FBT0EsSUFBSW1FLE1BQU07UUFDbkIsR0FBR25JLElBQUksQ0FBQztJQUNWO0lBRUE2SixXQUFXNU8sU0FBUyxDQUFDaVIsZUFBZSxHQUFHLFNBQVNBO1FBQzlDLElBQUkzSSxLQUFLLElBQUksQ0FBQ0EsRUFBRTtRQUdoQixPQUFPLElBQUksQ0FBQzBHLElBQUksQ0FBQ3BKLEdBQUcsQ0FBQyxTQUFVbUQsR0FBRyxFQUFFeEosQ0FBQztZQUNuQyxJQUFJd0IsTUFBTSxRQUFRdUgsS0FBSyxNQUFNL0k7WUFDN0IscUJBQU9qQixtREFBWUEsQ0FBQ3lLLElBQUlrRSxTQUFTLElBQUk7Z0JBQUVsTSxLQUFLQTtZQUFJO1FBQ2xEO0lBQ0Y7SUFFQVYsWUFBWXVPLFlBQVksTUFBTTtRQUFDO1lBQzdCN04sS0FBSztZQUNMbVEsS0FBSyxTQUFTQztnQkFDWixPQUFPeEMsVUFBV0EsQ0FBQUEsU0FBUyxJQUFJQyxhQUFhVixTQUFTLEVBQUM7WUFDeEQ7UUFJRjtRQUFHO1lBQ0RuTixLQUFLO1lBQ0xtUSxLQUFLLFNBQVNDO2dCQUNaLE9BQU92QyxXQUFXRCxNQUFNO1lBQzFCO1FBQ0Y7S0FBRTtJQUNGLE9BQU9DO0FBQ1Q7QUFFQSxHQUFHO0FBRUgsSUFBSXdDLFlBQVk7SUFDZCxTQUFTQSxVQUFVck8sSUFBSSxFQUFFOEUsS0FBSztRQUM1QixJQUFJL0MsUUFBUSxJQUFJO1FBRWhCN0UsZUFBZSxJQUFJLEVBQUVtUjtRQUVyQixJQUFJLENBQUNMLE1BQU0sR0FBRyxTQUFVTSxVQUFVO1lBQ2hDLElBQUksQ0FBQ0EsV0FBVzVJLFlBQVksQ0FBQzNELE1BQU13RCxFQUFFLEVBQUV4RCxNQUFNL0IsSUFBSSxHQUFHO2dCQUNsRHNPLFdBQVdOLE1BQU0sQ0FBQ2pNLE1BQU13RCxFQUFFLEVBQUV4RCxNQUFNK0MsS0FBSyxFQUFFL0MsTUFBTS9CLElBQUk7WUFDckQ7UUFDRjtRQUVBLElBQUksQ0FBQ3VPLFFBQVEsR0FBRztZQUNkLE1BQU0sSUFBSTlNLHNCQUFzQixJQUFJK00sT0FBT3pNLE1BQU0vQixJQUFJO1FBQ3ZEO1FBRUEsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDOEUsS0FBSyxHQUFHQTtRQUViLElBQUksQ0FBQ1MsRUFBRSxHQUFHLGtCQUFrQnZGO0lBQzlCO0lBRUFxTyxVQUFVcFIsU0FBUyxDQUFDd1IsT0FBTyxHQUFHLFNBQVNBO1FBQ3JDLE9BQU8sSUFBSSxDQUFDek8sSUFBSTtJQUNsQjtJQUVBLE9BQU9xTztBQUNUO0FBRUEsR0FBRztBQUVIOzs7Q0FHQyxHQUVELElBQUlLLG1CQUFtQjtBQUN2QixJQUFJQyxZQUFZO0FBRWhCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELFNBQVNDLG1CQUFtQnRLLE1BQU07SUFDaEMsT0FBT0EsT0FBTzlDLE9BQU8sQ0FBQ2tOLGtCQUFrQixPQUFPRyxXQUFXLEdBQUdyTixPQUFPLENBQUNtTixXQUFXO0FBQ2xGO0FBRUEsR0FBRztBQUVILGtKQUFrSjtBQUNsSixTQUFTRyxnQkFBZ0I5TyxJQUFJLEVBQUVuQixLQUFLO0lBQ2xDLHdFQUF3RTtJQUN4RSxhQUFhO0lBQ2IsSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsYUFBYUEsVUFBVSxJQUFJO1FBQy9ELE9BQU87SUFDVDtJQUVBLElBQUksT0FBT0EsVUFBVSxZQUFZQSxVQUFVLEtBQUssQ0FBRW1CLENBQUFBLFFBQVFyRSx5REFBTyxHQUFJO1FBQ25FLE9BQU9rRCxRQUFRLE1BQU0scURBQXFEO0lBQzVFO0lBRUEsT0FBTzJQLE9BQU8zUCxPQUFPc0QsSUFBSTtBQUMzQjtBQUVBLEdBQUc7QUFFSDs7Q0FFQyxHQUNELElBQUk0TSxZQUFZLFNBQVNBLFVBQVVDLEtBQUs7SUFDdEMsT0FBT0EsVUFBVTdOLGFBQWE2TixVQUFVLFFBQVFBLFVBQVUsU0FBU0EsVUFBVTtBQUMvRTtBQUVBLElBQUlDLGdCQUFnQixTQUFTQSxjQUFjbFMsR0FBRyxFQUFFbVMsT0FBTztJQUNyRCxJQUFJcEssUUFBUSxFQUFFO0lBQ2QsSUFBSTdGLE9BQU9uQixPQUFPbUIsSUFBSSxDQUFDbEM7SUFFdkJrQyxLQUFLcUMsT0FBTyxDQUFDLFNBQVV0RCxHQUFHO1FBQ3hCLElBQUksQ0FBQytRLFVBQVVoUyxHQUFHLENBQUNpQixJQUFJLEdBQUc7WUFDeEIsSUFBSXNCLGNBQWN2QyxHQUFHLENBQUNpQixJQUFJLEdBQUc7Z0JBQzNCOEcsTUFBTW5JLElBQUksQ0FBQ3NGLEtBQUssQ0FBQzZDLE9BQU9tSyxjQUFjbFMsR0FBRyxDQUFDaUIsSUFBSSxFQUFFQTtnQkFFaEQsT0FBTzhHO1lBQ1QsT0FBTyxJQUFJbkYsV0FBVzVDLEdBQUcsQ0FBQ2lCLElBQUksR0FBRztnQkFDL0I4RyxNQUFNbkksSUFBSSxDQUFDaVMsbUJBQW1CNVEsT0FBTyxLQUFLakIsR0FBRyxDQUFDaUIsSUFBSSxFQUFFO2dCQUVwRCxPQUFPOEc7WUFDVDtZQUNBQSxNQUFNbkksSUFBSSxDQUFDaVMsbUJBQW1CNVEsT0FBTyxPQUFPOFEsZ0JBQWdCOVEsS0FBS2pCLEdBQUcsQ0FBQ2lCLElBQUksSUFBSTtRQUMvRTtRQUNBLE9BQU84RztJQUNUO0lBRUEsT0FBT29LLFVBQVU7UUFBQ0EsVUFBVTtLQUFLLENBQUNoTixNQUFNLENBQUM0QyxPQUFPO1FBQUM7S0FBSSxJQUFJQTtBQUMzRDtBQUVBLFNBQVNxSyxRQUFRSCxLQUFLLEVBQUVJLGdCQUFnQixFQUFFZCxVQUFVO0lBQ2xELElBQUl6TSxNQUFNd04sT0FBTyxDQUFDTCxRQUFRO1FBQ3hCLElBQUlNLFVBQVUsRUFBRTtRQUVoQixJQUFLLElBQUk5UyxJQUFJLEdBQUdDLE1BQU11UyxNQUFNdFMsTUFBTSxFQUFFSCxRQUFRQyxJQUFJQyxLQUFLRCxLQUFLLEVBQUc7WUFDM0RELFNBQVM0UyxRQUFRSCxLQUFLLENBQUN4UyxFQUFFLEVBQUU0UyxrQkFBa0JkO1lBRTdDLElBQUkvUixXQUFXLE1BQU07aUJBQWMsSUFBSXNGLE1BQU13TixPQUFPLENBQUM5UyxTQUFTK1MsUUFBUTNTLElBQUksQ0FBQ3NGLEtBQUssQ0FBQ3FOLFNBQVMvUztpQkFBYStTLFFBQVEzUyxJQUFJLENBQUNKO1FBQ3RIO1FBRUEsT0FBTytTO0lBQ1Q7SUFFQSxJQUFJUCxVQUFVQyxRQUFRO1FBQ3BCLE9BQU87SUFDVDtJQUVBLDJCQUEyQixHQUMzQixJQUFJN08sa0JBQWtCNk8sUUFBUTtRQUM1QixPQUFPLE1BQU1BLE1BQU01TyxpQkFBaUI7SUFDdEM7SUFFQSx3Q0FBd0MsR0FDeEMsSUFBSVQsV0FBV3FQLFFBQVE7UUFDckIsSUFBSS9PLG9CQUFvQitPLFVBQVVJLGtCQUFrQjtZQUNsRCxJQUFJRyxVQUFVUCxNQUFNSTtZQUVwQixJQUFJdFAsS0FBeUIsSUFBZ0JsRSxtREFBU0EsQ0FBQzJULFVBQVU7Z0JBQy9ELHNDQUFzQztnQkFDdENDLFFBQVFDLElBQUksQ0FBQzVQLGlCQUFpQm1QLFNBQVM7WUFDekM7WUFFQSxPQUFPRyxRQUFRSSxTQUFTSCxrQkFBa0JkO1FBQzVDLE9BQU8sT0FBT1U7SUFDaEI7SUFFQSxJQUFJQSxpQkFBaUJYLFdBQVc7UUFDOUIsSUFBSUMsWUFBWTtZQUNkVSxNQUFNaEIsTUFBTSxDQUFDTTtZQUNiLE9BQU9VLE1BQU1QLE9BQU87UUFDdEIsT0FBTyxPQUFPTztJQUNoQjtJQUVBLGtCQUFrQixHQUNsQixPQUFPMVAsY0FBYzBQLFNBQVNDLGNBQWNELFNBQVNBLE1BQU1ULFFBQVE7QUFDckU7QUFFQSxHQUFHO0FBRUgsU0FBUy9MLElBQUlrTixNQUFNO0lBQ2pCLElBQUssSUFBSTlOLE9BQU92RCxVQUFVM0IsTUFBTSxFQUFFSixpQkFBaUJ1RixNQUFNRCxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJRSxPQUFPLEdBQUdBLE9BQU9GLE1BQU1FLE9BQVE7UUFDaEh4RixjQUFjLENBQUN3RixPQUFPLEVBQUUsR0FBR3pELFNBQVMsQ0FBQ3lELEtBQUs7SUFDNUM7SUFFQSxJQUFJbkMsV0FBVytQLFdBQVdwUSxjQUFjb1EsU0FBUztRQUMvQyxhQUFhO1FBQ2IsT0FBT1AsUUFBUS9TLFdBQVdvRCxhQUFhO1lBQUNrUTtTQUFPLENBQUN4TixNQUFNLENBQUM1RjtJQUN6RDtJQUVBLGFBQWE7SUFDYixPQUFPNlMsUUFBUS9TLFdBQVdzVCxRQUFRcFQ7QUFDcEM7QUFFQSxHQUFHO0FBRUgsU0FBU3FULHFCQUFxQkMsb0JBQW9CLEVBQUU1SixHQUFHO0lBQ3JELElBQUk2SixVQUFVeFIsVUFBVTNCLE1BQU0sR0FBRyxLQUFLMkIsU0FBUyxDQUFDLEVBQUUsS0FBSzhDLFlBQVk5QyxTQUFTLENBQUMsRUFBRSxHQUFHcUI7SUFFbEYsSUFBSSxDQUFDN0QsNERBQWtCQSxDQUFDbUssTUFBTTtRQUM1QixNQUFNLElBQUl2RSxzQkFBc0IsR0FBRytNLE9BQU94STtJQUM1QztJQUVBLG9EQUFvRCxHQUNwRCx5REFBeUQ7SUFDekQsSUFBSThKLG1CQUFtQixTQUFTQTtRQUM5QixPQUFPRixxQkFBcUI1SixLQUFLNkosU0FBU3JOLElBQUlQLEtBQUssQ0FBQ2QsV0FBVzlDO0lBQ2pFO0lBRUEsbUZBQW1GLEdBQ25GeVIsaUJBQWlCQyxVQUFVLEdBQUcsU0FBVUMsTUFBTTtRQUM1QyxPQUFPTCxxQkFBcUJDLHNCQUFzQjVKLEtBQUs3SCxTQUFTLENBQUMsR0FBRzBSLFNBQVNHO0lBQy9FO0lBRUEsc0NBQXNDLEdBQ3RDRixpQkFBaUIzSCxLQUFLLEdBQUcsU0FBVUEsS0FBSztRQUN0QyxPQUFPd0gscUJBQXFCQyxzQkFBc0I1SixLQUFLN0gsU0FBUyxDQUFDLEdBQUcwUixTQUFTO1lBQzNFMUgsT0FBT3RHLE1BQU01RSxTQUFTLENBQUNpRixNQUFNLENBQUMyTixRQUFRMUgsS0FBSyxFQUFFQSxPQUFPRSxNQUFNLENBQUNDO1FBQzdEO0lBQ0Y7SUFFQSxPQUFPd0g7QUFDVDtBQUVBLEdBQUc7QUFDSCxtRkFBbUY7QUFDbkYsU0FBU0csV0FBVzVPLENBQUM7SUFDbkIsSUFBSyxJQUFJNk8sSUFBSTdPLEVBQUUzRSxNQUFNLEdBQUcsR0FBR3dFLElBQUlnUCxJQUFJLEdBQUczTyxJQUFJLEdBQUdILEdBQUc4TyxLQUFLLEdBQUk7UUFDdkQ5TyxJQUFJQyxFQUFFOE8sVUFBVSxDQUFDNU8sS0FBSyxNQUFNLENBQUNGLEVBQUU4TyxVQUFVLENBQUMsRUFBRTVPLEtBQUssR0FBRSxLQUFNLElBQUksQ0FBQ0YsRUFBRThPLFVBQVUsQ0FBQyxFQUFFNU8sS0FBSyxHQUFFLEtBQU0sS0FBSyxDQUFDRixFQUFFOE8sVUFBVSxDQUFDLEVBQUU1TyxLQUFLLEdBQUUsS0FBTSxJQUFJSCxJQUFJLGFBQWNBLENBQUFBLElBQUksS0FBSSxJQUFNLEVBQUMsYUFBY0EsQ0FBQUEsTUFBTSxFQUFDLElBQUssS0FBSSxLQUFNLEVBQUMsR0FBSUEsS0FBS0EsTUFBTSxJQUFJQSxJQUFJLGFBQWNBLENBQUFBLElBQUksS0FBSSxJQUFNLEVBQUMsYUFBY0EsQ0FBQUEsTUFBTSxFQUFDLElBQUssS0FBSSxLQUFNLEVBQUMsR0FBSUYsSUFBSSxhQUFjQSxDQUFBQSxJQUFJLEtBQUksSUFBTSxFQUFDLGFBQWNBLENBQUFBLE1BQU0sRUFBQyxJQUFLLEtBQUksS0FBTSxFQUFDLElBQUtFLEdBQUc4TyxLQUFLLEdBQUcsRUFBRTNPO0lBQzdYO0lBQ0EsT0FBUTJPO1FBQ04sS0FBSztZQUNIaFAsS0FBSyxDQUFDRyxFQUFFOE8sVUFBVSxDQUFDNU8sSUFBSSxLQUFLLEdBQUUsS0FBTTtRQUN0QyxLQUFLO1lBQ0hMLEtBQUssQ0FBQ0csRUFBRThPLFVBQVUsQ0FBQzVPLElBQUksS0FBSyxHQUFFLEtBQU07UUFDdEMsS0FBSztZQUNITCxLQUFLRyxFQUFFOE8sVUFBVSxDQUFDNU8sS0FBSyxLQUFLTCxJQUFJLGFBQWNBLENBQUFBLElBQUksS0FBSSxJQUFNLEVBQUMsYUFBY0EsQ0FBQUEsTUFBTSxFQUFDLElBQUssS0FBSSxLQUFNLEVBQUM7SUFDdEc7SUFDQUEsS0FBS0EsTUFBTTtJQUNYQSxJQUFJLGFBQWNBLENBQUFBLElBQUksS0FBSSxJQUFNLEVBQUMsYUFBY0EsQ0FBQUEsTUFBTSxFQUFDLElBQUssS0FBSSxLQUFNLEVBQUM7SUFDdEUsT0FBTyxDQUFDQSxJQUFJQSxNQUFNLEVBQUMsTUFBTztBQUM1QjtBQUVBLEdBQUc7QUFDSCw2QkFBNkIsR0FFN0I7Z0JBQ2dCLEdBQ2hCLElBQUlrUCxjQUFjO0FBRWxCLG1GQUFtRixHQUNuRixJQUFJQyxvQkFBb0IsU0FBU0Esa0JBQWtCMU8sSUFBSTtJQUNyRCxPQUFPNk0sT0FBTzhCLFlBQVksQ0FBQzNPLE9BQVFBLENBQUFBLE9BQU8sS0FBSyxLQUFLLEVBQUM7QUFDdkQ7QUFFQSw0REFBNEQsR0FDNUQsU0FBUzRPLHVCQUF1QjVPLElBQUk7SUFDbEMsSUFBSTNCLE9BQU87SUFDWCxJQUFJVCxJQUFJLEtBQUs7SUFFYiw0Q0FBNEMsR0FDNUMsSUFBS0EsSUFBSW9DLE1BQU1wQyxJQUFJNlEsYUFBYTdRLElBQUk2TixLQUFLb0QsS0FBSyxDQUFDalIsSUFBSTZRLGFBQWM7UUFDL0RwUSxPQUFPcVEsa0JBQWtCOVEsSUFBSTZRLGVBQWVwUTtJQUM5QztJQUVBLE9BQU9xUSxrQkFBa0I5USxJQUFJNlEsZUFBZXBRO0FBQzlDO0FBRUEsR0FBRztBQUVILFNBQVN5USxxQkFBcUIxVCxHQUFHO0lBQy9CLDhEQUE4RDtJQUM5RCxJQUFLLElBQUlpQixPQUFPakIsSUFBSztRQUNuQixJQUFJNEMsV0FBVzVDLEdBQUcsQ0FBQ2lCLElBQUksR0FBRztZQUN4QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBLFNBQVMwUyxjQUFjNUwsS0FBSyxFQUFFcUQsS0FBSztJQUNqQyxJQUFLLElBQUkzTCxJQUFJLEdBQUdBLElBQUlzSSxNQUFNcEksTUFBTSxFQUFFRixLQUFLLEVBQUc7UUFDeEMsSUFBSXdILE9BQU9jLEtBQUssQ0FBQ3RJLEVBQUU7UUFFbkIsaUJBQWlCO1FBQ2pCLElBQUlxRixNQUFNd04sT0FBTyxDQUFDckwsU0FBUyxDQUFDME0sY0FBYzFNLE1BQU1tRSxRQUFRO1lBQ3RELE9BQU87UUFDVCxPQUFPLElBQUl4SSxXQUFXcUUsU0FBUyxDQUFDN0Qsa0JBQWtCNkQsT0FBTztZQUN2RCwyREFBMkQ7WUFDM0QseURBQXlEO1lBQ3pELE9BQU87UUFDVDtJQUNGO0lBRUEsSUFBSW1FLE1BQU13SSxJQUFJLENBQUMsU0FBVXBSLENBQUM7UUFDeEIsT0FBT0ksV0FBV0osTUFBTWtSLHFCQUFxQmxSO0lBQy9DLElBQUksT0FBTztJQUVYLE9BQU87QUFDVDtBQUVBLEdBQUc7QUFFSCxtRUFBbUUsR0FDbkUsSUFBSXFSLFNBQVMsU0FBU0EsT0FBT2hMLEdBQUc7SUFDOUIsT0FBTzJLLHVCQUF1Qk4sV0FBV3JLO0FBQzNDO0FBRUE7OztDQUdDLEdBRUQsSUFBSWlMLGlCQUFpQjtJQUNuQixTQUFTQSxlQUFlL0wsS0FBSyxFQUFFcUQsS0FBSyxFQUFFeEYsV0FBVztRQUMvQ3pGLGVBQWUsSUFBSSxFQUFFMlQ7UUFFckIsSUFBSSxDQUFDL0wsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ2dNLFFBQVEsR0FBR2hSLE1BQXlCLElBQWdCNFEsQ0FBMkJ2STtRQUNwRixJQUFJLENBQUN4RixXQUFXLEdBQUdBO1FBRW5CLElBQUksQ0FBQ2tKLFdBQVdELE1BQU0sQ0FBQ2tDLEtBQUssQ0FBQ25MLGNBQWM7WUFDekNrSixXQUFXRCxNQUFNLENBQUNtQyxjQUFjLENBQUNwTCxhQUFhLEVBQUU7UUFDbEQ7SUFDRjtJQUVBOzs7O0tBSUcsR0FHSGtPLGVBQWU1VCxTQUFTLENBQUM4VCx1QkFBdUIsR0FBRyxTQUFTQSx3QkFBd0IzQixnQkFBZ0IsRUFBRWQsVUFBVTtRQUM5RyxJQUFJd0MsV0FBVyxJQUFJLENBQUNBLFFBQVEsRUFDeEJuTyxjQUFjLElBQUksQ0FBQ0EsV0FBVyxFQUM5QnFPLGdCQUFnQixJQUFJLENBQUNBLGFBQWE7UUFFdEMsSUFBSXRRLGNBQWNvUSxZQUFZLE9BQU9FLGtCQUFrQixZQUFZMUMsV0FBVzVJLFlBQVksQ0FBQy9DLGFBQWFxTyxnQkFBZ0I7WUFDdEgsT0FBT0E7UUFDVDtRQUVBLElBQUloTSxVQUFVbUssUUFBUSxJQUFJLENBQUNySyxLQUFLLEVBQUVzSyxrQkFBa0JkO1FBQ3BELElBQUl0TyxPQUFPNFEsT0FBTyxJQUFJLENBQUNqTyxXQUFXLEdBQUdxQyxRQUFRaEQsSUFBSSxDQUFDO1FBQ2xELElBQUksQ0FBQ3NNLFdBQVc1SSxZQUFZLENBQUMvQyxhQUFhM0MsT0FBTztZQUMvQ3NPLFdBQVdOLE1BQU0sQ0FBQyxJQUFJLENBQUNyTCxXQUFXLEVBQUVrQyxlQUFlRyxTQUFTLE1BQU1oRixNQUFNbUIsV0FBV3dCLGNBQWMzQztRQUNuRztRQUVBLElBQUksQ0FBQ2dSLGFBQWEsR0FBR2hSO1FBQ3JCLE9BQU9BO0lBQ1Q7SUFFQTZRLGVBQWVJLFlBQVksR0FBRyxTQUFTQSxhQUFhckwsR0FBRztRQUNyRCxPQUFPZ0wsT0FBT2hMO0lBQ2hCO0lBRUEsT0FBT2lMO0FBQ1Q7QUFFQSxHQUFHO0FBRUgsSUFBSUssUUFBUTtBQUVaLElBQUlDLDJCQUE0QixTQUFVcFIsV0FBVztJQUNuRCxJQUFJcVIsbUJBQW1CLENBQUM7SUFDeEIsSUFBSUMsY0FBYztJQUVsQixPQUFPLFNBQVVDLFNBQVM7UUFDeEIsSUFBSSxDQUFDRCxhQUFhO1lBQ2hCRCxnQkFBZ0IsQ0FBQ0UsVUFBVSxHQUFHO1lBQzlCLElBQUl4VCxPQUFPbUIsSUFBSSxDQUFDbVMsa0JBQWtCMVUsTUFBTSxJQUFJd1UsT0FBTztnQkFDakQsaURBQWlEO2dCQUNqRCw4Q0FBOEMsR0FDOUMxQixRQUFRQyxJQUFJLENBQUMsVUFBVXlCLFFBQVEsMkNBQTJDblIsY0FBYyxTQUFTLG1HQUFtRyxlQUFlLHVEQUF1RCxtQkFBbUIsMENBQTBDLGFBQWEsNEJBQTRCO2dCQUNoWHNSLGNBQWM7Z0JBQ2RELG1CQUFtQixDQUFDO1lBQ3RCO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsR0FBRztBQUVILElBQUlHLGlCQUFrQixTQUFVOVQsS0FBSyxFQUFFK1QsYUFBYTtJQUNsRCxJQUFJQyxlQUFlcFQsVUFBVTNCLE1BQU0sR0FBRyxLQUFLMkIsU0FBUyxDQUFDLEVBQUUsS0FBSzhDLFlBQVk5QyxTQUFTLENBQUMsRUFBRSxHQUFHcUI7SUFFdkYscUZBQXFGO0lBQ3JGLG9FQUFvRTtJQUVwRSxnRUFBZ0UsR0FDaEUsSUFBSWdTLGlCQUFpQkQsZUFBZWhVLE1BQU1rVSxLQUFLLEtBQUtGLGFBQWFFLEtBQUssR0FBRztJQUN6RSxJQUFJQSxRQUFRbFUsTUFBTWtVLEtBQUssSUFBSSxDQUFDRCxpQkFBaUJqVSxNQUFNa1UsS0FBSyxHQUFHSCxpQkFBaUJDLGFBQWFFLEtBQUs7SUFDOUYsaUJBQWlCLEdBRWpCLE9BQU9BO0FBQ1Q7QUFFQSxHQUFHO0FBQ0gsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxlQUFlO0FBRW5COzs7Q0FHQyxHQUNELFNBQVNDLE9BQU9sTSxHQUFHO0lBQ2pCLE9BQU9BLEdBQ1AscUNBQXFDO0tBQ3BDcEUsT0FBTyxDQUFDb1EsYUFBYSxJQUV0QixpREFBaUQ7S0FDaERwUSxPQUFPLENBQUNxUSxjQUFjO0FBQ3pCO0FBRUEsR0FBRztBQUVILFNBQVNFLE1BQU12VSxNQUFNO0lBQ25CLE9BQU8sT0FBT0EsV0FBVyxZQUFhc0MsQ0FBQUEsS0FBeUIsR0FBZXRDLE9BQU93VSxNQUFNLENBQUMsT0FBT3hVLE9BQU93VSxNQUFNLENBQUMsR0FBR25ELFdBQVcsS0FBSyxDQUFHO0FBQ3pJO0FBRUEsR0FBRztBQUVILFNBQVNvRCxvQkFBb0J6VSxNQUFNO0lBQ2pDLGFBQWE7SUFDYixPQUFPdVUsTUFBTXZVLFVBQVUsWUFBWUEsU0FBUyxZQUFZcUMsaUJBQWlCckMsVUFBVTtBQUNyRjtBQUVBLElBQUkwVTtBQUVKLElBQUlDLGdCQUFnQjtJQUNsQkMsbUJBQW1CO0lBQ25CQyxjQUFjO0lBQ2RaLGNBQWM7SUFDZDFSLGFBQWE7SUFDYnVTLDBCQUEwQjtJQUMxQkMsV0FBVztJQUNYQyxNQUFNO0FBQ1I7QUFFQSxJQUFJQyxnQkFBZ0I7SUFDbEJ6UyxNQUFNO0lBQ050RCxRQUFRO0lBQ1JPLFdBQVc7SUFDWHlWLFFBQVE7SUFDUkMsUUFBUTtJQUNSdFUsV0FBVztJQUNYdVUsT0FBTztBQUNUO0FBRUEsSUFBSUMsZUFBZ0JYLENBQUFBLGdCQUFnQixDQUFDLEdBQUdBLGFBQWEsQ0FBQ3BXLGdEQUFVQSxDQUFDLEdBQUc7SUFDbEVnWCxVQUFVO0lBQ1ZDLFFBQVE7QUFDVixHQUFHYixhQUFZO0FBRWYsSUFBSWMsbUJBQW1CbFYsT0FBT0MsY0FBYyxFQUN4Q2tWLHNCQUFzQm5WLE9BQU9tVixtQkFBbUIsRUFDaERDLHdCQUF3QnBWLE9BQU9xVixxQkFBcUIsRUFDcERBLHdCQUF3QkQsMEJBQTBCL1IsWUFBWTtJQUNoRSxPQUFPLEVBQUU7QUFDWCxJQUFJK1IsdUJBQ0FFLDJCQUEyQnRWLE9BQU9zVix3QkFBd0IsRUFDMURDLGlCQUFpQnZWLE9BQU91VixjQUFjLEVBQ3RDQyxrQkFBa0J4VixPQUFPYixTQUFTO0FBQ3RDLElBQUlzVyxpQkFBaUIxUixNQUFNNUUsU0FBUztBQUdwQyxTQUFTdVcscUJBQXFCQyxlQUFlLEVBQUVDLGVBQWUsRUFBRUMsU0FBUztJQUN2RSxJQUFJLE9BQU9ELG9CQUFvQixVQUFVO1FBQ3ZDLDRDQUE0QztRQUU1QyxJQUFJRSxxQkFBcUJQLGVBQWVLO1FBRXhDLElBQUlFLHNCQUFzQkEsdUJBQXVCTixpQkFBaUI7WUFDaEVFLHFCQUFxQkMsaUJBQWlCRyxvQkFBb0JEO1FBQzVEO1FBRUEsSUFBSTFVLE9BQU9zVSxlQUFlclIsTUFBTSxDQUFDK1Esb0JBQW9CUyxrQkFDckQsYUFBYTtRQUNiUCxzQkFBc0JPO1FBRXRCLElBQUlHLGdCQUFnQmhCLFlBQVksQ0FBQ1ksZ0JBQWdCWCxRQUFRLENBQUMsSUFBSVg7UUFFOUQsSUFBSTJCLGdCQUFnQmpCLFlBQVksQ0FBQ2EsZ0JBQWdCWixRQUFRLENBQUMsSUFBSVg7UUFFOUQsSUFBSTNWLElBQUl5QyxLQUFLdkMsTUFBTTtRQUNuQixJQUFJZ0IsYUFBYSxLQUFLO1FBQ3RCLElBQUlNLE1BQU0sS0FBSztRQUVmLHVDQUF1QztRQUN2QyxNQUFPeEIsSUFBSztZQUNWd0IsTUFBTWlCLElBQUksQ0FBQ3pDLEVBQUU7WUFFYixJQUNBLGFBQWE7WUFDYixDQUFDaVcsYUFBYSxDQUFDelUsSUFBSSxJQUFJLENBQUUyVixDQUFBQSxhQUFhQSxTQUFTLENBQUMzVixJQUFJLEtBQUssQ0FBRThWLENBQUFBLGlCQUFpQkEsYUFBYSxDQUFDOVYsSUFBSSxLQUM5RixhQUFhO1lBQ2IsQ0FBRTZWLENBQUFBLGlCQUFpQkEsYUFBYSxDQUFDN1YsSUFBSSxHQUFHO2dCQUN0Q04sYUFBYTBWLHlCQUF5Qk0saUJBQWlCMVY7Z0JBRXZELElBQUlOLFlBQVk7b0JBQ2QsSUFBSTt3QkFDRiwyQ0FBMkM7d0JBQzNDc1YsaUJBQWlCUyxpQkFBaUJ6VixLQUFLTjtvQkFDekMsRUFBRSxPQUFPd1MsR0FBRztvQkFDVixpQkFBaUIsR0FDbkI7Z0JBQ0Y7WUFDRjtRQUNGO1FBRUEsT0FBT3VEO0lBQ1Q7SUFFQSxPQUFPQTtBQUNUO0FBRUEsR0FBRztBQUNILFNBQVNNLHdCQUF3QkMsRUFBRTtJQUNqQyxPQUFPLENBQUMsQ0FBRUEsQ0FBQUEsTUFBTUEsR0FBRy9XLFNBQVMsSUFBSStXLEdBQUcvVyxTQUFTLENBQUNpRCxnQkFBZ0I7QUFDL0Q7QUFFQSxHQUFHO0FBQ0gsNkNBQTZDO0FBQzdDLElBQUkrVCxPQUFRLFNBQVVDLEVBQUU7SUFDdEIsSUFBSUMsU0FBUztJQUViLE9BQU87UUFDTCxJQUFJLENBQUNBLFFBQVE7WUFDWEEsU0FBUztZQUNURCxHQUFHalMsS0FBSyxDQUFDZCxXQUFXOUM7UUFDdEI7SUFDRjtBQUNGO0FBRUEsR0FBRztBQUVILElBQUkrViw2QkFBZTVZLG9EQUFhQTtBQUVoQyxJQUFJNlksZ0JBQWdCRCxhQUFhRSxRQUFRO0FBRXpDOztDQUVDLEdBRUQsSUFBSUMsZ0JBQWdCLFNBQVVDLFVBQVU7SUFDdEMvVixTQUFTOFYsZUFBZUM7SUFFeEIsU0FBU0QsY0FBYzlXLEtBQUs7UUFDMUJQLGVBQWUsSUFBSSxFQUFFcVg7UUFFckIsSUFBSXhTLFFBQVE1QywwQkFBMEIsSUFBSSxFQUFFcVYsV0FBV2hXLElBQUksQ0FBQyxJQUFJLEVBQUVmO1FBRWxFc0UsTUFBTTBTLFVBQVUsR0FBRzFZLHVEQUFPQSxDQUFDZ0csTUFBTTBTLFVBQVUsQ0FBQ0MsSUFBSSxDQUFDM1M7UUFDakRBLE1BQU00UyxXQUFXLEdBQUc1UyxNQUFNNFMsV0FBVyxDQUFDRCxJQUFJLENBQUMzUztRQUMzQyxPQUFPQTtJQUNUO0lBRUF3UyxjQUFjdFgsU0FBUyxDQUFDOFYsTUFBTSxHQUFHLFNBQVNBO1FBQ3hDLElBQUksQ0FBQyxJQUFJLENBQUN0VixLQUFLLENBQUNtWCxRQUFRLEVBQUUsT0FBTztRQUVqQyxxQkFBT3RaLDBEQUFtQixDQUN4QjhZLGFBQWFFLFFBQVEsRUFDckIsTUFDQSxJQUFJLENBQUNLLFdBQVc7SUFFcEI7SUFFQUosY0FBY3RYLFNBQVMsQ0FBQzBYLFdBQVcsR0FBRyxTQUFTQSxZQUFZRSxVQUFVO1FBQ25FLElBQUloUixVQUFVLElBQUksQ0FBQzRRLFVBQVUsQ0FBQyxJQUFJLENBQUNoWCxLQUFLLENBQUNrVSxLQUFLLEVBQUVrRDtRQUVoRCxxQkFBT3ZaLDBEQUFtQixDQUN4QjhZLGFBQWFVLFFBQVEsRUFDckI7WUFBRWpXLE9BQU9nRjtRQUFRLEdBQ2pCLElBQUksQ0FBQ3BHLEtBQUssQ0FBQ21YLFFBQVE7SUFFdkI7SUFFQTs7O0dBR0MsR0FHREwsY0FBY3RYLFNBQVMsQ0FBQzhYLFFBQVEsR0FBRyxTQUFTQSxTQUFTcEQsS0FBSyxFQUFFa0QsVUFBVTtRQUNwRSxJQUFJbFYsV0FBV2dTLFFBQVE7WUFDckIsSUFBSXFELGNBQWNyRCxNQUFNa0Q7WUFFeEIsSUFBSS9VLEtBQXlCLElBQWlCa1YsQ0FBQUEsZ0JBQWdCLFFBQVFuVCxNQUFNd04sT0FBTyxDQUFDMkYsZ0JBQWdCLENBQUMsT0FBT0EsZ0JBQWdCLGNBQWMsY0FBY3BZLFFBQVFvWSxZQUFXLE1BQU8sUUFBTyxHQUFJO2dCQUMzTCxNQUFNLElBQUl2VCxzQkFBc0I7WUFDbEM7WUFFQSxPQUFPdVQ7UUFDVDtRQUVBLElBQUlyRCxVQUFVLFFBQVE5UCxNQUFNd04sT0FBTyxDQUFDc0MsVUFBVSxDQUFDLE9BQU9BLFVBQVUsY0FBYyxjQUFjL1UsUUFBUStVLE1BQUssTUFBTyxVQUFVO1lBQ3hILE1BQU0sSUFBSWxRLHNCQUFzQjtRQUNsQztRQUVBLE9BQU90RCxTQUFTLENBQUMsR0FBRzBXLFlBQVlsRDtJQUNsQztJQUVBNEMsY0FBY3RYLFNBQVMsQ0FBQ3dYLFVBQVUsR0FBRyxTQUFTQSxXQUFXOUMsS0FBSyxFQUFFa0QsVUFBVTtRQUN4RSxPQUFPLElBQUksQ0FBQ0UsUUFBUSxDQUFDcEQsT0FBT2tEO0lBQzlCO0lBRUEsT0FBT047QUFDVCxFQUFFOVksNENBQVNBO0FBRVgsR0FBRztBQUVILElBQUl3WixnQkFBZ0I7QUFFcEIsSUFBSUMsbUJBQW1CO0lBQ3JCLFNBQVNBO1FBQ1BoWSxlQUFlLElBQUksRUFBRWdZO1FBRXJCLDZEQUE2RCxHQUM3RCxJQUFJLENBQUNDLFdBQVcsR0FBR3RKLFdBQVdELE1BQU07UUFDcEMsSUFBSSxDQUFDek8sUUFBUSxHQUFHLElBQUksQ0FBQ2dZLFdBQVcsQ0FBQ3JQLEtBQUs7UUFDdEMsSUFBSSxDQUFDa0UsTUFBTSxHQUFHO0lBQ2hCO0lBRUE7OztHQUdDLEdBR0RrTCxpQkFBaUJqWSxTQUFTLENBQUNtWSxJQUFJLEdBQUcsU0FBU0E7UUFDekMsSUFBSSxDQUFDLElBQUksQ0FBQ3BMLE1BQU0sRUFBRTtZQUNoQixtREFBbUQsR0FDbkQsSUFBSXhELFFBQVEsSUFBSSxDQUFDMk8sV0FBVyxDQUFDNUksTUFBTSxDQUFDck4sT0FBTyxDQUFDLElBQUksQ0FBQy9CLFFBQVE7WUFDekQsSUFBSSxDQUFDZ1ksV0FBVyxDQUFDNUksTUFBTSxDQUFDOEksTUFBTSxDQUFDN08sT0FBTztZQUN0QyxJQUFJLENBQUN3RCxNQUFNLEdBQUc7UUFDaEI7SUFDRjtJQUVBa0wsaUJBQWlCalksU0FBUyxDQUFDcVksYUFBYSxHQUFHLFNBQVNBLGNBQWNWLFFBQVE7UUFDeEUsSUFBSSxJQUFJLENBQUM1SyxNQUFNLEVBQUU7WUFDZixNQUFNLElBQUl2SSxzQkFBc0I7UUFDbEM7UUFFQSxxQkFBT25HLDBEQUFtQixDQUN4QmlhLG1CQUNBO1lBQUV0UCxPQUFPLElBQUksQ0FBQzlJLFFBQVE7UUFBQyxHQUN2QnlYO0lBRUo7SUFFQU0saUJBQWlCalksU0FBUyxDQUFDdVksWUFBWSxHQUFHLFNBQVNBO1FBQ2pELElBQUksQ0FBQ0osSUFBSTtRQUNULE9BQU8sSUFBSSxDQUFDalksUUFBUSxDQUFDZ04sTUFBTTtJQUM3QjtJQUVBK0ssaUJBQWlCalksU0FBUyxDQUFDd1ksZUFBZSxHQUFHLFNBQVNBO1FBQ3BELElBQUksQ0FBQ0wsSUFBSTtRQUNULE9BQU8sSUFBSSxDQUFDalksUUFBUSxDQUFDK1EsZUFBZTtJQUN0QztJQUVBZ0gsaUJBQWlCalksU0FBUyxDQUFDeVksd0JBQXdCLEdBQUcsU0FBU0EseUJBQXlCQyxjQUFjO1FBQ3BHLElBQUk1VCxRQUFRLElBQUk7UUFFaEIsSUFBSXJCLFlBQVk7WUFDZCxNQUFNLElBQUllLHNCQUFzQjtRQUNsQztRQUVBLHFFQUFxRSxHQUNyRSxJQUFJdEUsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFFNUIsSUFBSXlZLG1CQUFtQjtRQUV2QixJQUFJQyxhQUFhcFYsaUJBQWlCO1FBRWxDLElBQUlxVixjQUFjLElBQUk5Wix5REFBZ0IsQ0FBQztZQUNyQ2dhLFdBQVcsU0FBU0Msa0JBQWtCakgsS0FBSyxFQUFFLFlBQVksR0FBRXhLLENBQUMsRUFBRTBSLFFBQVE7Z0JBQ3BFLElBQUlqSyxPQUFPOU8sU0FBUzhPLElBQUk7Z0JBRXhCLElBQUlrSyxPQUFPO2dCQUVYLHdDQUF3QyxHQUN4QyxNQUFPUCxtQkFBbUIzSixLQUFLdlAsTUFBTSxFQUFFa1osb0JBQW9CLEVBQUc7b0JBQzVELElBQUk1UCxNQUFNaUcsSUFBSSxDQUFDMkosaUJBQWlCO29CQUNoQ08sUUFBUW5RLElBQUltRSxNQUFNLENBQUMwTDtnQkFDckI7Z0JBRUEsbURBQW1ELEdBQ25EMVksU0FBU3VRLFdBQVc7Z0JBRXBCLElBQUkwSSxlQUFlcEgsTUFBTVQsUUFBUTtnQkFFakMscUhBQXFILEdBQ3JILElBQUkwRyxjQUFjclYsSUFBSSxDQUFDd1csZUFBZTtvQkFDcEMsSUFBSUMsa0JBQWtCRCxhQUFhbFgsT0FBTyxDQUFDO29CQUUzQyxJQUFJLENBQUN2QyxJQUFJLENBQUN5WixhQUFhblQsS0FBSyxDQUFDLEdBQUdvVCxrQkFBa0IsS0FBS0YsT0FBT0MsYUFBYW5ULEtBQUssQ0FBQ29ULGtCQUFrQjtnQkFDckcsT0FBTyxJQUFJLENBQUMxWixJQUFJLENBQUN3WixPQUFPQztnQkFFeEJGO1lBQ0Y7UUFDRjtRQUVBUCxlQUFlVyxFQUFFLENBQUMsT0FBTztZQUN2QixPQUFPdlUsTUFBTXFULElBQUk7UUFDbkI7UUFFQU8sZUFBZVcsRUFBRSxDQUFDLFNBQVMsU0FBVTFQLEdBQUc7WUFDdEM3RSxNQUFNcVQsSUFBSTtZQUVWLDRDQUE0QztZQUM1Q1UsWUFBWVMsSUFBSSxDQUFDLFNBQVMzUDtRQUM1QjtRQUVBLE9BQU8rTyxlQUFlYSxJQUFJLENBQUNWO0lBQzdCO0lBRUEsT0FBT1o7QUFDVDtBQUVBLEdBQUc7QUFFSCxJQUFJdUIsa0NBQW9CamIsb0RBQWFBO0FBQ3JDLElBQUlrYixxQkFBcUJELGtCQUFrQm5DLFFBQVE7QUFFbkQsSUFBSWlCLG9CQUFvQixTQUFVZixVQUFVO0lBQzFDL1YsU0FBUzhXLG1CQUFtQmY7SUFFNUIsU0FBU2Usa0JBQWtCOVgsS0FBSztRQUM5QlAsZUFBZSxJQUFJLEVBQUVxWTtRQUVyQixJQUFJeFQsUUFBUTVDLDBCQUEwQixJQUFJLEVBQUVxVixXQUFXaFcsSUFBSSxDQUFDLElBQUksRUFBRWY7UUFFbEVzRSxNQUFNMFMsVUFBVSxHQUFHMVksdURBQU9BLENBQUNnRyxNQUFNMFMsVUFBVTtRQUMzQyxPQUFPMVM7SUFDVDtJQUVBd1Qsa0JBQWtCdFksU0FBUyxDQUFDd1gsVUFBVSxHQUFHLFNBQVNBLFdBQVd4TyxLQUFLLEVBQUV6SSxNQUFNO1FBQ3hFLElBQUl5SSxPQUFPO1lBQ1QsT0FBT0E7UUFDVCxPQUFPLElBQUl6SSxRQUFRO1lBQ2pCLE9BQU8sSUFBSXFPLFdBQVdyTztRQUN4QixPQUFPO1lBQ0wsTUFBTSxJQUFJaUUsc0JBQXNCO1FBQ2xDO0lBQ0Y7SUFFQThULGtCQUFrQnRZLFNBQVMsQ0FBQzhWLE1BQU0sR0FBRyxTQUFTQTtRQUM1QyxJQUFJdkssU0FBUyxJQUFJLENBQUMvSyxLQUFLLEVBQ25CbVgsV0FBV3BNLE9BQU9vTSxRQUFRLEVBQzFCM08sUUFBUXVDLE9BQU92QyxLQUFLLEVBQ3BCekksU0FBU2dMLE9BQU9oTCxNQUFNO1FBRzFCLHFCQUFPbEMsMERBQW1CLENBQ3hCbWIsa0JBQWtCM0IsUUFBUSxFQUMxQjtZQUFFalcsT0FBTyxJQUFJLENBQUM0VixVQUFVLENBQUN4TyxPQUFPekk7UUFBUSxHQUN4Q3NDLEtBQXlCLEdBQWV4RSxxREFBYyxDQUFDc2IsSUFBSSxDQUFDaEMsWUFBWUEsQ0FBUUE7SUFFcEY7SUFFQSxPQUFPVztBQUNULEVBQUU5Wiw0Q0FBU0E7QUFuM0RYLEtBbzNEcUMsR0FBRzhaLGtCQUFrQmhELFNBQVMsR0FBRztJQUNwRXRNLE9BQU9oSywyREFBbUIsQ0FBQztRQUFDQSw0REFBb0IsQ0FBQzRQO1FBQWE1UCw0REFBb0IsQ0FBQ2laO0tBQWtCO0lBRXJHMVgsUUFBUXZCLHVEQUFlLENBQUM7UUFDdEI0TCxhQUFhNUwsd0RBQWMsQ0FBQ2diLFVBQVU7SUFDeEM7QUFDRixJQUFJLENBQU07QUFFVixHQUFHO0FBRUgsSUFBSUMsY0FBYyxDQUFDO0FBRW5CLDZDQUE2QyxHQUM3QyxTQUFTQyxXQUFXQyxlQUFlLEVBQUVDLFlBQVksRUFBRUMsaUJBQWlCO0lBQ2xFLElBQUl2WCxjQUFjLE9BQU9zWCxpQkFBaUIsV0FBVyxPQUFPdkYsT0FBT3VGO0lBRW5FOzs7R0FHQyxHQUNELElBQUlFLEtBQUssQ0FBQ0wsV0FBVyxDQUFDblgsWUFBWSxJQUFJLEtBQUs7SUFDM0NtWCxXQUFXLENBQUNuWCxZQUFZLEdBQUd3WDtJQUUzQixJQUFJNVUsY0FBYzVDLGNBQWMsTUFBTXFYLGdCQUFnQm5HLFlBQVksQ0FBQ2xSLGNBQWN3WDtJQUVqRixPQUFPRCxvQkFBb0JBLG9CQUFvQixNQUFNM1UsY0FBY0E7QUFDckU7QUFFQSxhQUFhO0FBRWIsSUFBSTZVLGtCQUFrQixTQUFVaEQsVUFBVTtJQUN4Qy9WLFNBQVMrWSxpQkFBaUJoRDtJQUUxQixTQUFTZ0Q7UUFDUHRhLGVBQWUsSUFBSSxFQUFFc2E7UUFFckIsSUFBSXpWLFFBQVE1QywwQkFBMEIsSUFBSSxFQUFFcVYsV0FBV2hXLElBQUksQ0FBQyxJQUFJO1FBRWhFdUQsTUFBTW9HLEtBQUssR0FBRyxDQUFDO1FBRWZwRyxNQUFNMFYsV0FBVyxHQUFHMVYsTUFBTTBWLFdBQVcsQ0FBQy9DLElBQUksQ0FBQzNTO1FBQzNDQSxNQUFNNFMsV0FBVyxHQUFHNVMsTUFBTTRTLFdBQVcsQ0FBQ0QsSUFBSSxDQUFDM1M7UUFFM0MsSUFBSWpDLElBQXlCLEVBQWM7WUFDekNpQyxNQUFNMlYsWUFBWSxHQUFHekQsS0FBSyxTQUFVbFUsV0FBVztnQkFDN0MsT0FDRSxzQ0FBc0M7Z0JBQ3RDeVAsUUFBUUMsSUFBSSxDQUFDLHdMQUF3TDFQLGNBQWM7WUFFdk47WUFFQWdDLE1BQU00Viw4QkFBOEIsR0FBRzFELEtBQUssU0FBVWpXLEdBQUcsRUFBRStCLFdBQVc7Z0JBQ3BFLE9BQ0Usc0NBQXNDO2dCQUN0Q3lQLFFBQVFDLElBQUksQ0FBQyw0UEFBNFB6UixNQUFNLHFCQUFxQitCLGNBQWMsTUFBTSxRQUFRLElBQUlxQyxRQUFRd1YsS0FBSztZQUVyVjtZQUVBN1YsTUFBTThWLG9DQUFvQyxHQUFHNUQsS0FBSyxTQUFValcsR0FBRyxFQUFFK0IsV0FBVztnQkFDMUUsT0FDRSxzQ0FBc0M7Z0JBQ3RDeVAsUUFBUUMsSUFBSSxDQUFDLDZFQUE2RXpSLE1BQU0sb0RBQW9EK0IsY0FBYyxTQUFTLHNIQUFzSCxnTkFBaU4scUJBQW9CL0IsTUFBTSwyQ0FBMkNBLE1BQU0sb0JBQW1CO1lBRXBsQjtRQUNGO1FBQ0EsT0FBTytEO0lBQ1Q7SUFFQXlWLGdCQUFnQnZhLFNBQVMsQ0FBQzhWLE1BQU0sR0FBRyxTQUFTQTtRQUMxQyxxQkFBT3pYLDBEQUFtQixDQUN4Qm9iLG9CQUNBLE1BQ0EsSUFBSSxDQUFDZSxXQUFXO0lBRXBCO0lBRUFELGdCQUFnQnZhLFNBQVMsQ0FBQ3dhLFdBQVcsR0FBRyxTQUFTQTtRQUMvQyxJQUFJbkosYUFBYWpRLFVBQVUzQixNQUFNLEdBQUcsS0FBSzJCLFNBQVMsQ0FBQyxFQUFFLEtBQUs4QyxZQUFZOUMsU0FBUyxDQUFDLEVBQUUsR0FBR3dOLFdBQVdELE1BQU07UUFFdEcsSUFBSSxDQUFDMEMsVUFBVSxHQUFHQTtRQUVsQixxRkFBcUY7UUFDckYsSUFBSSxJQUFJLENBQUM3USxLQUFLLENBQUNxYSxrQkFBa0IsQ0FBQ0MsY0FBYyxDQUFDakgsUUFBUSxFQUFFLE9BQU8sSUFBSSxDQUFDNkQsV0FBVztRQUVsRixxQkFBT3JaLDBEQUFtQixDQUN4QitZLGVBQ0EsTUFDQSxJQUFJLENBQUNNLFdBQVc7SUFFcEI7SUFFQTZDLGdCQUFnQnZhLFNBQVMsQ0FBQzBYLFdBQVcsR0FBRyxTQUFTQSxZQUFZaEQsS0FBSztRQUNoRSxJQUFJcUcsd0JBQXdCLElBQUksQ0FBQ3ZhLEtBQUssQ0FBQ3FhLGtCQUFrQixFQUNyREMsaUJBQWlCQyxzQkFBc0JELGNBQWMsRUFDckR0RyxlQUFldUcsc0JBQXNCdkcsWUFBWSxFQUNqRDFSLGNBQWNpWSxzQkFBc0JqWSxXQUFXLEVBQy9Da1kscUJBQXFCRCxzQkFBc0JDLGtCQUFrQixFQUM3RDdYLG9CQUFvQjRYLHNCQUFzQjVYLGlCQUFpQixFQUMzRDVDLFNBQVN3YSxzQkFBc0J4YSxNQUFNO1FBR3pDLElBQUkwYSxxQkFBcUIsS0FBSztRQUM5QixJQUFJSCxlQUFlakgsUUFBUSxFQUFFO1lBQzNCb0gscUJBQXFCLElBQUksQ0FBQ25ILHVCQUF1QixDQUFDclIsY0FBYyxJQUFJLENBQUNqQyxLQUFLO1FBQzVFLE9BQU87WUFDTHlhLHFCQUFxQixJQUFJLENBQUNuSCx1QkFBdUIsQ0FBQ1EsZUFBZSxJQUFJLENBQUM5VCxLQUFLLEVBQUVrVSxPQUFPRixpQkFBaUIvUixjQUFjLElBQUksQ0FBQ2pDLEtBQUs7UUFDL0g7UUFFQSxJQUFJMGEscUJBQXFCLElBQUksQ0FBQzFhLEtBQUssQ0FBQzJhLEVBQUUsSUFBSSxJQUFJLENBQUNqUSxLQUFLLENBQUNpUSxFQUFFLElBQUk1YTtRQUMzRCxJQUFJNmEsY0FBY3RHLE1BQU1vRztRQUV4QixJQUFJRyxrQkFBa0IsQ0FBQztRQUN2QixJQUFJQyxnQkFBZ0JwYSxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUNWLEtBQUssRUFBRSxJQUFJLENBQUMwSyxLQUFLO1FBRXZELElBQUluSyxNQUFNLEtBQUs7UUFDZix3Q0FBd0M7UUFDeEMsSUFBS0EsT0FBT3VhLGNBQWU7WUFDekIsSUFBSXpZLEtBQXlCLElBQWdCOUIsUUFBUSxjQUFjcWEsYUFBYTtnQkFDOUUsSUFBSSxDQUFDWCxZQUFZLENBQUMzWDtZQUNwQjtZQUVBLElBQUkvQixRQUFRLHdCQUF3QkEsUUFBUSxNQUFNO2dCQUNoRDtZQUNGLE9BQU8sSUFBSUEsUUFBUSxnQkFBZ0JzYSxnQkFBZ0JFLEdBQUcsR0FBR0QsYUFBYSxDQUFDdmEsSUFBSTtpQkFBTSxJQUFJQSxRQUFRLGVBQWVzYSxnQkFBZ0JGLEVBQUUsR0FBR0csYUFBYSxDQUFDdmEsSUFBSTtpQkFBTSxJQUFJLENBQUNxYSxlQUFlbmMsa0VBQVNBLENBQUM4QixNQUFNO2dCQUMzTCw0REFBNEQ7Z0JBQzVEc2EsZUFBZSxDQUFDdGEsSUFBSSxHQUFHdWEsYUFBYSxDQUFDdmEsSUFBSTtZQUMzQztRQUNGO1FBRUEsSUFBSSxJQUFJLENBQUNQLEtBQUssQ0FBQ2diLEtBQUssSUFBSSxJQUFJLENBQUN0USxLQUFLLENBQUNzUSxLQUFLLEVBQUU7WUFDeENILGdCQUFnQkcsS0FBSyxHQUFHdGEsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDZ0ssS0FBSyxDQUFDc1EsS0FBSyxFQUFFLElBQUksQ0FBQ2hiLEtBQUssQ0FBQ2diLEtBQUs7UUFDekU7UUFFQUgsZ0JBQWdCaEgsU0FBUyxHQUFHelAsTUFBTTVFLFNBQVMsQ0FBQ2lGLE1BQU0sQ0FBQytWLG9CQUFvQjdYLG1CQUFtQjhYLHVCQUF1QjlYLG9CQUFvQjhYLHFCQUFxQixNQUFNLElBQUksQ0FBQ3phLEtBQUssQ0FBQzZULFNBQVMsRUFBRSxJQUFJLENBQUNuSixLQUFLLENBQUNtSixTQUFTLEVBQUVqSixNQUFNLENBQUNDLFNBQVN0RyxJQUFJLENBQUM7UUFFak8scUJBQU90RyxvREFBYUEsQ0FBQ3ljLG9CQUFvQkc7SUFDM0M7SUFFQWQsZ0JBQWdCdmEsU0FBUyxDQUFDeWIscUJBQXFCLEdBQUcsU0FBU0Esc0JBQXNCL0csS0FBSyxFQUFFbFUsS0FBSyxFQUFFMEssS0FBSztRQUNsRyxJQUFJd1EsU0FBUyxJQUFJO1FBRWpCLElBQUk5VSxVQUFVMUYsU0FBUyxDQUFDLEdBQUdWLE9BQU87WUFBRWtVLE9BQU9BO1FBQU07UUFFakQsSUFBSSxDQUFDeEosTUFBTXpMLE1BQU0sRUFBRSxPQUFPbUg7UUFFMUIsSUFBSSxDQUFDc0UsS0FBSyxHQUFHLENBQUM7UUFFZEEsTUFBTTdHLE9BQU8sQ0FBQyxTQUFVc1gsT0FBTztZQUM3QixJQUFJQyxrQkFBa0JEO1lBQ3RCLElBQUlFLGVBQWU7WUFDbkIsSUFBSUMsT0FBTyxLQUFLO1lBQ2hCLElBQUkvYSxNQUFNLEtBQUs7WUFFZixJQUFJMkIsV0FBV2taLGtCQUFrQjtnQkFDL0IsYUFBYTtnQkFDYkEsa0JBQWtCQSxnQkFBZ0JoVjtnQkFDbENpVixlQUFlO1lBQ2pCO1lBRUEsK0JBQStCLEdBQy9CLGFBQWE7WUFDYixJQUFLOWEsT0FBTzZhLGdCQUFpQjtnQkFDM0JFLE9BQU9GLGVBQWUsQ0FBQzdhLElBQUk7Z0JBRTNCLElBQUksQ0FBQzhhLGNBQWM7b0JBQ2pCLElBQUluWixXQUFXb1osU0FBUyxDQUFDaEYsd0JBQXdCZ0YsU0FBUyxDQUFDNVksa0JBQWtCNFksT0FBTzt3QkFDbEYsSUFBSWpaLElBQXlCLEVBQWM7NEJBQ3pDNlksT0FBT2hCLDhCQUE4QixDQUFDM1osS0FBS1AsTUFBTXFhLGtCQUFrQixDQUFDL1gsV0FBVzt3QkFDakY7d0JBRUFnWixPQUFPQSxLQUFLbFY7d0JBRVosSUFBSS9ELEtBQXlCLGtCQUFnQnhFLDJEQUFvQixDQUFDeWQsT0FBTzs0QkFDdkVKLE9BQU9kLG9DQUFvQyxDQUFDN1osS0FBS1AsTUFBTXFhLGtCQUFrQixDQUFDL1gsV0FBVzt3QkFDdkY7b0JBQ0Y7Z0JBQ0Y7Z0JBRUE0WSxPQUFPeFEsS0FBSyxDQUFDbkssSUFBSSxHQUFHK2E7Z0JBQ3BCbFYsT0FBTyxDQUFDN0YsSUFBSSxHQUFHK2E7WUFDakI7UUFDQSxpQkFBaUIsR0FDbkI7UUFFQSxPQUFPbFY7SUFDVDtJQUVBMlQsZ0JBQWdCdmEsU0FBUyxDQUFDOFQsdUJBQXVCLEdBQUcsU0FBU0Esd0JBQXdCWSxLQUFLLEVBQUVsVSxLQUFLO1FBQy9GLElBQUl3Yix5QkFBeUJ4YixNQUFNcWEsa0JBQWtCLEVBQ2pEM1AsUUFBUThRLHVCQUF1QjlRLEtBQUssRUFDcEM0UCxpQkFBaUJrQix1QkFBdUJsQixjQUFjLEVBQ3REbUIscUJBQXFCRCx1QkFBdUJDLGtCQUFrQjtRQUVsRSxnRkFBZ0Y7UUFDaEYsd0RBQXdEO1FBRXhELElBQUluQixlQUFlakgsUUFBUSxJQUFJLENBQUMzSSxNQUFNekwsTUFBTSxFQUFFO1lBQzVDLE9BQU9xYixlQUFlaEgsdUJBQXVCLENBQUNyUixjQUFjLElBQUksQ0FBQzRPLFVBQVU7UUFDN0U7UUFFQSxJQUFJZ0QsWUFBWXlHLGVBQWVoSCx1QkFBdUIsQ0FBQyxJQUFJLENBQUMySCxxQkFBcUIsQ0FBQy9HLE9BQU9sVSxPQUFPMEssUUFBUSxJQUFJLENBQUNtRyxVQUFVO1FBRXZILElBQUl4TyxLQUF5QixJQUFnQm9aLG9CQUFvQkEsbUJBQW1CNUg7UUFFcEYsT0FBT0E7SUFDVDtJQUVBLE9BQU9rRztBQUNULEVBQUUvYiw0Q0FBU0E7QUFFWCxTQUFTMGQsc0JBQXNCM2IsTUFBTSxFQUFFcVMsT0FBTyxFQUFFL0ssS0FBSztJQUNuRCxJQUFJc1UscUJBQXFCalosa0JBQWtCM0M7SUFDM0MsSUFBSTZiLFVBQVUsQ0FBQ3RILE1BQU12VTtJQUVyQixJQUFJOGIsdUJBQXVCekosUUFBUTlQLFdBQVcsRUFDMUNBLGNBQWN1Wix5QkFBeUJuWSxZQUFZOFEsb0JBQW9CelUsVUFBVThiLHNCQUNqRkMsdUJBQXVCMUosUUFBUWxOLFdBQVcsRUFDMUNBLGNBQWM0Vyx5QkFBeUJwWSxZQUFZZ1csV0FBV3RHLGdCQUFnQmhCLFFBQVE5UCxXQUFXLEVBQUU4UCxRQUFReUgsaUJBQWlCLElBQUlpQyxzQkFDaElDLHdCQUF3QjNKLFFBQVE0SixlQUFlLEVBQy9DQSxrQkFBa0JELDBCQUEwQnJZLFlBQVlxVyxrQkFBa0JnQyx1QkFDMUVFLGlCQUFpQjdKLFFBQVExSCxLQUFLLEVBQzlCQSxRQUFRdVIsbUJBQW1CdlksWUFBWTNCLGNBQWNrYTtJQUd6RCxJQUFJdFosb0JBQW9CeVAsUUFBUTlQLFdBQVcsSUFBSThQLFFBQVFsTixXQUFXLEdBQUdtUCxPQUFPakMsUUFBUTlQLFdBQVcsSUFBSSxNQUFNOFAsUUFBUWxOLFdBQVcsR0FBR2tOLFFBQVFsTixXQUFXLElBQUlBO0lBRXRKLGlFQUFpRTtJQUNqRSxJQUFJZ1gsYUFDSixhQUFhO0lBQ2JQLHNCQUFzQjViLE9BQU8ySyxLQUFLLEdBQUd0RyxNQUFNNUUsU0FBUyxDQUFDaUYsTUFBTSxDQUFDMUUsT0FBTzJLLEtBQUssRUFBRUEsT0FBT0UsTUFBTSxDQUFDQyxXQUFXSDtJQUVuRyxJQUFJNFAsaUJBQWlCLElBQUlsSCxlQUFldUkscUJBQ3hDLGFBQWE7SUFDYjViLE9BQU91YSxjQUFjLENBQUNqVCxLQUFLLENBQUM1QyxNQUFNLENBQUM0QyxTQUFTQSxPQUFPNlUsWUFBWXZaO0lBRS9EOzs7R0FHQyxHQUNELElBQUl3Wix5QkFBeUIsS0FBSztJQUNsQyxJQUFJQyxhQUFhLFNBQVNBLFdBQVdwYyxLQUFLLEVBQUUrYSxHQUFHO1FBQzdDLHFCQUFPbGQsMERBQW1CLENBQUNtZSxpQkFBaUJ0YixTQUFTLENBQUMsR0FBR1YsT0FBTztZQUFFcWEsb0JBQW9COEI7WUFBd0JFLGNBQWN0QjtRQUFJO0lBQ2xJO0lBQ0FxQixXQUFXOVosV0FBVyxHQUFHQTtJQUN6QjZaLHVDQUF5QnRlLHVEQUFnQixDQUFDdWU7SUFDMUNELHVCQUF1QjdaLFdBQVcsR0FBR0E7SUFFckMsYUFBYTtJQUNiNlosdUJBQXVCelIsS0FBSyxHQUFHd1I7SUFDL0IsYUFBYTtJQUNiQyx1QkFBdUI3QixjQUFjLEdBQUdBO0lBRXhDLGFBQWE7SUFDYjZCLHVCQUF1QjNCLGtCQUFrQixHQUFHbUIscUJBQzVDdlgsTUFBTTVFLFNBQVMsQ0FBQ2lGLE1BQU0sQ0FBQzFFLE9BQU95YSxrQkFBa0IsRUFBRXphLE9BQU80QyxpQkFBaUIsSUFBSVo7SUFFOUUsYUFBYTtJQUNib2EsdUJBQXVCeFosaUJBQWlCLEdBQUdBO0lBRTNDLDJFQUEyRTtJQUMzRSxhQUFhO0lBQ2J3Wix1QkFBdUJwYyxNQUFNLEdBQUc0YixxQkFBcUI1YixPQUFPQSxNQUFNLEdBQUdBO0lBRXJFLGFBQWE7SUFDYm9jLHVCQUF1QkcsYUFBYSxHQUFHLFNBQVNBLGNBQWMvVCxHQUFHO1FBQy9ELElBQUlnVSxzQkFBc0JuSyxRQUFRbE4sV0FBVyxFQUN6Q3NYLGdCQUFnQmpiLHdCQUF3QjZRLFNBQVM7WUFBQztTQUFjO1FBR3BFLElBQUlxSyxpQkFBaUJGLHVCQUF1QkEsc0JBQXNCLE1BQU9qSSxDQUFBQSxNQUFNL0wsT0FBT0EsTUFBTThMLE9BQU9qUyxpQkFBaUJtRyxLQUFJO1FBRXhILElBQUltVSxhQUFhaGMsU0FBUyxDQUFDLEdBQUc4YixlQUFlO1lBQzNDOVIsT0FBT3dSO1lBQ1BoWCxhQUFhdVg7WUFDYlQsaUJBQWlCQTtRQUNuQjtRQUVBLE9BQU9OLHNCQUFzQm5ULEtBQUttVSxZQUFZclY7SUFDaEQ7SUFFQSxhQUFhO0lBQ2JoSCxPQUFPQyxjQUFjLENBQUM2Yix3QkFBd0IsZ0JBQWdCO1FBQzVEekwsS0FBSyxTQUFTQztZQUNaLE9BQU8sSUFBSSxDQUFDZ00sbUJBQW1CO1FBQ2pDO1FBQ0FDLEtBQUssU0FBU0MsT0FBT3ZkLEdBQUc7WUFDdEIsYUFBYTtZQUNiLElBQUksQ0FBQ3FkLG1CQUFtQixHQUFHaEIscUJBQXFCamQsMERBQUtBLENBQUNxQixPQUFPaVUsWUFBWSxFQUFFMVUsT0FBT0E7UUFDcEY7SUFDRjtJQUVBLElBQUkrQyxJQUF5QixFQUFjO1FBQ3pDLGFBQWE7UUFDYjhaLHVCQUF1QlYsa0JBQWtCLEdBQUcvSCx5QkFBeUJwUjtJQUN2RTtJQUVBLGFBQWE7SUFDYjZaLHVCQUF1QnJMLFFBQVEsR0FBRztRQUNoQyxPQUFPLE1BQU1xTCx1QkFBdUJ4WixpQkFBaUI7SUFDdkQ7SUFFQSxJQUFJaVosU0FBUztRQUNYN0YscUJBQXFCb0csd0JBQXdCcGMsUUFBUTtZQUNuRCwrQ0FBK0M7WUFDL0MySyxPQUFPO1lBQ1A0UCxnQkFBZ0I7WUFDaEJoWSxhQUFhO1lBQ2JrWSxvQkFBb0I7WUFDcEI3WCxtQkFBbUI7WUFDbkI1QyxRQUFRO1lBQ1J1YyxlQUFlO1FBQ2pCO0lBQ0Y7SUFFQSxPQUFPSDtBQUNUO0FBRUEsR0FBRztBQUNILG1EQUFtRDtBQUVuRCxJQUFJVyxjQUFjO0lBQUM7SUFBSztJQUFRO0lBQVc7SUFBUTtJQUFXO0lBQVM7SUFBUztJQUFLO0lBQVE7SUFBTztJQUFPO0lBQU87SUFBYztJQUFRO0lBQU07SUFBVTtJQUFVO0lBQVc7SUFBUTtJQUFRO0lBQU87SUFBWTtJQUFRO0lBQVk7SUFBTTtJQUFPO0lBQVc7SUFBTztJQUFVO0lBQU87SUFBTTtJQUFNO0lBQU07SUFBUztJQUFZO0lBQWM7SUFBVTtJQUFVO0lBQVE7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBUTtJQUFVO0lBQVU7SUFBTTtJQUFRO0lBQUs7SUFBVTtJQUFPO0lBQVM7SUFBTztJQUFPO0lBQVU7SUFBUztJQUFVO0lBQU07SUFBUTtJQUFRO0lBQU87SUFBUTtJQUFXO0lBQVE7SUFBWTtJQUFRO0lBQVM7SUFBTztJQUFZO0lBQVU7SUFBTTtJQUFZO0lBQVU7SUFBVTtJQUFLO0lBQVM7SUFBVztJQUFPO0lBQVk7SUFBSztJQUFNO0lBQU07SUFBUTtJQUFLO0lBQVE7SUFBVTtJQUFXO0lBQVU7SUFBUztJQUFVO0lBQVE7SUFBVTtJQUFTO0lBQU87SUFBVztJQUFPO0lBQVM7SUFBUztJQUFNO0lBQVk7SUFBUztJQUFNO0lBQVM7SUFBUTtJQUFTO0lBQU07SUFBUztJQUFLO0lBQU07SUFBTztJQUFTO0lBRXA4QixNQUFNO0lBQ047SUFBVTtJQUFZO0lBQVE7SUFBVztJQUFpQjtJQUFLO0lBQVM7SUFBUTtJQUFrQjtJQUFVO0lBQVE7SUFBUTtJQUFXO0lBQVc7SUFBWTtJQUFrQjtJQUFRO0lBQVE7SUFBTztJQUFRO0NBQVE7QUFFdk4sR0FBRztBQUVILElBQUlDLFNBQVMsU0FBU0EsT0FBT3hVLEdBQUc7SUFDOUIsT0FBTzJKLHFCQUFxQndKLHVCQUF1Qm5UO0FBQ3JEO0FBRUEseUNBQXlDO0FBQ3pDdVUsWUFBWWpaLE9BQU8sQ0FBQyxTQUFVbVosVUFBVTtJQUN0Q0QsTUFBTSxDQUFDQyxXQUFXLEdBQUdELE9BQU9DO0FBQzlCO0FBRUEsR0FBRztBQUVILElBQUlDLGNBQWM7SUFDaEIsU0FBU0EsWUFBWTVWLEtBQUssRUFBRW5DLFdBQVc7UUFDckN6RixlQUFlLElBQUksRUFBRXdkO1FBRXJCLElBQUksQ0FBQzVWLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNuQyxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ21PLFFBQVEsR0FBR0osY0FBYzVMLE9BQU90RjtRQUVyQyxJQUFJLENBQUNxTSxXQUFXRCxNQUFNLENBQUNrQyxLQUFLLENBQUNuTCxjQUFjO1lBQ3pDa0osV0FBV0QsTUFBTSxDQUFDbUMsY0FBYyxDQUFDcEwsYUFBYSxFQUFFO1FBQ2xEO0lBQ0Y7SUFFQStYLFlBQVl6ZCxTQUFTLENBQUMwZCxZQUFZLEdBQUcsU0FBU0EsYUFBYXZMLGdCQUFnQixFQUFFZCxVQUFVO1FBQ3JGLElBQUl0SixVQUFVbUssUUFBUSxJQUFJLENBQUNySyxLQUFLLEVBQUVzSyxrQkFBa0JkO1FBQ3BELElBQUk5TCxNQUFNcUMsZUFBZUcsU0FBUztRQUVsQ3NKLFdBQVdOLE1BQU0sQ0FBQyxJQUFJLENBQUNyTCxXQUFXLEVBQUVIO0lBQ3RDO0lBRUFrWSxZQUFZemQsU0FBUyxDQUFDMmQsWUFBWSxHQUFHLFNBQVNBLGFBQWF0TSxVQUFVO1FBQ25FLElBQUkzTCxjQUFjLElBQUksQ0FBQ0EsV0FBVztRQUVsQyxJQUFJMkwsV0FBV1IsS0FBSyxDQUFDbkwsY0FBYztZQUNqQzJMLFdBQVdMLE1BQU0sQ0FBQ3RMO1FBQ3BCO0lBQ0Y7SUFFQSxxREFBcUQ7SUFHckQrWCxZQUFZemQsU0FBUyxDQUFDNGQsWUFBWSxHQUFHLFNBQVNBLGFBQWF6TCxnQkFBZ0IsRUFBRWQsVUFBVTtRQUNyRixJQUFJLENBQUNzTSxZQUFZLENBQUN0TTtRQUNsQixJQUFJLENBQUNxTSxZQUFZLENBQUN2TCxrQkFBa0JkO0lBQ3RDO0lBRUEsT0FBT29NO0FBQ1Q7QUFFQSxHQUFHO0FBRUgsb0VBQW9FO0FBQ3BFLElBQUloYSxZQUFZO0lBQ2RDLE9BQU9tYSxhQUFhLEdBQUcsQ0FBQztBQUMxQjtBQUVBLFNBQVNDLGtCQUFrQjFlLE9BQU87SUFDaEMsSUFBSyxJQUFJdUYsT0FBT3ZELFVBQVUzQixNQUFNLEVBQUVKLGlCQUFpQnVGLE1BQU1ELE9BQU8sSUFBSUEsT0FBTyxJQUFJLElBQUlFLE9BQU8sR0FBR0EsT0FBT0YsTUFBTUUsT0FBUTtRQUNoSHhGLGNBQWMsQ0FBQ3dGLE9BQU8sRUFBRSxHQUFHekQsU0FBUyxDQUFDeUQsS0FBSztJQUM1QztJQUVBLElBQUlnRCxRQUFRdEMsSUFBSVAsS0FBSyxDQUFDZCxXQUFXO1FBQUM5RTtLQUFRLENBQUM2RixNQUFNLENBQUM1RjtJQUNsRCxJQUFJaUosS0FBSyxlQUFlMEssV0FBVytLLEtBQUtDLFNBQVMsQ0FBQ25XO0lBQ2xELElBQUkyVCxRQUFRLElBQUlpQyxZQUFZNVYsT0FBT1M7SUFFbkMsSUFBSTJWLHVCQUF1QixTQUFVQyxnQkFBZ0I7UUFDbkQxYyxTQUFTeWMsc0JBQXNCQztRQUUvQixTQUFTRCxxQkFBcUJ6ZCxLQUFLO1lBQ2pDUCxlQUFlLElBQUksRUFBRWdlO1lBRXJCLElBQUluWixRQUFRNUMsMEJBQTBCLElBQUksRUFBRWdjLGlCQUFpQjNjLElBQUksQ0FBQyxJQUFJLEVBQUVmO1lBRXhFLElBQUkyZCxvQkFBb0JyWixNQUFNL0UsV0FBVyxFQUNyQ3FlLGNBQWNELGtCQUFrQkMsV0FBVyxFQUMzQ2piLG9CQUFvQmdiLGtCQUFrQmhiLGlCQUFpQjtZQUczRCxJQUFJTSxZQUFZO2dCQUNkQyxPQUFPbWEsYUFBYSxDQUFDMWEsa0JBQWtCLEdBQUcsQ0FBQ08sT0FBT21hLGFBQWEsQ0FBQzFhLGtCQUFrQixJQUFJLEtBQUs7WUFDN0Y7WUFFQTs7OztPQUlDLEdBQ0QyQixNQUFNdVosS0FBSyxHQUFHO2dCQUNaRCxhQUFhQTtnQkFDYmpiLG1CQUFtQkE7WUFDckI7WUFDQSxPQUFPMkI7UUFDVDtRQUVBbVoscUJBQXFCamUsU0FBUyxDQUFDc2Usb0JBQW9CLEdBQUcsU0FBU0E7WUFDN0QsSUFBSTVhLE9BQU9tYSxhQUFhLENBQUMsSUFBSSxDQUFDUSxLQUFLLENBQUNsYixpQkFBaUIsQ0FBQyxFQUFFO2dCQUN0RE8sT0FBT21hLGFBQWEsQ0FBQyxJQUFJLENBQUNRLEtBQUssQ0FBQ2xiLGlCQUFpQixDQUFDLElBQUk7WUFDeEQ7WUFDQTs7OztPQUlDLEdBQ0QsSUFBSU8sT0FBT21hLGFBQWEsQ0FBQyxJQUFJLENBQUNRLEtBQUssQ0FBQ2xiLGlCQUFpQixDQUFDLEtBQUssR0FBRztnQkFDNUQsSUFBSSxDQUFDa2IsS0FBSyxDQUFDRCxXQUFXLENBQUNULFlBQVksQ0FBQyxJQUFJLENBQUN0TSxVQUFVO1lBQ3JEO1FBQ0Y7UUFFQTRNLHFCQUFxQmplLFNBQVMsQ0FBQzhWLE1BQU0sR0FBRyxTQUFTQTtZQUMvQyxJQUFJNEYsU0FBUyxJQUFJO1lBRWpCLElBQUk3WSxLQUF5QixJQUFnQnhFLHFEQUFjLENBQUNrZ0IsS0FBSyxDQUFDLElBQUksQ0FBQy9kLEtBQUssQ0FBQ21YLFFBQVEsR0FBRztnQkFDdEYsc0NBQXNDO2dCQUN0Q3BGLFFBQVFDLElBQUksQ0FBQyxnQ0FBZ0MsSUFBSSxDQUFDNkwsS0FBSyxDQUFDbGIsaUJBQWlCLEdBQUc7WUFDOUU7WUFFQSxxQkFBTzlFLDBEQUFtQixDQUN4Qm9iLG9CQUNBLE1BQ0EsU0FBVXBJLFVBQVU7Z0JBQ2xCcUssT0FBT3JLLFVBQVUsR0FBR0EsY0FBY3pDLFdBQVdELE1BQU07Z0JBRW5ELElBQUl5UCxjQUFjMUMsT0FBTzJDLEtBQUssQ0FBQ0QsV0FBVztnQkFHMUMsSUFBSUEsWUFBWXZLLFFBQVEsRUFBRTtvQkFDeEJ1SyxZQUFZUixZQUFZLENBQUM5WiwwQkFBMEI0WCxPQUFPckssVUFBVTtvQkFFcEUsT0FBTztnQkFDVCxPQUFPO29CQUNMLHFCQUFPaFQsMERBQW1CLENBQ3hCK1ksZUFDQSxNQUNBLFNBQVUxQyxLQUFLO3dCQUNiLGFBQWE7d0JBQ2IsSUFBSUYsZUFBZWtILE9BQU8zYixXQUFXLENBQUN5VSxZQUFZO3dCQUdsRCxJQUFJNU4sVUFBVTFGLFNBQVMsQ0FBQyxHQUFHd2EsT0FBT2xiLEtBQUs7d0JBRXZDLElBQUksT0FBT2tVLFVBQVUsYUFBYTs0QkFDaEM5TixRQUFROE4sS0FBSyxHQUFHSixlQUFlb0gsT0FBT2xiLEtBQUssRUFBRWtVLE9BQU9GO3dCQUN0RDt3QkFFQTRKLFlBQVlSLFlBQVksQ0FBQ2hYLFNBQVM4VSxPQUFPckssVUFBVTt3QkFFbkQsT0FBTztvQkFDVDtnQkFFSjtZQUNGO1FBRUo7UUFFQSxPQUFPNE07SUFDVCxFQUFFNWYsd0RBQWU7SUFFakI0ZixxQkFBcUJHLFdBQVcsR0FBRzVDO0lBQ25DeUMscUJBQXFCOWEsaUJBQWlCLEdBQUdtRjtJQUd6QyxPQUFPMlY7QUFDVDtBQUVBLEdBQUc7QUFFSCxJQUFJTyxvQkFBb0IsU0FBU0Esa0JBQWtCN1YsR0FBRztJQUNwRCxPQUFPQSxJQUFJcEUsT0FBTyxDQUFDLFdBQVc7QUFDaEM7QUFFQSxTQUFTa2EsVUFBVXJmLE9BQU87SUFDeEIsb0RBQW9ELEdBQ3BELElBQUl5RCxLQUF5QixJQUFnQixPQUFPNmIsY0FBYyxlQUFlQSxVQUFVQyxPQUFPLEtBQUssZUFBZTtRQUNwSCxzQ0FBc0M7UUFDdENwTSxRQUFRQyxJQUFJLENBQUM7SUFDZjtJQUVBLElBQUssSUFBSTdOLE9BQU92RCxVQUFVM0IsTUFBTSxFQUFFSixpQkFBaUJ1RixNQUFNRCxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJRSxPQUFPLEdBQUdBLE9BQU9GLE1BQU1FLE9BQVE7UUFDaEh4RixjQUFjLENBQUN3RixPQUFPLEVBQUUsR0FBR3pELFNBQVMsQ0FBQ3lELEtBQUs7SUFDNUM7SUFFQSxJQUFJZ0QsUUFBUXRDLElBQUlQLEtBQUssQ0FBQ2QsV0FBVztRQUFDOUU7S0FBUSxDQUFDNkYsTUFBTSxDQUFDNUY7SUFFbEQsSUFBSTBELE9BQU91USx1QkFBdUJOLFdBQVd3TCxrQkFBa0JULEtBQUtDLFNBQVMsQ0FBQ25XO0lBRTlFLE9BQU8sSUFBSXVKLFVBQVVyTyxNQUFNNkUsZUFBZUMsT0FBTzlFLE1BQU07QUFDekQ7QUFFQSxHQUFHO0FBRUgsSUFBSTZiLFlBQWEsU0FBVUMsWUFBWTtJQUNyQyxJQUFJQywwQkFBWXpnQix1REFBZ0IsQ0FBQyxTQUFVbUMsS0FBSyxFQUFFK2EsR0FBRztRQUNuRCxxQkFBT2xkLDBEQUFtQixDQUN4QitZLGVBQ0EsTUFDQSxTQUFVMUMsS0FBSztZQUNiLGFBQWE7WUFDYixJQUFJRixlQUFlcUssYUFBYXJLLFlBQVk7WUFFNUMsSUFBSXVLLFlBQVl6SyxlQUFlOVQsT0FBT2tVLE9BQU9GO1lBRTdDLElBQUkzUixLQUF5QixJQUFnQmtjLGNBQWM3YSxXQUFXO2dCQUNwRSxzQ0FBc0M7Z0JBQ3RDcU8sUUFBUUMsSUFBSSxDQUFDLDJIQUEySDVQLGlCQUFpQmljLGdCQUFnQjtZQUMzSztZQUVBLHFCQUFPeGdCLDBEQUFtQixDQUFDd2dCLGNBQWMzZCxTQUFTLENBQUMsR0FBR1YsT0FBTztnQkFBRWtVLE9BQU9xSztnQkFBV3hELEtBQUtBO1lBQUk7UUFDNUY7SUFFSjtJQUVBaEYscUJBQXFCdUksV0FBV0Q7SUFFaENDLFVBQVVoYyxXQUFXLEdBQUcsZUFBZUYsaUJBQWlCaWMsZ0JBQWdCO0lBRXhFLE9BQU9DO0FBQ1Q7QUFFQSxHQUFHO0FBRUgsa0JBQWtCLEdBQ2xCLElBQUlFLHVEQUF1RDtJQUN6RHBRLFlBQVlBO0FBQ2Q7QUFFQSxHQUFHO0FBRUgsd0RBQXdELEdBQ3hELElBQUkvTCxLQUF5QixJQUFnQixPQUFPNmIsY0FBYyxlQUFlQSxVQUFVQyxPQUFPLEtBQUssZUFBZTtJQUNwSCxzQ0FBc0M7SUFDdENwTSxRQUFRQyxJQUFJLENBQUMseUVBQXlFLG1FQUFtRTtBQUMzSjtBQUVBLCtEQUErRCxHQUMvRCxJQUFJM1AsS0FBd1IsRUFBRSxFQVM3UjtBQUVELEVBQUU7QUFFRixpRUFBZTBhLE1BQU1BLEVBQUM7QUFDbU8sQ0FDelAsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHVoYWNrc18zLy4vbm9kZV9tb2R1bGVzL2JldHRlci1yZWFjdC1jYXJvdXNlbC9ub2RlX21vZHVsZXMvc3R5bGVkLWNvbXBvbmVudHMvZGlzdC9zdHlsZWQtY29tcG9uZW50cy5lc20uanM/ODU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU3R5bGlzIGZyb20gJ3N0eWxpcy9zdHlsaXMubWluJztcbmltcG9ydCBfaW5zZXJ0UnVsZVBsdWdpbiBmcm9tICdzdHlsaXMtcnVsZS1zaGVldCc7XG5pbXBvcnQgUmVhY3QsIHsgY2xvbmVFbGVtZW50LCBjcmVhdGVDb250ZXh0LCBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgdW5pdGxlc3MgZnJvbSAnQGVtb3Rpb24vdW5pdGxlc3MnO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc1ZhbGlkRWxlbWVudFR5cGUsIEZvcndhcmRSZWYgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgbWVtb2l6ZSBmcm9tICdtZW1vaXplLW9uZSc7XG5pbXBvcnQgc3RyZWFtIGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHZhbGlkQXR0ciBmcm9tICdAZW1vdGlvbi9pcy1wcm9wLXZhbGlkJztcbmltcG9ydCBtZXJnZSBmcm9tICdtZXJnZS1hbnl0aGluZyc7XG5cbi8vIFxuXG52YXIgaW50ZXJsZWF2ZSA9IChmdW5jdGlvbiAoc3RyaW5ncywgaW50ZXJwb2xhdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IFtzdHJpbmdzWzBdXTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW50ZXJwb2xhdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0aW9uc1tpXSwgc3RyaW5nc1tpICsgMV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmosIGtleXMpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTtcbiAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07XG5cbi8vIFxudmFyIGlzUGxhaW5PYmplY3QgPSAoZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoeCkpID09PSAnb2JqZWN0JyAmJiB4LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59KTtcblxuLy8gXG52YXIgRU1QVFlfQVJSQVkgPSBPYmplY3QuZnJlZXplKFtdKTtcbnZhciBFTVBUWV9PQkpFQ1QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHRlc3QpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vLyBcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0YXJnZXQpIHtcbiAgcmV0dXJuIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgJiYgdGFyZ2V0IDogZmFsc2UpIHx8IHRhcmdldC5kaXNwbGF5TmFtZSB8fCB0YXJnZXQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxuLy8gXG5mdW5jdGlvbiBpc1N0YXRlbGVzc0Z1bmN0aW9uKHRlc3QpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ID09PSAnZnVuY3Rpb24nICYmICEodGVzdC5wcm90b3R5cGUgJiYgdGVzdC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbi8vIFxuZnVuY3Rpb24gaXNTdHlsZWRDb21wb25lbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgJiYgdHlwZW9mIHRhcmdldC5zdHlsZWRDb21wb25lbnRJZCA9PT0gJ3N0cmluZyc7XG59XG5cbi8vIFxuXG52YXIgU0NfQVRUUiA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAocHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX1NDX0FUVFIgfHwgcHJvY2Vzcy5lbnYuU0NfQVRUUikgfHwgJ2RhdGEtc3R5bGVkJztcblxudmFyIFNDX1ZFUlNJT05fQVRUUiA9ICdkYXRhLXN0eWxlZC12ZXJzaW9uJztcblxudmFyIFNDX1NUUkVBTV9BVFRSID0gJ2RhdGEtc3R5bGVkLXN0cmVhbWVkJztcblxudmFyIElTX0JST1dTRVIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnSFRNTEVsZW1lbnQnIGluIHdpbmRvdztcblxudmFyIERJU0FCTEVfU1BFRURZID0gdHlwZW9mIFNDX0RJU0FCTEVfU1BFRURZID09PSAnYm9vbGVhbicgJiYgU0NfRElTQUJMRV9TUEVFRFkgfHwgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIChwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfRElTQUJMRV9TUEVFRFkgfHwgcHJvY2Vzcy5lbnYuU0NfRElTQUJMRV9TUEVFRFkpIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5cbi8vIFNoYXJlZCBlbXB0eSBleGVjdXRpb24gY29udGV4dCB3aGVuIGdlbmVyYXRpbmcgc3RhdGljIHN0eWxlc1xudmFyIFNUQVRJQ19FWEVDVVRJT05fQ09OVEVYVCA9IHt9O1xuXG4vLyBcblxuXG4vKipcbiAqIFBhcnNlIGVycm9ycy5tZCBhbmQgdHVybiBpdCBpbnRvIGEgc2ltcGxlIGhhc2ggb2YgY29kZTogbWVzc2FnZVxuICovXG52YXIgRVJST1JTID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHtcbiAgXCIxXCI6IFwiQ2Fubm90IGNyZWF0ZSBzdHlsZWQtY29tcG9uZW50IGZvciBjb21wb25lbnQ6ICVzLlxcblxcblwiLFxuICBcIjJcIjogXCJDYW4ndCBjb2xsZWN0IHN0eWxlcyBvbmNlIHlvdSd2ZSBjb25zdW1lZCBhIGBTZXJ2ZXJTdHlsZVNoZWV0YCdzIHN0eWxlcyEgYFNlcnZlclN0eWxlU2hlZXRgIGlzIGEgb25lIG9mZiBpbnN0YW5jZSBmb3IgZWFjaCBzZXJ2ZXItc2lkZSByZW5kZXIgY3ljbGUuXFxuXFxuLSBBcmUgeW91IHRyeWluZyB0byByZXVzZSBpdCBhY3Jvc3MgcmVuZGVycz9cXG4tIEFyZSB5b3UgYWNjaWRlbnRhbGx5IGNhbGxpbmcgY29sbGVjdFN0eWxlcyB0d2ljZT9cXG5cXG5cIixcbiAgXCIzXCI6IFwiU3RyZWFtaW5nIFNTUiBpcyBvbmx5IHN1cHBvcnRlZCBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQ7IFBsZWFzZSBkbyBub3QgdHJ5IHRvIGNhbGwgdGhpcyBtZXRob2QgaW4gdGhlIGJyb3dzZXIuXFxuXFxuXCIsXG4gIFwiNFwiOiBcIlRoZSBgU3R5bGVTaGVldE1hbmFnZXJgIGV4cGVjdHMgYSB2YWxpZCB0YXJnZXQgb3Igc2hlZXQgcHJvcCFcXG5cXG4tIERvZXMgdGhpcyBlcnJvciBvY2N1ciBvbiB0aGUgY2xpZW50IGFuZCBpcyB5b3VyIHRhcmdldCBmYWxzeT9cXG4tIERvZXMgdGhpcyBlcnJvciBvY2N1ciBvbiB0aGUgc2VydmVyIGFuZCBpcyB0aGUgc2hlZXQgZmFsc3k/XFxuXFxuXCIsXG4gIFwiNVwiOiBcIlRoZSBjbG9uZSBtZXRob2QgY2Fubm90IGJlIHVzZWQgb24gdGhlIGNsaWVudCFcXG5cXG4tIEFyZSB5b3UgcnVubmluZyBpbiBhIGNsaWVudC1saWtlIGVudmlyb25tZW50IG9uIHRoZSBzZXJ2ZXI/XFxuLSBBcmUgeW91IHRyeWluZyB0byBydW4gU1NSIG9uIHRoZSBjbGllbnQ/XFxuXFxuXCIsXG4gIFwiNlwiOiBcIlRyeWluZyB0byBpbnNlcnQgYSBuZXcgc3R5bGUgdGFnLCBidXQgdGhlIGdpdmVuIE5vZGUgaXMgdW5tb3VudGVkIVxcblxcbi0gQXJlIHlvdSB1c2luZyBhIGN1c3RvbSB0YXJnZXQgdGhhdCBpc24ndCBtb3VudGVkP1xcbi0gRG9lcyB5b3VyIGRvY3VtZW50IG5vdCBoYXZlIGEgdmFsaWQgaGVhZCBlbGVtZW50P1xcbi0gSGF2ZSB5b3UgYWNjaWRlbnRhbGx5IHJlbW92ZWQgYSBzdHlsZSB0YWcgbWFudWFsbHk/XFxuXFxuXCIsXG4gIFwiN1wiOiBcIlRoZW1lUHJvdmlkZXI6IFBsZWFzZSByZXR1cm4gYW4gb2JqZWN0IGZyb20geW91ciBcXFwidGhlbWVcXFwiIHByb3AgZnVuY3Rpb24sIGUuZy5cXG5cXG5gYGBqc1xcbnRoZW1lPXsoKSA9PiAoe30pfVxcbmBgYFxcblxcblwiLFxuICBcIjhcIjogXCJUaGVtZVByb3ZpZGVyOiBQbGVhc2UgbWFrZSB5b3VyIFxcXCJ0aGVtZVxcXCIgcHJvcCBhbiBvYmplY3QuXFxuXFxuXCIsXG4gIFwiOVwiOiBcIk1pc3NpbmcgZG9jdW1lbnQgYDxoZWFkPmBcXG5cXG5cIixcbiAgXCIxMFwiOiBcIkNhbm5vdCBmaW5kIGEgU3R5bGVTaGVldCBpbnN0YW5jZS4gVXN1YWxseSB0aGlzIGhhcHBlbnMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvcGllcyBvZiBzdHlsZWQtY29tcG9uZW50cyBsb2FkZWQgYXQgb25jZS4gQ2hlY2sgb3V0IHRoaXMgaXNzdWUgZm9yIGhvdyB0byB0cm91Ymxlc2hvb3QgYW5kIGZpeCB0aGUgY29tbW9uIGNhc2VzIHdoZXJlIHRoaXMgc2l0dWF0aW9uIGNhbiBoYXBwZW46IGh0dHBzOi8vZ2l0aHViLmNvbS9zdHlsZWQtY29tcG9uZW50cy9zdHlsZWQtY29tcG9uZW50cy9pc3N1ZXMvMTk0MSNpc3N1ZWNvbW1lbnQtNDE3ODYyMDIxXFxuXFxuXCIsXG4gIFwiMTFcIjogXCJfVGhpcyBlcnJvciB3YXMgcmVwbGFjZWQgd2l0aCBhIGRldi10aW1lIHdhcm5pbmcsIGl0IHdpbGwgYmUgZGVsZXRlZCBmb3IgdjQgZmluYWwuXyBbY3JlYXRlR2xvYmFsU3R5bGVdIHJlY2VpdmVkIGNoaWxkcmVuIHdoaWNoIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBQbGVhc2UgdXNlIHRoZSBjb21wb25lbnQgd2l0aG91dCBwYXNzaW5nIGNoaWxkcmVuIGVsZW1lbnRzLlxcblxcblwiLFxuICBcIjEyXCI6IFwiSXQgc2VlbXMgeW91IGFyZSBpbnRlcnBvbGF0aW5nIGEga2V5ZnJhbWUgZGVjbGFyYXRpb24gKCVzKSBpbnRvIGFuIHVudGFnZ2VkIHN0cmluZy4gVGhpcyB3YXMgc3VwcG9ydGVkIGluIHN0eWxlZC1jb21wb25lbnRzIHYzLCBidXQgaXMgbm90IGxvbmdlciBzdXBwb3J0ZWQgaW4gdjQgYXMga2V5ZnJhbWVzIGFyZSBub3cgaW5qZWN0ZWQgb24tZGVtYW5kLiBQbGVhc2Ugd3JhcCB5b3VyIHN0cmluZyBpbiB0aGUgY3NzXFxcXGBcXFxcYCBoZWxwZXIgd2hpY2ggZW5zdXJlcyB0aGUgc3R5bGVzIGFyZSBpbmplY3RlZCBjb3JyZWN0bHkuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hcGkjY3NzXFxuXFxuXCIsXG4gIFwiMTNcIjogXCIlcyBpcyBub3QgYSBzdHlsZWQgY29tcG9uZW50IGFuZCBjYW5ub3QgYmUgcmVmZXJyZWQgdG8gdmlhIGNvbXBvbmVudCBzZWxlY3Rvci4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FkdmFuY2VkI3JlZmVycmluZy10by1vdGhlci1jb21wb25lbnRzIGZvciBtb3JlIGRldGFpbHMuXFxuXCJcbn0gOiB7fTtcblxuLyoqXG4gKiBzdXBlciBiYXNpYyB2ZXJzaW9uIG9mIHNwcmludGZcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KCkge1xuICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTtcbiAgdmFyIGIgPSBbXTtcblxuICBmb3IgKHZhciBjID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgYyA8IGxlbjsgYyArPSAxKSB7XG4gICAgYi5wdXNoKGFyZ3VtZW50cy5sZW5ndGggPD0gYyA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tjXSk7XG4gIH1cblxuICBiLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICBhID0gYS5yZXBsYWNlKC8lW2Etel0vLCBkKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVycm9yIGZpbGUgb3V0IG9mIGVycm9ycy5tZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIGEgc2ltcGxlIHdlYiBsaW5rIHRvIHRoZSBmdWxsIGVycm9yc1xuICogaW4gcHJvZHVjdGlvbiBtb2RlLlxuICovXG5cbnZhciBTdHlsZWRDb21wb25lbnRzRXJyb3IgPSBmdW5jdGlvbiAoX0Vycm9yKSB7XG4gIGluaGVyaXRzKFN0eWxlZENvbXBvbmVudHNFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBTdHlsZWRDb21wb25lbnRzRXJyb3IoY29kZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlZENvbXBvbmVudHNFcnJvcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaW50ZXJwb2xhdGlvbnMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBpbnRlcnBvbGF0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Vycm9yLmNhbGwodGhpcywgJ0FuIGVycm9yIG9jY3VycmVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3N0eWxlZC1jb21wb25lbnRzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3N0eWxlZC1jb21wb25lbnRzL3NyYy91dGlscy9lcnJvcnMubWQjJyArIGNvZGUgKyAnIGZvciBtb3JlIGluZm9ybWF0aW9uLicgKyAoaW50ZXJwb2xhdGlvbnMubGVuZ3RoID4gMCA/ICcgQWRkaXRpb25hbCBhcmd1bWVudHM6ICcgKyBpbnRlcnBvbGF0aW9ucy5qb2luKCcsICcpIDogJycpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0Vycm9yLmNhbGwodGhpcywgZm9ybWF0LmFwcGx5KHVuZGVmaW5lZCwgW0VSUk9SU1tjb2RlXV0uY29uY2F0KGludGVycG9sYXRpb25zKSkudHJpbSgpKSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzKTtcbiAgfVxuXG4gIHJldHVybiBTdHlsZWRDb21wb25lbnRzRXJyb3I7XG59KEVycm9yKTtcblxuLy8gXG52YXIgU0NfQ09NUE9ORU5UX0lEID0gL15bXlxcU1xcbl0qP1xcL1xcKiBzYy1jb21wb25lbnQtaWQ6XFxzKihcXFMrKVxccytcXCpcXC8vZ207XG5cbnZhciBleHRyYWN0Q29tcHMgPSAoZnVuY3Rpb24gKG1heWJlQ1NTKSB7XG4gIHZhciBjc3MgPSAnJyArIChtYXliZUNTUyB8fCAnJyk7IC8vIERlZmluaXRlbHkgYSBzdHJpbmcsIGFuZCBhIGNsb25lXG4gIHZhciBleGlzdGluZ0NvbXBvbmVudHMgPSBbXTtcbiAgY3NzLnJlcGxhY2UoU0NfQ09NUE9ORU5UX0lELCBmdW5jdGlvbiAobWF0Y2gsIGNvbXBvbmVudElkLCBtYXRjaEluZGV4KSB7XG4gICAgZXhpc3RpbmdDb21wb25lbnRzLnB1c2goeyBjb21wb25lbnRJZDogY29tcG9uZW50SWQsIG1hdGNoSW5kZXg6IG1hdGNoSW5kZXggfSk7XG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcbiAgcmV0dXJuIGV4aXN0aW5nQ29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKF9yZWYsIGkpIHtcbiAgICB2YXIgY29tcG9uZW50SWQgPSBfcmVmLmNvbXBvbmVudElkLFxuICAgICAgICBtYXRjaEluZGV4ID0gX3JlZi5tYXRjaEluZGV4O1xuXG4gICAgdmFyIG5leHRDb21wID0gZXhpc3RpbmdDb21wb25lbnRzW2kgKyAxXTtcbiAgICB2YXIgY3NzRnJvbURPTSA9IG5leHRDb21wID8gY3NzLnNsaWNlKG1hdGNoSW5kZXgsIG5leHRDb21wLm1hdGNoSW5kZXgpIDogY3NzLnNsaWNlKG1hdGNoSW5kZXgpO1xuICAgIHJldHVybiB7IGNvbXBvbmVudElkOiBjb21wb25lbnRJZCwgY3NzRnJvbURPTTogY3NzRnJvbURPTSB9O1xuICB9KTtcbn0pO1xuXG4vLyBcblxudmFyIENPTU1FTlRfUkVHRVggPSAvXlxccypcXC9cXC8uKiQvZ207XG5cbi8vIE5PVEU6IFRoaXMgc3R5bGlzIGluc3RhbmNlIGlzIG9ubHkgdXNlZCB0byBzcGxpdCBydWxlcyBmcm9tIFNTUidkIHN0eWxlIHRhZ3NcbnZhciBzdHlsaXNTcGxpdHRlciA9IG5ldyBTdHlsaXMoe1xuICBnbG9iYWw6IGZhbHNlLFxuICBjYXNjYWRlOiB0cnVlLFxuICBrZXlmcmFtZTogZmFsc2UsXG4gIHByZWZpeDogZmFsc2UsXG4gIGNvbXByZXNzOiBmYWxzZSxcbiAgc2VtaWNvbG9uOiB0cnVlXG59KTtcblxudmFyIHN0eWxpcyA9IG5ldyBTdHlsaXMoe1xuICBnbG9iYWw6IGZhbHNlLFxuICBjYXNjYWRlOiB0cnVlLFxuICBrZXlmcmFtZTogZmFsc2UsXG4gIHByZWZpeDogdHJ1ZSxcbiAgY29tcHJlc3M6IGZhbHNlLFxuICBzZW1pY29sb246IGZhbHNlIC8vIE5PVEU6IFRoaXMgbWVhbnMgXCJhdXRvY29tcGxldGUgbWlzc2luZyBzZW1pY29sb25zXCJcbn0pO1xuXG4vLyBXcmFwIGBpbnNlcnRSdWxlUGx1Z2luIHRvIGJ1aWxkIGEgbGlzdCBvZiBydWxlcyxcbi8vIGFuZCB0aGVuIG1ha2Ugb3VyIG93biBwbHVnaW4gdG8gcmV0dXJuIHRoZSBydWxlcy4gVGhpc1xuLy8gbWFrZXMgaXQgZWFzaWVyIHRvIGhvb2sgaW50byB0aGUgZXhpc3RpbmcgU1NSIGFyY2hpdGVjdHVyZVxuXG52YXIgcGFyc2luZ1J1bGVzID0gW107XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIHJldHVyblJ1bGVzUGx1Z2luID0gZnVuY3Rpb24gcmV0dXJuUnVsZXNQbHVnaW4oY29udGV4dCkge1xuICBpZiAoY29udGV4dCA9PT0gLTIpIHtcbiAgICB2YXIgcGFyc2VkUnVsZXMgPSBwYXJzaW5nUnVsZXM7XG4gICAgcGFyc2luZ1J1bGVzID0gW107XG4gICAgcmV0dXJuIHBhcnNlZFJ1bGVzO1xuICB9XG59O1xuXG52YXIgcGFyc2VSdWxlc1BsdWdpbiA9IF9pbnNlcnRSdWxlUGx1Z2luKGZ1bmN0aW9uIChydWxlKSB7XG4gIHBhcnNpbmdSdWxlcy5wdXNoKHJ1bGUpO1xufSk7XG5cbnZhciBfY29tcG9uZW50SWQgPSB2b2lkIDA7XG52YXIgX3NlbGVjdG9yID0gdm9pZCAwO1xudmFyIF9zZWxlY3RvclJlZ2V4cCA9IHZvaWQgMDtcblxudmFyIHNlbGZSZWZlcmVuY2VSZXBsYWNlciA9IGZ1bmN0aW9uIHNlbGZSZWZlcmVuY2VSZXBsYWNlcihtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgaWYgKFxuICAvLyB0aGUgZmlyc3Qgc2VsZi1yZWYgaXMgYWx3YXlzIHVudG91Y2hlZFxuICBvZmZzZXQgPiAwICYmXG4gIC8vIHRoZXJlIHNob3VsZCBiZSBhdCBsZWFzdCB0d28gc2VsZi1yZWZzIHRvIGRvIGEgcmVwbGFjZW1lbnQgKC5iID4gLmIpXG4gIHN0cmluZy5zbGljZSgwLCBvZmZzZXQpLmluZGV4T2YoX3NlbGVjdG9yKSAhPT0gLTEgJiZcbiAgLy8gbm8gY29uc2VjdXRpdmUgc2VsZiByZWZzICguYi5iKTsgdGhhdCBpcyBhIHByZWNlZGVuY2UgYm9vc3QgYW5kIHRyZWF0ZWQgZGlmZmVyZW50bHlcbiAgc3RyaW5nLnNsaWNlKG9mZnNldCAtIF9zZWxlY3Rvci5sZW5ndGgsIG9mZnNldCkgIT09IF9zZWxlY3Rvcikge1xuICAgIHJldHVybiAnLicgKyBfY29tcG9uZW50SWQ7XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59O1xuXG4vKipcbiAqIFdoZW4gd3JpdGluZyBhIHN0eWxlIGxpa2VcbiAqXG4gKiAmICsgJiB7XG4gKiAgIGNvbG9yOiByZWQ7XG4gKiB9XG4gKlxuICogVGhlIHNlY29uZCBhbXBlcnNhbmQgc2hvdWxkIGJlIGEgcmVmZXJlbmNlIHRvIHRoZSBzdGF0aWMgY29tcG9uZW50IGNsYXNzLiBzdHlsaXNcbiAqIGhhcyBubyBrbm93bGVkZ2Ugb2Ygc3RhdGljIGNsYXNzIHNvIHdlIGhhdmUgdG8gaW50ZWxsaWdlbnRseSByZXBsYWNlIHRoZSBiYXNlIHNlbGVjdG9yLlxuICovXG52YXIgc2VsZlJlZmVyZW5jZVJlcGxhY2VtZW50UGx1Z2luID0gZnVuY3Rpb24gc2VsZlJlZmVyZW5jZVJlcGxhY2VtZW50UGx1Z2luKGNvbnRleHQsIF8sIHNlbGVjdG9ycykge1xuICBpZiAoY29udGV4dCA9PT0gMiAmJiBzZWxlY3RvcnMubGVuZ3RoICYmIHNlbGVjdG9yc1swXS5sYXN0SW5kZXhPZihfc2VsZWN0b3IpID4gMCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHNlbGVjdG9yc1swXSA9IHNlbGVjdG9yc1swXS5yZXBsYWNlKF9zZWxlY3RvclJlZ2V4cCwgc2VsZlJlZmVyZW5jZVJlcGxhY2VyKTtcbiAgfVxufTtcblxuc3R5bGlzLnVzZShbc2VsZlJlZmVyZW5jZVJlcGxhY2VtZW50UGx1Z2luLCBwYXJzZVJ1bGVzUGx1Z2luLCByZXR1cm5SdWxlc1BsdWdpbl0pO1xuc3R5bGlzU3BsaXR0ZXIudXNlKFtwYXJzZVJ1bGVzUGx1Z2luLCByZXR1cm5SdWxlc1BsdWdpbl0pO1xuXG52YXIgc3BsaXRCeVJ1bGVzID0gZnVuY3Rpb24gc3BsaXRCeVJ1bGVzKGNzcykge1xuICByZXR1cm4gc3R5bGlzU3BsaXR0ZXIoJycsIGNzcyk7XG59O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlSdWxlcyhydWxlcywgc2VsZWN0b3IsIHByZWZpeCkge1xuICB2YXIgY29tcG9uZW50SWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcmJztcblxuICB2YXIgZmxhdENTUyA9IHJ1bGVzLmpvaW4oJycpLnJlcGxhY2UoQ09NTUVOVF9SRUdFWCwgJycpOyAvLyByZXBsYWNlIEpTIGNvbW1lbnRzXG5cbiAgdmFyIGNzc1N0ciA9IHNlbGVjdG9yICYmIHByZWZpeCA/IHByZWZpeCArICcgJyArIHNlbGVjdG9yICsgJyB7ICcgKyBmbGF0Q1NTICsgJyB9JyA6IGZsYXRDU1M7XG5cbiAgLy8gc3R5bGlzIGhhcyBubyBjb25jZXB0IG9mIHN0YXRlIHRvIGJlIHBhc3NlZCB0byBwbHVnaW5zXG4gIC8vIGJ1dCBzaW5jZSBKUyBpcyBzaW5nbGU9dGhyZWFkZWQsIHdlIGNhbiByZWx5IG9uIHRoYXQgdG8gZW5zdXJlXG4gIC8vIHRoZXNlIHByb3BlcnRpZXMgc3RheSBpbiBzeW5jIHdpdGggdGhlIGN1cnJlbnQgc3R5bGlzIHJ1blxuICBfY29tcG9uZW50SWQgPSBjb21wb25lbnRJZDtcbiAgX3NlbGVjdG9yID0gc2VsZWN0b3I7XG4gIF9zZWxlY3RvclJlZ2V4cCA9IG5ldyBSZWdFeHAoJ1xcXFwnICsgX3NlbGVjdG9yICsgJ1xcXFxiJywgJ2cnKTtcblxuICByZXR1cm4gc3R5bGlzKHByZWZpeCB8fCAhc2VsZWN0b3IgPyAnJyA6IHNlbGVjdG9yLCBjc3NTdHIpO1xufVxuXG4vLyBcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSwgbm8tdW5kZWYgKi9cblxudmFyIGdldE5vbmNlID0gKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG59KTtcblxuLy8gXG4vKiBUaGVzZSBhcmUgaGVscGVycyBmb3IgdGhlIFN0eWxlVGFncyB0byBrZWVwIHRyYWNrIG9mIHRoZSBpbmplY3RlZFxuICogcnVsZSBuYW1lcyBmb3IgZWFjaCAoY29tcG9uZW50KSBJRCB0aGF0IHRoZXkncmUga2VlcGluZyB0cmFjayBvZi5cbiAqIFRoZXkncmUgY3J1Y2lhbCBmb3IgZGV0ZWN0aW5nIHdoZXRoZXIgYSBuYW1lIGhhcyBhbHJlYWR5IGJlZW5cbiAqIGluamVjdGVkLlxuICogKFRoaXMgZXhjbHVkZXMgcmVoeWRyYXRlZCBuYW1lcykgKi9cblxuLyogYWRkcyBhIG5ldyBJRDpuYW1lIHBhaXJpbmcgdG8gYSBuYW1lcyBkaWN0aW9uYXJ5ICovXG52YXIgYWRkTmFtZUZvcklkID0gZnVuY3Rpb24gYWRkTmFtZUZvcklkKG5hbWVzLCBpZCwgbmFtZSkge1xuICBpZiAobmFtZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIHZhciBuYW1lc0ZvcklkID0gbmFtZXNbaWRdIHx8IChuYW1lc1tpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBuYW1lc0ZvcklkW25hbWVdID0gdHJ1ZTtcbiAgfVxufTtcblxuLyogcmVzZXRzIGFuIElEIGVudGlyZWx5IGJ5IG92ZXJ3cml0aW5nIGl0IGluIHRoZSBkaWN0aW9uYXJ5ICovXG52YXIgcmVzZXRJZE5hbWVzID0gZnVuY3Rpb24gcmVzZXRJZE5hbWVzKG5hbWVzLCBpZCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgbmFtZXNbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn07XG5cbi8qIGZhY3RvcnkgZm9yIGEgbmFtZXMgZGljdGlvbmFyeSBjaGVja2luZyB0aGUgZXhpc3RhbmNlIG9mIGFuIElEOm5hbWUgcGFpcmluZyAqL1xudmFyIGhhc05hbWVGb3JJZCA9IGZ1bmN0aW9uIGhhc05hbWVGb3JJZChuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24gKGlkLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWVzW2lkXSAhPT0gdW5kZWZpbmVkICYmIG5hbWVzW2lkXVtuYW1lXTtcbiAgfTtcbn07XG5cbi8qIHN0cmluZ2lmaWVzIG5hbWVzIGZvciB0aGUgaHRtbC9lbGVtZW50IG91dHB1dCAqL1xudmFyIHN0cmluZ2lmeU5hbWVzID0gZnVuY3Rpb24gc3RyaW5naWZ5TmFtZXMobmFtZXMpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gIGZvciAodmFyIGlkIGluIG5hbWVzKSB7XG4gICAgc3RyICs9IE9iamVjdC5rZXlzKG5hbWVzW2lkXSkuam9pbignICcpICsgJyAnO1xuICB9XG4gIHJldHVybiBzdHIudHJpbSgpO1xufTtcblxuLyogY2xvbmVzIHRoZSBuZXN0ZWQgbmFtZXMgZGljdGlvbmFyeSAqL1xudmFyIGNsb25lTmFtZXMgPSBmdW5jdGlvbiBjbG9uZU5hbWVzKG5hbWVzKSB7XG4gIHZhciBjbG9uZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgZm9yICh2YXIgaWQgaW4gbmFtZXMpIHtcbiAgICBjbG9uZVtpZF0gPSBfZXh0ZW5kcyh7fSwgbmFtZXNbaWRdKTtcbiAgfVxuICByZXR1cm4gY2xvbmU7XG59O1xuXG4vLyBcblxuLyogVGhlc2UgYXJlIGhlbHBlcnMgdGhhdCBkZWFsIHdpdGggdGhlIGluc2VydFJ1bGUgKGFrYSBzcGVlZHkpIEFQSVxuICogVGhleSBhcmUgdXNlZCBpbiB0aGUgU3R5bGVUYWdzIGFuZCBzcGVjaWZpY2FsbHkgdGhlIHNwZWVkeSB0YWdcbiAqL1xuXG4vKiByZXRyaWV2ZSBhIHNoZWV0IGZvciBhIGdpdmVuIHN0eWxlIHRhZyAqL1xudmFyIHNoZWV0Rm9yVGFnID0gZnVuY3Rpb24gc2hlZXRGb3JUYWcodGFnKSB7XG4gIC8vICRGbG93Rml4TWVcbiAgaWYgKHRhZy5zaGVldCkgcmV0dXJuIHRhZy5zaGVldDtcblxuICAvKiBGaXJlZm94IHF1aXJrIHJlcXVpcmVzIHVzIHRvIHN0ZXAgdGhyb3VnaCBhbGwgc3R5bGVzaGVldHMgdG8gZmluZCBvbmUgb3duZWQgYnkgdGhlIGdpdmVuIHRhZyAqL1xuICB2YXIgc2l6ZSA9IHRhZy5vd25lckRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICB2YXIgc2hlZXQgPSB0YWcub3duZXJEb2N1bWVudC5zdHlsZVNoZWV0c1tpXTtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgaWYgKHNoZWV0Lm93bmVyTm9kZSA9PT0gdGFnKSByZXR1cm4gc2hlZXQ7XG4gIH1cblxuICAvKiB3ZSBzaG91bGQgYWx3YXlzIGJlIGFibGUgdG8gZmluZCBhIHRhZyAqL1xuICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDEwKTtcbn07XG5cbi8qIGluc2VydCBhIHJ1bGUgc2FmZWx5IGFuZCByZXR1cm4gd2hldGhlciBpdCB3YXMgYWN0dWFsbHkgaW5qZWN0ZWQgKi9cbnZhciBzYWZlSW5zZXJ0UnVsZSA9IGZ1bmN0aW9uIHNhZmVJbnNlcnRSdWxlKHNoZWV0LCBjc3NSdWxlLCBpbmRleCkge1xuICAvKiBhYm9ydCBlYXJseSBpZiBjc3NSdWxlIHN0cmluZyBpcyBmYWxzeSAqL1xuICBpZiAoIWNzc1J1bGUpIHJldHVybiBmYWxzZTtcblxuICB2YXIgbWF4SW5kZXggPSBzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG5cbiAgdHJ5IHtcbiAgICAvKiB1c2UgaW5zZXJ0UnVsZSBhbmQgY2FwIHBhc3NlZCBpbmRleCB3aXRoIG1heEluZGV4IChubyBvZiBjc3NSdWxlcykgKi9cbiAgICBzaGVldC5pbnNlcnRSdWxlKGNzc1J1bGUsIGluZGV4IDw9IG1heEluZGV4ID8gaW5kZXggOiBtYXhJbmRleCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8qIGFueSBlcnJvciBpbmRpY2F0ZXMgYW4gaW52YWxpZCBydWxlICovXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKiBkZWxldGVzIGBzaXplYCBydWxlcyBzdGFydGluZyBmcm9tIGByZW1vdmFsSW5kZXhgICovXG52YXIgZGVsZXRlUnVsZXMgPSBmdW5jdGlvbiBkZWxldGVSdWxlcyhzaGVldCwgcmVtb3ZhbEluZGV4LCBzaXplKSB7XG4gIHZhciBsb3dlckJvdW5kID0gcmVtb3ZhbEluZGV4IC0gc2l6ZTtcbiAgZm9yICh2YXIgaSA9IHJlbW92YWxJbmRleDsgaSA+IGxvd2VyQm91bmQ7IGkgLT0gMSkge1xuICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaSk7XG4gIH1cbn07XG5cbi8vIFxuXG4vKiB0aGlzIG1hcmtlciBzZXBhcmF0ZXMgY29tcG9uZW50IHN0eWxlcyBhbmQgaXMgaW1wb3J0YW50IGZvciByZWh5ZHJhdGlvbiAqL1xudmFyIG1ha2VUZXh0TWFya2VyID0gZnVuY3Rpb24gbWFrZVRleHRNYXJrZXIoaWQpIHtcbiAgcmV0dXJuICdcXG4vKiBzYy1jb21wb25lbnQtaWQ6ICcgKyBpZCArICcgKi9cXG4nO1xufTtcblxuLyogYWRkIHVwIGFsbCBudW1iZXJzIGluIGFycmF5IHVwIHVudGlsIGFuZCBpbmNsdWRpbmcgdGhlIGluZGV4ICovXG52YXIgYWRkVXBVbnRpbEluZGV4ID0gZnVuY3Rpb24gYWRkVXBVbnRpbEluZGV4KHNpemVzLCBpbmRleCkge1xuICB2YXIgdG90YWxVcFRvSW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBpbmRleDsgaSArPSAxKSB7XG4gICAgdG90YWxVcFRvSW5kZXggKz0gc2l6ZXNbaV07XG4gIH1cblxuICByZXR1cm4gdG90YWxVcFRvSW5kZXg7XG59O1xuXG4vKiBjcmVhdGUgYSBuZXcgc3R5bGUgdGFnIGFmdGVyIGxhc3RFbCAqL1xudmFyIG1ha2VTdHlsZVRhZyA9IGZ1bmN0aW9uIG1ha2VTdHlsZVRhZyh0YXJnZXQsIHRhZ0VsLCBpbnNlcnRCZWZvcmUpIHtcbiAgdmFyIHRhcmdldERvY3VtZW50ID0gZG9jdW1lbnQ7XG4gIGlmICh0YXJnZXQpIHRhcmdldERvY3VtZW50ID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7ZWxzZSBpZiAodGFnRWwpIHRhcmdldERvY3VtZW50ID0gdGFnRWwub3duZXJEb2N1bWVudDtcblxuICB2YXIgZWwgPSB0YXJnZXREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBlbC5zZXRBdHRyaWJ1dGUoU0NfQVRUUiwgJycpO1xuICBlbC5zZXRBdHRyaWJ1dGUoU0NfVkVSU0lPTl9BVFRSLCBcIjQuNC4xXCIpO1xuXG4gIHZhciBub25jZSA9IGdldE5vbmNlKCk7XG4gIGlmIChub25jZSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gIH1cblxuICAvKiBXb3JrIGFyb3VuZCBpbnNlcnRSdWxlIHF1aXJrIGluIEVkZ2VIVE1MICovXG4gIGVsLmFwcGVuZENoaWxkKHRhcmdldERvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKSk7XG5cbiAgaWYgKHRhcmdldCAmJiAhdGFnRWwpIHtcbiAgICAvKiBBcHBlbmQgdG8gdGFyZ2V0IHdoZW4gbm8gcHJldmlvdXMgZWxlbWVudCB3YXMgcGFzc2VkICovXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXRhZ0VsIHx8ICF0YXJnZXQgfHwgIXRhZ0VsLnBhcmVudE5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoNik7XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IG5ldyBzdHlsZSB0YWcgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZSAqL1xuICAgIHRhZ0VsLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBpbnNlcnRCZWZvcmUgPyB0YWdFbCA6IHRhZ0VsLm5leHRTaWJsaW5nKTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn07XG5cbi8qIHRha2VzIGEgY3NzIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG91dHB1dHMgYW4gaHRtbCBzdHlsZWQgdGFnIGZhY3RvcnkgKi9cbnZhciB3cmFwQXNIdG1sVGFnID0gZnVuY3Rpb24gd3JhcEFzSHRtbFRhZyhjc3MsIG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYWRkaXRpb25hbEF0dHJzKSB7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICB2YXIgYXR0cnMgPSBbbm9uY2UgJiYgJ25vbmNlPVwiJyArIG5vbmNlICsgJ1wiJywgU0NfQVRUUiArICc9XCInICsgc3RyaW5naWZ5TmFtZXMobmFtZXMpICsgJ1wiJywgU0NfVkVSU0lPTl9BVFRSICsgJz1cIicgKyBcIjQuNC4xXCIgKyAnXCInLCBhZGRpdGlvbmFsQXR0cnNdO1xuXG4gICAgdmFyIGh0bWxBdHRyID0gYXR0cnMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKTtcbiAgICByZXR1cm4gJzxzdHlsZSAnICsgaHRtbEF0dHIgKyAnPicgKyBjc3MoKSArICc8L3N0eWxlPic7XG4gIH07XG59O1xuXG4vKiB0YWtlcyBhIGNzcyBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBvdXRwdXRzIGFuIGVsZW1lbnQgZmFjdG9yeSAqL1xudmFyIHdyYXBBc0VsZW1lbnQgPSBmdW5jdGlvbiB3cmFwQXNFbGVtZW50KGNzcywgbmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3Byb3BzO1xuXG4gICAgdmFyIHByb3BzID0gKF9wcm9wcyA9IHt9LCBfcHJvcHNbU0NfQVRUUl0gPSBzdHJpbmdpZnlOYW1lcyhuYW1lcyksIF9wcm9wc1tTQ19WRVJTSU9OX0FUVFJdID0gXCI0LjQuMVwiLCBfcHJvcHMpO1xuXG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHByb3BzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWRhbmdlclxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdzdHlsZScsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBkYW5nZXJvdXNseVNldElubmVySFRNTDogeyBfX2h0bWw6IGNzcygpIH0gfSkpO1xuICB9O1xufTtcblxudmFyIGdldElkc0Zyb21NYXJrZXJzRmFjdG9yeSA9IGZ1bmN0aW9uIGdldElkc0Zyb21NYXJrZXJzRmFjdG9yeShtYXJrZXJzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcmtlcnMpO1xuICB9O1xufTtcblxuLyogc3BlZWR5IHRhZ3MgdXRpbGlzZSBpbnNlcnRSdWxlICovXG52YXIgbWFrZVNwZWVkeVRhZyA9IGZ1bmN0aW9uIG1ha2VTcGVlZHlUYWcoZWwsIGdldEltcG9ydFJ1bGVUYWcpIHtcbiAgdmFyIG5hbWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIG1hcmtlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgc2l6ZXMgPSBbXTtcblxuICB2YXIgZXh0cmFjdEltcG9ydCA9IGdldEltcG9ydFJ1bGVUYWcgIT09IHVuZGVmaW5lZDtcbiAgLyogaW5kaWNhdGVzIHdoZXRoZXIgZ2V0SW1wb3J0UnVsZVRhZyB3YXMgY2FsbGVkICovXG4gIHZhciB1c2VkSW1wb3J0UnVsZVRhZyA9IGZhbHNlO1xuXG4gIHZhciBpbnNlcnRNYXJrZXIgPSBmdW5jdGlvbiBpbnNlcnRNYXJrZXIoaWQpIHtcbiAgICB2YXIgcHJldiA9IG1hcmtlcnNbaWRdO1xuICAgIGlmIChwcmV2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cblxuICAgIG1hcmtlcnNbaWRdID0gc2l6ZXMubGVuZ3RoO1xuICAgIHNpemVzLnB1c2goMCk7XG4gICAgcmVzZXRJZE5hbWVzKG5hbWVzLCBpZCk7XG5cbiAgICByZXR1cm4gbWFya2Vyc1tpZF07XG4gIH07XG5cbiAgdmFyIGluc2VydFJ1bGVzID0gZnVuY3Rpb24gaW5zZXJ0UnVsZXMoaWQsIGNzc1J1bGVzLCBuYW1lKSB7XG4gICAgdmFyIG1hcmtlciA9IGluc2VydE1hcmtlcihpZCk7XG4gICAgdmFyIHNoZWV0ID0gc2hlZXRGb3JUYWcoZWwpO1xuICAgIHZhciBpbnNlcnRJbmRleCA9IGFkZFVwVW50aWxJbmRleChzaXplcywgbWFya2VyKTtcblxuICAgIHZhciBpbmplY3RlZFJ1bGVzID0gMDtcbiAgICB2YXIgaW1wb3J0UnVsZXMgPSBbXTtcbiAgICB2YXIgY3NzUnVsZXNTaXplID0gY3NzUnVsZXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjc3NSdWxlc1NpemU7IGkgKz0gMSkge1xuICAgICAgdmFyIGNzc1J1bGUgPSBjc3NSdWxlc1tpXTtcbiAgICAgIHZhciBtYXlIYXZlSW1wb3J0ID0gZXh0cmFjdEltcG9ydDsgLyogQGltcG9ydCBydWxlcyBhcmUgcmVvcmRlcmVkIHRvIGFwcGVhciBmaXJzdCAqL1xuICAgICAgaWYgKG1heUhhdmVJbXBvcnQgJiYgY3NzUnVsZS5pbmRleE9mKCdAaW1wb3J0JykgIT09IC0xKSB7XG4gICAgICAgIGltcG9ydFJ1bGVzLnB1c2goY3NzUnVsZSk7XG4gICAgICB9IGVsc2UgaWYgKHNhZmVJbnNlcnRSdWxlKHNoZWV0LCBjc3NSdWxlLCBpbnNlcnRJbmRleCArIGluamVjdGVkUnVsZXMpKSB7XG4gICAgICAgIG1heUhhdmVJbXBvcnQgPSBmYWxzZTtcbiAgICAgICAgaW5qZWN0ZWRSdWxlcyArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRyYWN0SW1wb3J0ICYmIGltcG9ydFJ1bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHVzZWRJbXBvcnRSdWxlVGFnID0gdHJ1ZTtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGdldEltcG9ydFJ1bGVUYWcoKS5pbnNlcnRSdWxlcyhpZCArICctaW1wb3J0JywgaW1wb3J0UnVsZXMpO1xuICAgIH1cblxuICAgIHNpemVzW21hcmtlcl0gKz0gaW5qZWN0ZWRSdWxlczsgLyogYWRkIHVwIG5vIG9mIGluamVjdGVkIHJ1bGVzICovXG4gICAgYWRkTmFtZUZvcklkKG5hbWVzLCBpZCwgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHJlbW92ZVJ1bGVzID0gZnVuY3Rpb24gcmVtb3ZlUnVsZXMoaWQpIHtcbiAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKG1hcmtlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIGlmIChlbC5pc0Nvbm5lY3RlZCA9PT0gZmFsc2UpIHJldHVybjtcblxuICAgIHZhciBzaXplID0gc2l6ZXNbbWFya2VyXTtcbiAgICB2YXIgc2hlZXQgPSBzaGVldEZvclRhZyhlbCk7XG4gICAgdmFyIHJlbW92YWxJbmRleCA9IGFkZFVwVW50aWxJbmRleChzaXplcywgbWFya2VyKSAtIDE7XG4gICAgZGVsZXRlUnVsZXMoc2hlZXQsIHJlbW92YWxJbmRleCwgc2l6ZSk7XG4gICAgc2l6ZXNbbWFya2VyXSA9IDA7XG4gICAgcmVzZXRJZE5hbWVzKG5hbWVzLCBpZCk7XG5cbiAgICBpZiAoZXh0cmFjdEltcG9ydCAmJiB1c2VkSW1wb3J0UnVsZVRhZykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgZ2V0SW1wb3J0UnVsZVRhZygpLnJlbW92ZVJ1bGVzKGlkICsgJy1pbXBvcnQnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNzcyA9IGZ1bmN0aW9uIGNzcygpIHtcbiAgICB2YXIgX3NoZWV0Rm9yVGFnID0gc2hlZXRGb3JUYWcoZWwpLFxuICAgICAgICBjc3NSdWxlcyA9IF9zaGVldEZvclRhZy5jc3NSdWxlcztcblxuICAgIHZhciBzdHIgPSAnJztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKHZhciBpZCBpbiBtYXJrZXJzKSB7XG4gICAgICBzdHIgKz0gbWFrZVRleHRNYXJrZXIoaWQpO1xuICAgICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaWRdO1xuICAgICAgdmFyIGVuZCA9IGFkZFVwVW50aWxJbmRleChzaXplcywgbWFya2VyKTtcbiAgICAgIHZhciBzaXplID0gc2l6ZXNbbWFya2VyXTtcbiAgICAgIGZvciAodmFyIGkgPSBlbmQgLSBzaXplOyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSBjc3NSdWxlc1tpXTtcbiAgICAgICAgaWYgKHJ1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0ciArPSBydWxlLmNzc1RleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcig1KTtcbiAgICB9LFxuXG4gICAgY3NzOiBjc3MsXG4gICAgZ2V0SWRzOiBnZXRJZHNGcm9tTWFya2Vyc0ZhY3RvcnkobWFya2VycyksXG4gICAgaGFzTmFtZUZvcklkOiBoYXNOYW1lRm9ySWQobmFtZXMpLFxuICAgIGluc2VydE1hcmtlcjogaW5zZXJ0TWFya2VyLFxuICAgIGluc2VydFJ1bGVzOiBpbnNlcnRSdWxlcyxcbiAgICByZW1vdmVSdWxlczogcmVtb3ZlUnVsZXMsXG4gICAgc2VhbGVkOiBmYWxzZSxcbiAgICBzdHlsZVRhZzogZWwsXG4gICAgdG9FbGVtZW50OiB3cmFwQXNFbGVtZW50KGNzcywgbmFtZXMpLFxuICAgIHRvSFRNTDogd3JhcEFzSHRtbFRhZyhjc3MsIG5hbWVzKVxuICB9O1xufTtcblxudmFyIG1ha2VUZXh0Tm9kZSA9IGZ1bmN0aW9uIG1ha2VUZXh0Tm9kZSh0YXJnZXREb2N1bWVudCwgaWQpIHtcbiAgcmV0dXJuIHRhcmdldERvY3VtZW50LmNyZWF0ZVRleHROb2RlKG1ha2VUZXh0TWFya2VyKGlkKSk7XG59O1xuXG52YXIgbWFrZUJyb3dzZXJUYWcgPSBmdW5jdGlvbiBtYWtlQnJvd3NlclRhZyhlbCwgZ2V0SW1wb3J0UnVsZVRhZykge1xuICB2YXIgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbWFya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgdmFyIGV4dHJhY3RJbXBvcnQgPSBnZXRJbXBvcnRSdWxlVGFnICE9PSB1bmRlZmluZWQ7XG5cbiAgLyogaW5kaWNhdGVzIHdoZXRoZXIgZ2V0SW1wb3J0UnVsZVRhZyB3YXMgY2FsbGVkICovXG4gIHZhciB1c2VkSW1wb3J0UnVsZVRhZyA9IGZhbHNlO1xuXG4gIHZhciBpbnNlcnRNYXJrZXIgPSBmdW5jdGlvbiBpbnNlcnRNYXJrZXIoaWQpIHtcbiAgICB2YXIgcHJldiA9IG1hcmtlcnNbaWRdO1xuICAgIGlmIChwcmV2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cblxuICAgIG1hcmtlcnNbaWRdID0gbWFrZVRleHROb2RlKGVsLm93bmVyRG9jdW1lbnQsIGlkKTtcbiAgICBlbC5hcHBlbmRDaGlsZChtYXJrZXJzW2lkXSk7XG4gICAgbmFtZXNbaWRdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHJldHVybiBtYXJrZXJzW2lkXTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhpZCwgY3NzUnVsZXMsIG5hbWUpIHtcbiAgICB2YXIgbWFya2VyID0gaW5zZXJ0TWFya2VyKGlkKTtcbiAgICB2YXIgaW1wb3J0UnVsZXMgPSBbXTtcbiAgICB2YXIgY3NzUnVsZXNTaXplID0gY3NzUnVsZXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjc3NSdWxlc1NpemU7IGkgKz0gMSkge1xuICAgICAgdmFyIHJ1bGUgPSBjc3NSdWxlc1tpXTtcbiAgICAgIHZhciBtYXlIYXZlSW1wb3J0ID0gZXh0cmFjdEltcG9ydDtcbiAgICAgIGlmIChtYXlIYXZlSW1wb3J0ICYmIHJ1bGUuaW5kZXhPZignQGltcG9ydCcpICE9PSAtMSkge1xuICAgICAgICBpbXBvcnRSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF5SGF2ZUltcG9ydCA9IGZhbHNlO1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gaSA9PT0gY3NzUnVsZXNTaXplIC0gMSA/ICcnIDogJyAnO1xuICAgICAgICBtYXJrZXIuYXBwZW5kRGF0YSgnJyArIHJ1bGUgKyBzZXBhcmF0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFkZE5hbWVGb3JJZChuYW1lcywgaWQsIG5hbWUpO1xuXG4gICAgaWYgKGV4dHJhY3RJbXBvcnQgJiYgaW1wb3J0UnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdXNlZEltcG9ydFJ1bGVUYWcgPSB0cnVlO1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgZ2V0SW1wb3J0UnVsZVRhZygpLmluc2VydFJ1bGVzKGlkICsgJy1pbXBvcnQnLCBpbXBvcnRSdWxlcyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmVSdWxlcyA9IGZ1bmN0aW9uIHJlbW92ZVJ1bGVzKGlkKSB7XG4gICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaWRdO1xuICAgIGlmIChtYXJrZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgLyogY3JlYXRlIG5ldyBlbXB0eSB0ZXh0IG5vZGUgYW5kIHJlcGxhY2UgdGhlIGN1cnJlbnQgb25lICovXG4gICAgdmFyIG5ld01hcmtlciA9IG1ha2VUZXh0Tm9kZShlbC5vd25lckRvY3VtZW50LCBpZCk7XG4gICAgZWwucmVwbGFjZUNoaWxkKG5ld01hcmtlciwgbWFya2VyKTtcbiAgICBtYXJrZXJzW2lkXSA9IG5ld01hcmtlcjtcbiAgICByZXNldElkTmFtZXMobmFtZXMsIGlkKTtcblxuICAgIGlmIChleHRyYWN0SW1wb3J0ICYmIHVzZWRJbXBvcnRSdWxlVGFnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBnZXRJbXBvcnRSdWxlVGFnKCkucmVtb3ZlUnVsZXMoaWQgKyAnLWltcG9ydCcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3NzID0gZnVuY3Rpb24gY3NzKCkge1xuICAgIHZhciBzdHIgPSAnJztcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKHZhciBpZCBpbiBtYXJrZXJzKSB7XG4gICAgICBzdHIgKz0gbWFya2Vyc1tpZF0uZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcig1KTtcbiAgICB9LFxuXG4gICAgY3NzOiBjc3MsXG4gICAgZ2V0SWRzOiBnZXRJZHNGcm9tTWFya2Vyc0ZhY3RvcnkobWFya2VycyksXG4gICAgaGFzTmFtZUZvcklkOiBoYXNOYW1lRm9ySWQobmFtZXMpLFxuICAgIGluc2VydE1hcmtlcjogaW5zZXJ0TWFya2VyLFxuICAgIGluc2VydFJ1bGVzOiBpbnNlcnRSdWxlcyxcbiAgICByZW1vdmVSdWxlczogcmVtb3ZlUnVsZXMsXG4gICAgc2VhbGVkOiBmYWxzZSxcbiAgICBzdHlsZVRhZzogZWwsXG4gICAgdG9FbGVtZW50OiB3cmFwQXNFbGVtZW50KGNzcywgbmFtZXMpLFxuICAgIHRvSFRNTDogd3JhcEFzSHRtbFRhZyhjc3MsIG5hbWVzKVxuICB9O1xufTtcblxudmFyIG1ha2VTZXJ2ZXJUYWcgPSBmdW5jdGlvbiBtYWtlU2VydmVyVGFnKG5hbWVzQXJnLCBtYXJrZXJzQXJnKSB7XG4gIHZhciBuYW1lcyA9IG5hbWVzQXJnID09PSB1bmRlZmluZWQgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbmFtZXNBcmc7XG4gIHZhciBtYXJrZXJzID0gbWFya2Vyc0FyZyA9PT0gdW5kZWZpbmVkID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IG1hcmtlcnNBcmc7XG5cbiAgdmFyIGluc2VydE1hcmtlciA9IGZ1bmN0aW9uIGluc2VydE1hcmtlcihpZCkge1xuICAgIHZhciBwcmV2ID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmtlcnNbaWRdID0gWycnXTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhpZCwgY3NzUnVsZXMsIG5hbWUpIHtcbiAgICB2YXIgbWFya2VyID0gaW5zZXJ0TWFya2VyKGlkKTtcbiAgICBtYXJrZXJbMF0gKz0gY3NzUnVsZXMuam9pbignICcpO1xuICAgIGFkZE5hbWVGb3JJZChuYW1lcywgaWQsIG5hbWUpO1xuICB9O1xuXG4gIHZhciByZW1vdmVSdWxlcyA9IGZ1bmN0aW9uIHJlbW92ZVJ1bGVzKGlkKSB7XG4gICAgdmFyIG1hcmtlciA9IG1hcmtlcnNbaWRdO1xuICAgIGlmIChtYXJrZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIG1hcmtlclswXSA9ICcnO1xuICAgIHJlc2V0SWROYW1lcyhuYW1lcywgaWQpO1xuICB9O1xuXG4gIHZhciBjc3MgPSBmdW5jdGlvbiBjc3MoKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKHZhciBpZCBpbiBtYXJrZXJzKSB7XG4gICAgICB2YXIgY3NzRm9ySWQgPSBtYXJrZXJzW2lkXVswXTtcbiAgICAgIGlmIChjc3NGb3JJZCkge1xuICAgICAgICBzdHIgKz0gbWFrZVRleHRNYXJrZXIoaWQpICsgY3NzRm9ySWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgdmFyIGNsb25lID0gZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgdmFyIG5hbWVzQ2xvbmUgPSBjbG9uZU5hbWVzKG5hbWVzKTtcbiAgICB2YXIgbWFya2Vyc0Nsb25lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKHZhciBpZCBpbiBtYXJrZXJzKSB7XG4gICAgICBtYXJrZXJzQ2xvbmVbaWRdID0gW21hcmtlcnNbaWRdWzBdXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZVNlcnZlclRhZyhuYW1lc0Nsb25lLCBtYXJrZXJzQ2xvbmUpO1xuICB9O1xuXG4gIHZhciB0YWcgPSB7XG4gICAgY2xvbmU6IGNsb25lLFxuICAgIGNzczogY3NzLFxuICAgIGdldElkczogZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5KG1hcmtlcnMpLFxuICAgIGhhc05hbWVGb3JJZDogaGFzTmFtZUZvcklkKG5hbWVzKSxcbiAgICBpbnNlcnRNYXJrZXI6IGluc2VydE1hcmtlcixcbiAgICBpbnNlcnRSdWxlczogaW5zZXJ0UnVsZXMsXG4gICAgcmVtb3ZlUnVsZXM6IHJlbW92ZVJ1bGVzLFxuICAgIHNlYWxlZDogZmFsc2UsXG4gICAgc3R5bGVUYWc6IG51bGwsXG4gICAgdG9FbGVtZW50OiB3cmFwQXNFbGVtZW50KGNzcywgbmFtZXMpLFxuICAgIHRvSFRNTDogd3JhcEFzSHRtbFRhZyhjc3MsIG5hbWVzKVxuICB9O1xuXG4gIHJldHVybiB0YWc7XG59O1xuXG52YXIgbWFrZVRhZyA9IGZ1bmN0aW9uIG1ha2VUYWcodGFyZ2V0LCB0YWdFbCwgZm9yY2VTZXJ2ZXIsIGluc2VydEJlZm9yZSwgZ2V0SW1wb3J0UnVsZVRhZykge1xuICBpZiAoSVNfQlJPV1NFUiAmJiAhZm9yY2VTZXJ2ZXIpIHtcbiAgICB2YXIgZWwgPSBtYWtlU3R5bGVUYWcodGFyZ2V0LCB0YWdFbCwgaW5zZXJ0QmVmb3JlKTtcblxuICAgIGlmIChESVNBQkxFX1NQRUVEWSkge1xuICAgICAgcmV0dXJuIG1ha2VCcm93c2VyVGFnKGVsLCBnZXRJbXBvcnRSdWxlVGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1ha2VTcGVlZHlUYWcoZWwsIGdldEltcG9ydFJ1bGVUYWcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYWtlU2VydmVyVGFnKCk7XG59O1xuXG52YXIgcmVoeWRyYXRlID0gZnVuY3Rpb24gcmVoeWRyYXRlKHRhZywgZWxzLCBleHRyYWN0ZWQpIHtcbiAgLyogYWRkIGFsbCBleHRyYWN0ZWQgY29tcG9uZW50cyB0byB0aGUgbmV3IHRhZyAqL1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXh0cmFjdGVkLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgdmFyIF9leHRyYWN0ZWQkaSA9IGV4dHJhY3RlZFtpXSxcbiAgICAgICAgY29tcG9uZW50SWQgPSBfZXh0cmFjdGVkJGkuY29tcG9uZW50SWQsXG4gICAgICAgIGNzc0Zyb21ET00gPSBfZXh0cmFjdGVkJGkuY3NzRnJvbURPTTtcblxuICAgIHZhciBjc3NSdWxlcyA9IHNwbGl0QnlSdWxlcyhjc3NGcm9tRE9NKTtcbiAgICB0YWcuaW5zZXJ0UnVsZXMoY29tcG9uZW50SWQsIGNzc1J1bGVzKTtcbiAgfVxuXG4gIC8qIHJlbW92ZSBvbGQgSFRNTFN0eWxlRWxlbWVudHMsIHNpbmNlIHRoZXkgaGF2ZSBiZWVuIHJlaHlkcmF0ZWQgKi9cbiAgZm9yICh2YXIgX2kgPSAwLCBfbGVuID0gZWxzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSArPSAxKSB7XG4gICAgdmFyIGVsID0gZWxzW19pXTtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBcblxudmFyIFNQTElUX1JFR0VYID0gL1xccysvO1xuXG4vKiBkZXRlcm1pbmUgdGhlIG1heGltdW0gbnVtYmVyIG9mIGNvbXBvbmVudHMgYmVmb3JlIHRhZ3MgYXJlIHNoYXJkZWQgKi9cbnZhciBNQVhfU0laRSA9IHZvaWQgMDtcbmlmIChJU19CUk9XU0VSKSB7XG4gIC8qIGluIHNwZWVkeSBtb2RlIHdlIGNhbiBrZWVwIGEgbG90IG1vcmUgcnVsZXMgaW4gYSBzaGVldCBiZWZvcmUgYSBzbG93ZG93biBjYW4gYmUgZXhwZWN0ZWQgKi9cbiAgTUFYX1NJWkUgPSBESVNBQkxFX1NQRUVEWSA/IDQwIDogMTAwMDtcbn0gZWxzZSB7XG4gIC8qIGZvciBzZXJ2ZXJzIHdlIGRvIG5vdCBuZWVkIHRvIHNoYXJkIGF0IGFsbCAqL1xuICBNQVhfU0laRSA9IC0xO1xufVxuXG52YXIgc2hlZXRSdW5uaW5nSWQgPSAwO1xudmFyIG1hc3RlciA9IHZvaWQgMDtcblxudmFyIFN0eWxlU2hlZXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyogYSBtYXAgZnJvbSBpZHMgdG8gdGFncyAqL1xuXG4gIC8qIGRlZmVycmVkIHJ1bGVzIGZvciBhIGdpdmVuIGlkICovXG5cbiAgLyogdGhpcyBpcyB1c2VkIGZvciBub3QgcmVpbmplY3RpbmcgcnVsZXMgdmlhIGhhc05hbWVGb3JJZCgpICovXG5cbiAgLyogd2hlbiBydWxlcyBmb3IgYW4gaWQgYXJlIHJlbW92ZWQgdXNpbmcgcmVtb3ZlKCkgd2UgaGF2ZSB0byBpZ25vcmUgcmVoeWRyYXRlZE5hbWVzIGZvciBpdCAqL1xuXG4gIC8qIGEgbGlzdCBvZiB0YWdzIGJlbG9uZ2luZyB0byB0aGlzIFN0eWxlU2hlZXQgKi9cblxuICAvKiBhIHRhZyBmb3IgaW1wb3J0IHJ1bGVzICovXG5cbiAgLyogY3VycmVudCBjYXBhY2l0eSB1bnRpbCBhIG5ldyB0YWcgbXVzdCBiZSBjcmVhdGVkICovXG5cbiAgLyogY2hpbGRyZW4gKGFrYSBjbG9uZXMpIG9mIHRoaXMgU3R5bGVTaGVldCBpbmhlcml0aW5nIGFsbCBhbmQgZnV0dXJlIGluamVjdGlvbnMgKi9cblxuICBmdW5jdGlvbiBTdHlsZVNoZWV0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBJU19CUk9XU0VSID8gZG9jdW1lbnQuaGVhZCA6IG51bGw7XG4gICAgdmFyIGZvcmNlU2VydmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZVNoZWV0KTtcblxuICAgIHRoaXMuZ2V0SW1wb3J0UnVsZVRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpbXBvcnRSdWxlVGFnID0gX3RoaXMuaW1wb3J0UnVsZVRhZztcblxuICAgICAgaWYgKGltcG9ydFJ1bGVUYWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaW1wb3J0UnVsZVRhZztcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0VGFnID0gX3RoaXMudGFnc1swXTtcbiAgICAgIHZhciBpbnNlcnRCZWZvcmUgPSB0cnVlO1xuXG4gICAgICByZXR1cm4gX3RoaXMuaW1wb3J0UnVsZVRhZyA9IG1ha2VUYWcoX3RoaXMudGFyZ2V0LCBmaXJzdFRhZyA/IGZpcnN0VGFnLnN0eWxlVGFnIDogbnVsbCwgX3RoaXMuZm9yY2VTZXJ2ZXIsIGluc2VydEJlZm9yZSk7XG4gICAgfTtcblxuICAgIHNoZWV0UnVubmluZ0lkICs9IDE7XG4gICAgdGhpcy5pZCA9IHNoZWV0UnVubmluZ0lkO1xuICAgIHRoaXMuZm9yY2VTZXJ2ZXIgPSBmb3JjZVNlcnZlcjtcbiAgICB0aGlzLnRhcmdldCA9IGZvcmNlU2VydmVyID8gbnVsbCA6IHRhcmdldDtcbiAgICB0aGlzLnRhZ01hcCA9IHt9O1xuICAgIHRoaXMuZGVmZXJyZWQgPSB7fTtcbiAgICB0aGlzLnJlaHlkcmF0ZWROYW1lcyA9IHt9O1xuICAgIHRoaXMuaWdub3JlUmVoeWRyYXRlZE5hbWVzID0ge307XG4gICAgdGhpcy50YWdzID0gW107XG4gICAgdGhpcy5jYXBhY2l0eSA9IDE7XG4gICAgdGhpcy5jbG9uZXMgPSBbXTtcbiAgfVxuXG4gIC8qIHJlaHlkcmF0ZSBhbGwgU1NSJ2Qgc3R5bGUgdGFncyAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUucmVoeWRyYXRlID0gZnVuY3Rpb24gcmVoeWRyYXRlJCQxKCkge1xuICAgIGlmICghSVNfQlJPV1NFUiB8fCB0aGlzLmZvcmNlU2VydmVyKSByZXR1cm4gdGhpcztcblxuICAgIHZhciBlbHMgPSBbXTtcbiAgICB2YXIgZXh0cmFjdGVkID0gW107XG4gICAgdmFyIGlzU3RyZWFtZWQgPSBmYWxzZTtcblxuICAgIC8qIHJldHJpZXZlIGFsbCBvZiBvdXIgU1NSIHN0eWxlIGVsZW1lbnRzIGZyb20gdGhlIERPTSAqL1xuICAgIHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlWycgKyBTQ19BVFRSICsgJ11bJyArIFNDX1ZFUlNJT05fQVRUUiArICc9XCInICsgXCI0LjQuMVwiICsgJ1wiXScpO1xuXG4gICAgdmFyIG5vZGVzU2l6ZSA9IG5vZGVzLmxlbmd0aDtcblxuICAgIC8qIGFib3J0IHJlaHlkcmF0aW9uIGlmIG5vIHByZXZpb3VzIHN0eWxlIHRhZ3Mgd2VyZSBmb3VuZCAqL1xuICAgIGlmICghbm9kZXNTaXplKSByZXR1cm4gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNTaXplOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbCA9IG5vZGVzW2ldO1xuXG4gICAgICAvKiBjaGVjayBpZiBzdHlsZSB0YWcgaXMgYSBzdHJlYW1lZCB0YWcgKi9cbiAgICAgIGlmICghaXNTdHJlYW1lZCkgaXNTdHJlYW1lZCA9ICEhZWwuZ2V0QXR0cmlidXRlKFNDX1NUUkVBTV9BVFRSKTtcblxuICAgICAgLyogcmV0cmlldmUgYWxsIGNvbXBvbmVudCBuYW1lcyAqL1xuICAgICAgdmFyIGVsTmFtZXMgPSAoZWwuZ2V0QXR0cmlidXRlKFNDX0FUVFIpIHx8ICcnKS50cmltKCkuc3BsaXQoU1BMSVRfUkVHRVgpO1xuICAgICAgdmFyIGVsTmFtZXNTaXplID0gZWxOYW1lcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBqID0gMCwgbmFtZTsgaiA8IGVsTmFtZXNTaXplOyBqICs9IDEpIHtcbiAgICAgICAgbmFtZSA9IGVsTmFtZXNbal07XG4gICAgICAgIC8qIGFkZCByZWh5ZHJhdGVkIG5hbWUgdG8gc2hlZXQgdG8gYXZvaWQgcmUtYWRkaW5nIHN0eWxlcyAqL1xuICAgICAgICB0aGlzLnJlaHlkcmF0ZWROYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIGV4dHJhY3QgYWxsIGNvbXBvbmVudHMgYW5kIHRoZWlyIENTUyAqL1xuICAgICAgZXh0cmFjdGVkLnB1c2guYXBwbHkoZXh0cmFjdGVkLCBleHRyYWN0Q29tcHMoZWwudGV4dENvbnRlbnQpKTtcblxuICAgICAgLyogc3RvcmUgb3JpZ2luYWwgSFRNTFN0eWxlRWxlbWVudCAqL1xuICAgICAgZWxzLnB1c2goZWwpO1xuICAgIH1cblxuICAgIC8qIGFib3J0IHJlaHlkcmF0aW9uIGlmIG5vdGhpbmcgd2FzIGV4dHJhY3RlZCAqL1xuICAgIHZhciBleHRyYWN0ZWRTaXplID0gZXh0cmFjdGVkLmxlbmd0aDtcbiAgICBpZiAoIWV4dHJhY3RlZFNpemUpIHJldHVybiB0aGlzO1xuXG4gICAgLyogY3JlYXRlIGEgdGFnIHRvIGJlIHVzZWQgZm9yIHJlaHlkcmF0aW9uICovXG4gICAgdmFyIHRhZyA9IHRoaXMubWFrZVRhZyhudWxsKTtcblxuICAgIHJlaHlkcmF0ZSh0YWcsIGVscywgZXh0cmFjdGVkKTtcblxuICAgIC8qIHJlc2V0IGNhcGFjaXR5IGFuZCBhZGp1c3QgTUFYX1NJWkUgYnkgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgcmVoeWRyYXRpb24gKi9cbiAgICB0aGlzLmNhcGFjaXR5ID0gTWF0aC5tYXgoMSwgTUFYX1NJWkUgLSBleHRyYWN0ZWRTaXplKTtcbiAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuXG4gICAgLyogcmV0cmlldmUgYWxsIGNvbXBvbmVudCBpZHMgKi9cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgZXh0cmFjdGVkU2l6ZTsgX2ogKz0gMSkge1xuICAgICAgdGhpcy50YWdNYXBbZXh0cmFjdGVkW19qXS5jb21wb25lbnRJZF0gPSB0YWc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyogcmV0cmlldmUgYSBcIm1hc3RlclwiIGluc3RhbmNlIG9mIFN0eWxlU2hlZXQgd2hpY2ggaXMgdHlwaWNhbGx5IHVzZWQgd2hlbiBubyBvdGhlciBpcyBhdmFpbGFibGVcbiAgICogVGhlIG1hc3RlciBTdHlsZVNoZWV0IGlzIHRhcmdldGVkIGJ5IGNyZWF0ZUdsb2JhbFN0eWxlLCBrZXlmcmFtZXMsIGFuZCBjb21wb25lbnRzIG91dHNpZGUgb2YgYW55XG4gICAgKiBTdHlsZVNoZWV0TWFuYWdlcidzIGNvbnRleHQgKi9cblxuXG4gIC8qIHJlc2V0IHRoZSBpbnRlcm5hbCBcIm1hc3RlclwiIGluc3RhbmNlICovXG4gIFN0eWxlU2hlZXQucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2YXIgZm9yY2VTZXJ2ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgbWFzdGVyID0gbmV3IFN0eWxlU2hlZXQodW5kZWZpbmVkLCBmb3JjZVNlcnZlcikucmVoeWRyYXRlKCk7XG4gIH07XG5cbiAgLyogYWRkcyBcImNoaWxkcmVuXCIgdG8gdGhlIFN0eWxlU2hlZXQgdGhhdCBpbmhlcml0IGFsbCBvZiB0aGUgcGFyZW50cycgcnVsZXNcbiAgICogd2hpbGUgdGhlaXIgb3duIHJ1bGVzIGRvIG5vdCBhZmZlY3QgdGhlIHBhcmVudCAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICB2YXIgc2hlZXQgPSBuZXcgU3R5bGVTaGVldCh0aGlzLnRhcmdldCwgdGhpcy5mb3JjZVNlcnZlcik7XG5cbiAgICAvKiBhZGQgdG8gY2xvbmUgYXJyYXkgKi9cbiAgICB0aGlzLmNsb25lcy5wdXNoKHNoZWV0KTtcblxuICAgIC8qIGNsb25lIGFsbCB0YWdzICovXG4gICAgc2hlZXQudGFncyA9IHRoaXMudGFncy5tYXAoZnVuY3Rpb24gKHRhZykge1xuICAgICAgdmFyIGlkcyA9IHRhZy5nZXRJZHMoKTtcbiAgICAgIHZhciBuZXdUYWcgPSB0YWcuY2xvbmUoKTtcblxuICAgICAgLyogcmVjb25zdHJ1Y3QgdGFnTWFwICovXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzaGVldC50YWdNYXBbaWRzW2ldXSA9IG5ld1RhZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1RhZztcbiAgICB9KTtcblxuICAgIC8qIGNsb25lIG90aGVyIG1hcHMgKi9cbiAgICBzaGVldC5yZWh5ZHJhdGVkTmFtZXMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5yZWh5ZHJhdGVkTmFtZXMpO1xuICAgIHNoZWV0LmRlZmVycmVkID0gX2V4dGVuZHMoe30sIHRoaXMuZGVmZXJyZWQpO1xuXG4gICAgcmV0dXJuIHNoZWV0O1xuICB9O1xuXG4gIC8qIGZvcmNlIFN0eWxlU2hlZXQgdG8gY3JlYXRlIGEgbmV3IHRhZyBvbiB0aGUgbmV4dCBpbmplY3Rpb24gKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLnNlYWxBbGxUYWdzID0gZnVuY3Rpb24gc2VhbEFsbFRhZ3MoKSB7XG4gICAgdGhpcy5jYXBhY2l0eSA9IDE7XG5cbiAgICB0aGlzLnRhZ3MuZm9yRWFjaChmdW5jdGlvbiAodGFnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHRhZy5zZWFsZWQgPSB0cnVlO1xuICAgIH0pO1xuICB9O1xuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLm1ha2VUYWcgPSBmdW5jdGlvbiBtYWtlVGFnJCQxKHRhZykge1xuICAgIHZhciBsYXN0RWwgPSB0YWcgPyB0YWcuc3R5bGVUYWcgOiBudWxsO1xuICAgIHZhciBpbnNlcnRCZWZvcmUgPSBmYWxzZTtcblxuICAgIHJldHVybiBtYWtlVGFnKHRoaXMudGFyZ2V0LCBsYXN0RWwsIHRoaXMuZm9yY2VTZXJ2ZXIsIGluc2VydEJlZm9yZSwgdGhpcy5nZXRJbXBvcnRSdWxlVGFnKTtcbiAgfTtcblxuICAvKiBnZXQgYSB0YWcgZm9yIGEgZ2l2ZW4gY29tcG9uZW50SWQsIGFzc2lnbiB0aGUgY29tcG9uZW50SWQgdG8gb25lLCBvciBzaGFyZCAqL1xuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5nZXRUYWdGb3JJZCA9IGZ1bmN0aW9uIGdldFRhZ0ZvcklkKGlkKSB7XG4gICAgLyogc2ltcGx5IHJldHVybiBhIHRhZywgd2hlbiB0aGUgY29tcG9uZW50SWQgd2FzIGFscmVhZHkgYXNzaWduZWQgb25lICovXG4gICAgdmFyIHByZXYgPSB0aGlzLnRhZ01hcFtpZF07XG4gICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCAmJiAhcHJldi5zZWFsZWQpIHtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cblxuICAgIHZhciB0YWcgPSB0aGlzLnRhZ3NbdGhpcy50YWdzLmxlbmd0aCAtIDFdO1xuXG4gICAgLyogc2hhcmQgKGNyZWF0ZSBhIG5ldyB0YWcpIGlmIHRoZSB0YWcgaXMgZXhoYXVzdGVkIChTZWUgTUFYX1NJWkUpICovXG4gICAgdGhpcy5jYXBhY2l0eSAtPSAxO1xuXG4gICAgaWYgKHRoaXMuY2FwYWNpdHkgPT09IDApIHtcbiAgICAgIHRoaXMuY2FwYWNpdHkgPSBNQVhfU0laRTtcbiAgICAgIHRhZyA9IHRoaXMubWFrZVRhZyh0YWcpO1xuICAgICAgdGhpcy50YWdzLnB1c2godGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50YWdNYXBbaWRdID0gdGFnO1xuICB9O1xuXG4gIC8qIG1haW5seSBmb3IgY3JlYXRlR2xvYmFsU3R5bGUgdG8gY2hlY2sgZm9yIGl0cyBpZCAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuaGFzSWQgPSBmdW5jdGlvbiBoYXNJZChpZCkge1xuICAgIHJldHVybiB0aGlzLnRhZ01hcFtpZF0gIT09IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKiBjYWNoaW5nIGxheWVyIGNoZWNraW5nIGlkK25hbWUgdG8gYWxyZWFkeSBoYXZlIGEgY29ycmVzcG9uZGluZyB0YWcgYW5kIGluamVjdGVkIHJ1bGVzICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5oYXNOYW1lRm9ySWQgPSBmdW5jdGlvbiBoYXNOYW1lRm9ySWQoaWQsIG5hbWUpIHtcbiAgICAvKiBleGNlcHRpb24gZm9yIHJlaHlkcmF0ZWQgbmFtZXMgd2hpY2ggYXJlIGNoZWNrZWQgc2VwYXJhdGVseSAqL1xuICAgIGlmICh0aGlzLmlnbm9yZVJlaHlkcmF0ZWROYW1lc1tpZF0gPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJlaHlkcmF0ZWROYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IHRoaXMudGFnTWFwW2lkXTtcbiAgICByZXR1cm4gdGFnICE9PSB1bmRlZmluZWQgJiYgdGFnLmhhc05hbWVGb3JJZChpZCwgbmFtZSk7XG4gIH07XG5cbiAgLyogcmVnaXN0ZXJzIGEgY29tcG9uZW50SWQgYW5kIHJlZ2lzdGVycyBpdCBvbiBpdHMgdGFnICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWZlcnJlZEluamVjdCA9IGZ1bmN0aW9uIGRlZmVycmVkSW5qZWN0KGlkLCBjc3NSdWxlcykge1xuICAgIC8qIGRvbid0IGluamVjdCB3aGVuIHRoZSBpZCBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQgKi9cbiAgICBpZiAodGhpcy50YWdNYXBbaWRdICE9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIHZhciBjbG9uZXMgPSB0aGlzLmNsb25lcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjbG9uZXNbaV0uZGVmZXJyZWRJbmplY3QoaWQsIGNzc1J1bGVzKTtcbiAgICB9XG5cbiAgICB0aGlzLmdldFRhZ0ZvcklkKGlkKS5pbnNlcnRNYXJrZXIoaWQpO1xuICAgIHRoaXMuZGVmZXJyZWRbaWRdID0gY3NzUnVsZXM7XG4gIH07XG5cbiAgLyogaW5qZWN0cyBydWxlcyBmb3IgYSBnaXZlbiBpZCB3aXRoIGEgbmFtZSB0aGF0IHdpbGwgbmVlZCB0byBiZSBjYWNoZWQgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLmluamVjdCA9IGZ1bmN0aW9uIGluamVjdChpZCwgY3NzUnVsZXMsIG5hbWUpIHtcbiAgICB2YXIgY2xvbmVzID0gdGhpcy5jbG9uZXM7XG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjbG9uZXNbaV0uaW5qZWN0KGlkLCBjc3NSdWxlcywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IHRoaXMuZ2V0VGFnRm9ySWQoaWQpO1xuXG4gICAgLyogYWRkIGRlZmVycmVkIHJ1bGVzIGZvciBjb21wb25lbnQgKi9cbiAgICBpZiAodGhpcy5kZWZlcnJlZFtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQ29tYmluZSBwYXNzZWQgY3NzUnVsZXMgd2l0aCBwcmV2aW91c2x5IGRlZmVycmVkIENTUyBydWxlc1xuICAgICAgLy8gTk9URTogV2UgY2Fubm90IG11dGF0ZSB0aGUgZGVmZXJyZWQgYXJyYXkgaXRzZWxmIGFzIGFsbCBjbG9uZXNcbiAgICAgIC8vIGRvIHRoZSBzYW1lIChzZWUgY2xvbmVzW2ldLmluamVjdClcbiAgICAgIHZhciBydWxlcyA9IHRoaXMuZGVmZXJyZWRbaWRdLmNvbmNhdChjc3NSdWxlcyk7XG4gICAgICB0YWcuaW5zZXJ0UnVsZXMoaWQsIHJ1bGVzLCBuYW1lKTtcblxuICAgICAgdGhpcy5kZWZlcnJlZFtpZF0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5pbnNlcnRSdWxlcyhpZCwgY3NzUnVsZXMsIG5hbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKiByZW1vdmVzIGFsbCBydWxlcyBmb3IgYSBnaXZlbiBpZCwgd2hpY2ggZG9lc24ndCByZW1vdmUgaXRzIG1hcmtlciBidXQgcmVzZXRzIGl0ICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoaWQpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWdNYXBbaWRdO1xuICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdmFyIGNsb25lcyA9IHRoaXMuY2xvbmVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNsb25lc1tpXS5yZW1vdmUoaWQpO1xuICAgIH1cblxuICAgIC8qIHJlbW92ZSBhbGwgcnVsZXMgZnJvbSB0aGUgdGFnICovXG4gICAgdGFnLnJlbW92ZVJ1bGVzKGlkKTtcblxuICAgIC8qIGlnbm9yZSBwb3NzaWJsZSByZWh5ZHJhdGVkIG5hbWVzICovXG4gICAgdGhpcy5pZ25vcmVSZWh5ZHJhdGVkTmFtZXNbaWRdID0gdHJ1ZTtcblxuICAgIC8qIGRlbGV0ZSBwb3NzaWJsZSBkZWZlcnJlZCBydWxlcyAqL1xuICAgIHRoaXMuZGVmZXJyZWRbaWRdID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLnRvSFRNTCA9IGZ1bmN0aW9uIHRvSFRNTCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgICByZXR1cm4gdGFnLnRvSFRNTCgpO1xuICAgIH0pLmpvaW4oJycpO1xuICB9O1xuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLnRvUmVhY3RFbGVtZW50cyA9IGZ1bmN0aW9uIHRvUmVhY3RFbGVtZW50cygpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkO1xuXG5cbiAgICByZXR1cm4gdGhpcy50YWdzLm1hcChmdW5jdGlvbiAodGFnLCBpKSB7XG4gICAgICB2YXIga2V5ID0gJ3NjLScgKyBpZCArICctJyArIGk7XG4gICAgICByZXR1cm4gY2xvbmVFbGVtZW50KHRhZy50b0VsZW1lbnQoKSwgeyBrZXk6IGtleSB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBjcmVhdGVDbGFzcyhTdHlsZVNoZWV0LCBudWxsLCBbe1xuICAgIGtleTogJ21hc3RlcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gbWFzdGVyIHx8IChtYXN0ZXIgPSBuZXcgU3R5bGVTaGVldCgpLnJlaHlkcmF0ZSgpKTtcbiAgICB9XG5cbiAgICAvKiBOT1RFOiBUaGlzIGlzIGp1c3QgZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHdpdGggamVzdC1zdHlsZWQtY29tcG9uZW50cyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdpbnN0YW5jZScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gU3R5bGVTaGVldC5tYXN0ZXI7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdHlsZVNoZWV0O1xufSgpO1xuXG4vLyBcblxudmFyIEtleWZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gS2V5ZnJhbWVzKG5hbWUsIHJ1bGVzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEtleWZyYW1lcyk7XG5cbiAgICB0aGlzLmluamVjdCA9IGZ1bmN0aW9uIChzdHlsZVNoZWV0KSB7XG4gICAgICBpZiAoIXN0eWxlU2hlZXQuaGFzTmFtZUZvcklkKF90aGlzLmlkLCBfdGhpcy5uYW1lKSkge1xuICAgICAgICBzdHlsZVNoZWV0LmluamVjdChfdGhpcy5pZCwgX3RoaXMucnVsZXMsIF90aGlzLm5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcigxMiwgU3RyaW5nKF90aGlzLm5hbWUpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG5cbiAgICB0aGlzLmlkID0gJ3NjLWtleWZyYW1lcy0nICsgbmFtZTtcbiAgfVxuXG4gIEtleWZyYW1lcy5wcm90b3R5cGUuZ2V0TmFtZSA9IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVzO1xufSgpO1xuXG4vLyBcblxuLyoqXG4gKiBpbmxpbmVkIHZlcnNpb24gb2ZcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2ZianMvc3JjL2NvcmUvaHlwaGVuYXRlU3R5bGVOYW1lLmpzXG4gKi9cblxudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSh1cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxuLy8gXG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjg3YWFiZGZlMWI3NDYxZTczMzFhYmIzNjAxZDllNmJiMjc1NDRiYy9wYWNrYWdlcy9yZWFjdC1kb20vc3JjL3NoYXJlZC9kYW5nZXJvdXNTdHlsZVZhbHVlLmpzXG5mdW5jdGlvbiBhZGRVbml0SWZOZWVkZWQobmFtZSwgdmFsdWUpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FtaWxhamFjay9lc2xpbnQtcGx1Z2luLWZsb3d0eXBlLWVycm9ycy9pc3N1ZXMvMTMzXG4gIC8vICRGbG93Rml4TWVcbiAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShuYW1lIGluIHVuaXRsZXNzKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gU3RyaW5nKHZhbHVlKS50cmltKCk7XG59XG5cbi8vIFxuXG4vKipcbiAqIEl0J3MgZmFsc2lzaCBub3QgZmFsc3kgYmVjYXVzZSAwIGlzIGFsbG93ZWQuXG4gKi9cbnZhciBpc0ZhbHNpc2ggPSBmdW5jdGlvbiBpc0ZhbHNpc2goY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rID09PSB1bmRlZmluZWQgfHwgY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IGZhbHNlIHx8IGNodW5rID09PSAnJztcbn07XG5cbnZhciBvYmpUb0Nzc0FycmF5ID0gZnVuY3Rpb24gb2JqVG9Dc3NBcnJheShvYmosIHByZXZLZXkpIHtcbiAgdmFyIHJ1bGVzID0gW107XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaXNGYWxzaXNoKG9ialtrZXldKSkge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob2JqW2tleV0pKSB7XG4gICAgICAgIHJ1bGVzLnB1c2guYXBwbHkocnVsZXMsIG9ialRvQ3NzQXJyYXkob2JqW2tleV0sIGtleSkpO1xuXG4gICAgICAgIHJldHVybiBydWxlcztcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvYmpba2V5XSkpIHtcbiAgICAgICAgcnVsZXMucHVzaChoeXBoZW5hdGVTdHlsZU5hbWUoa2V5KSArICc6Jywgb2JqW2tleV0sICc7Jyk7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgfVxuICAgICAgcnVsZXMucHVzaChoeXBoZW5hdGVTdHlsZU5hbWUoa2V5KSArICc6ICcgKyBhZGRVbml0SWZOZWVkZWQoa2V5LCBvYmpba2V5XSkgKyAnOycpO1xuICAgIH1cbiAgICByZXR1cm4gcnVsZXM7XG4gIH0pO1xuXG4gIHJldHVybiBwcmV2S2V5ID8gW3ByZXZLZXkgKyAnIHsnXS5jb25jYXQocnVsZXMsIFsnfSddKSA6IHJ1bGVzO1xufTtcblxuZnVuY3Rpb24gZmxhdHRlbihjaHVuaywgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaHVuaykpIHtcbiAgICB2YXIgcnVsZVNldCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNodW5rLmxlbmd0aCwgcmVzdWx0OyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHJlc3VsdCA9IGZsYXR0ZW4oY2h1bmtbaV0sIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSBjb250aW51ZTtlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHJ1bGVTZXQucHVzaC5hcHBseShydWxlU2V0LCByZXN1bHQpO2Vsc2UgcnVsZVNldC5wdXNoKHJlc3VsdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGVTZXQ7XG4gIH1cblxuICBpZiAoaXNGYWxzaXNoKGNodW5rKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyogSGFuZGxlIG90aGVyIGNvbXBvbmVudHMgKi9cbiAgaWYgKGlzU3R5bGVkQ29tcG9uZW50KGNodW5rKSkge1xuICAgIHJldHVybiAnLicgKyBjaHVuay5zdHlsZWRDb21wb25lbnRJZDtcbiAgfVxuXG4gIC8qIEVpdGhlciBleGVjdXRlIG9yIGRlZmVyIHRoZSBmdW5jdGlvbiAqL1xuICBpZiAoaXNGdW5jdGlvbihjaHVuaykpIHtcbiAgICBpZiAoaXNTdGF0ZWxlc3NGdW5jdGlvbihjaHVuaykgJiYgZXhlY3V0aW9uQ29udGV4dCkge1xuICAgICAgdmFyIF9yZXN1bHQgPSBjaHVuayhleGVjdXRpb25Db250ZXh0KTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNFbGVtZW50KF9yZXN1bHQpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihnZXRDb21wb25lbnROYW1lKGNodW5rKSArICcgaXMgbm90IGEgc3R5bGVkIGNvbXBvbmVudCBhbmQgY2Fubm90IGJlIHJlZmVycmVkIHRvIHZpYSBjb21wb25lbnQgc2VsZWN0b3IuIFNlZSBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9hZHZhbmNlZCNyZWZlcnJpbmctdG8tb3RoZXItY29tcG9uZW50cyBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxhdHRlbihfcmVzdWx0LCBleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KTtcbiAgICB9IGVsc2UgcmV0dXJuIGNodW5rO1xuICB9XG5cbiAgaWYgKGNodW5rIGluc3RhbmNlb2YgS2V5ZnJhbWVzKSB7XG4gICAgaWYgKHN0eWxlU2hlZXQpIHtcbiAgICAgIGNodW5rLmluamVjdChzdHlsZVNoZWV0KTtcbiAgICAgIHJldHVybiBjaHVuay5nZXROYW1lKCk7XG4gICAgfSBlbHNlIHJldHVybiBjaHVuaztcbiAgfVxuXG4gIC8qIEhhbmRsZSBvYmplY3RzICovXG4gIHJldHVybiBpc1BsYWluT2JqZWN0KGNodW5rKSA/IG9ialRvQ3NzQXJyYXkoY2h1bmspIDogY2h1bmsudG9TdHJpbmcoKTtcbn1cblxuLy8gXG5cbmZ1bmN0aW9uIGNzcyhzdHlsZXMpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGludGVycG9sYXRpb25zID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGludGVycG9sYXRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChpc0Z1bmN0aW9uKHN0eWxlcykgfHwgaXNQbGFpbk9iamVjdChzdHlsZXMpKSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHJldHVybiBmbGF0dGVuKGludGVybGVhdmUoRU1QVFlfQVJSQVksIFtzdHlsZXNdLmNvbmNhdChpbnRlcnBvbGF0aW9ucykpKTtcbiAgfVxuXG4gIC8vICRGbG93Rml4TWVcbiAgcmV0dXJuIGZsYXR0ZW4oaW50ZXJsZWF2ZShzdHlsZXMsIGludGVycG9sYXRpb25zKSk7XG59XG5cbi8vIFxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RXaXRoT3B0aW9ucyhjb21wb25lbnRDb25zdHJ1Y3RvciwgdGFnKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBFTVBUWV9PQkpFQ1Q7XG5cbiAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUodGFnKSkge1xuICAgIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoMSwgU3RyaW5nKHRhZykpO1xuICB9XG5cbiAgLyogVGhpcyBpcyBjYWxsYWJsZSBkaXJlY3RseSBhcyBhIHRlbXBsYXRlIGZ1bmN0aW9uICovXG4gIC8vICRGbG93Rml4TWU6IE5vdCB0eXBlZCB0byBhdm9pZCBkZXN0cnVjdHVyaW5nIGFyZ3VtZW50c1xuICB2YXIgdGVtcGxhdGVGdW5jdGlvbiA9IGZ1bmN0aW9uIHRlbXBsYXRlRnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudENvbnN0cnVjdG9yKHRhZywgb3B0aW9ucywgY3NzLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKSk7XG4gIH07XG5cbiAgLyogSWYgY29uZmlnIG1ldGhvZHMgYXJlIGNhbGxlZCwgd3JhcCB1cCBhIG5ldyB0ZW1wbGF0ZSBmdW5jdGlvbiBhbmQgbWVyZ2Ugb3B0aW9ucyAqL1xuICB0ZW1wbGF0ZUZ1bmN0aW9uLndpdGhDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdFdpdGhPcHRpb25zKGNvbXBvbmVudENvbnN0cnVjdG9yLCB0YWcsIF9leHRlbmRzKHt9LCBvcHRpb25zLCBjb25maWcpKTtcbiAgfTtcblxuICAvKiBNb2RpZnkvaW5qZWN0IG5ldyBwcm9wcyBhdCBydW50aW1lICovXG4gIHRlbXBsYXRlRnVuY3Rpb24uYXR0cnMgPSBmdW5jdGlvbiAoYXR0cnMpIHtcbiAgICByZXR1cm4gY29uc3RydWN0V2l0aE9wdGlvbnMoY29tcG9uZW50Q29uc3RydWN0b3IsIHRhZywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIGF0dHJzOiBBcnJheS5wcm90b3R5cGUuY29uY2F0KG9wdGlvbnMuYXR0cnMsIGF0dHJzKS5maWx0ZXIoQm9vbGVhbilcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIHRlbXBsYXRlRnVuY3Rpb247XG59XG5cbi8vIFxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L211cm11cmhhc2gtanMvYmxvYi9tYXN0ZXIvbXVybXVyaGFzaDJfZ2MuanNcbmZ1bmN0aW9uIG11cm11cmhhc2goYykge1xuICBmb3IgKHZhciBlID0gYy5sZW5ndGggfCAwLCBhID0gZSB8IDAsIGQgPSAwLCBiOyBlID49IDQ7KSB7XG4gICAgYiA9IGMuY2hhckNvZGVBdChkKSAmIDI1NSB8IChjLmNoYXJDb2RlQXQoKytkKSAmIDI1NSkgPDwgOCB8IChjLmNoYXJDb2RlQXQoKytkKSAmIDI1NSkgPDwgMTYgfCAoYy5jaGFyQ29kZUF0KCsrZCkgJiAyNTUpIDw8IDI0LCBiID0gMTU0MDQ4MzQ3NyAqIChiICYgNjU1MzUpICsgKCgxNTQwNDgzNDc3ICogKGIgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNiksIGIgXj0gYiA+Pj4gMjQsIGIgPSAxNTQwNDgzNDc3ICogKGIgJiA2NTUzNSkgKyAoKDE1NDA0ODM0NzcgKiAoYiA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSwgYSA9IDE1NDA0ODM0NzcgKiAoYSAmIDY1NTM1KSArICgoMTU0MDQ4MzQ3NyAqIChhID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpIF4gYiwgZSAtPSA0LCArK2Q7XG4gIH1cbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSAzOlxuICAgICAgYSBePSAoYy5jaGFyQ29kZUF0KGQgKyAyKSAmIDI1NSkgPDwgMTY7XG4gICAgY2FzZSAyOlxuICAgICAgYSBePSAoYy5jaGFyQ29kZUF0KGQgKyAxKSAmIDI1NSkgPDwgODtcbiAgICBjYXNlIDE6XG4gICAgICBhIF49IGMuY2hhckNvZGVBdChkKSAmIDI1NSwgYSA9IDE1NDA0ODM0NzcgKiAoYSAmIDY1NTM1KSArICgoMTU0MDQ4MzQ3NyAqIChhID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpO1xuICB9XG4gIGEgXj0gYSA+Pj4gMTM7XG4gIGEgPSAxNTQwNDgzNDc3ICogKGEgJiA2NTUzNSkgKyAoKDE1NDA0ODM0NzcgKiAoYSA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KTtcbiAgcmV0dXJuIChhIF4gYSA+Pj4gMTUpID4+PiAwO1xufVxuXG4vLyBcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyogVGhpcyBpcyB0aGUgXCJjYXBhY2l0eVwiIG9mIG91ciBhbHBoYWJldCBpLmUuIDJ4MjYgZm9yIGFsbCBsZXR0ZXJzIHBsdXMgdGhlaXIgY2FwaXRhbGlzZWRcbiAqIGNvdW50ZXJwYXJ0cyAqL1xudmFyIGNoYXJzTGVuZ3RoID0gNTI7XG5cbi8qIHN0YXJ0IGF0IDc1IGZvciAnYScgdW50aWwgJ3onICgyNSkgYW5kIHRoZW4gc3RhcnQgYXQgNjUgZm9yIGNhcGl0YWxpc2VkIGxldHRlcnMgKi9cbnZhciBnZXRBbHBoYWJldGljQ2hhciA9IGZ1bmN0aW9uIGdldEFscGhhYmV0aWNDaGFyKGNvZGUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSArIChjb2RlID4gMjUgPyAzOSA6IDk3KSk7XG59O1xuXG4vKiBpbnB1dCBhIG51bWJlciwgdXN1YWxseSBhIGhhc2ggYW5kIGNvbnZlcnQgaXQgdG8gYmFzZS01MiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVBbHBoYWJldGljTmFtZShjb2RlKSB7XG4gIHZhciBuYW1lID0gJyc7XG4gIHZhciB4ID0gdm9pZCAwO1xuXG4gIC8qIGdldCBhIGNoYXIgYW5kIGRpdmlkZSBieSBhbHBoYWJldC1sZW5ndGggKi9cbiAgZm9yICh4ID0gY29kZTsgeCA+IGNoYXJzTGVuZ3RoOyB4ID0gTWF0aC5mbG9vcih4IC8gY2hhcnNMZW5ndGgpKSB7XG4gICAgbmFtZSA9IGdldEFscGhhYmV0aWNDaGFyKHggJSBjaGFyc0xlbmd0aCkgKyBuYW1lO1xuICB9XG5cbiAgcmV0dXJuIGdldEFscGhhYmV0aWNDaGFyKHggJSBjaGFyc0xlbmd0aCkgKyBuYW1lO1xufVxuXG4vLyBcblxuZnVuY3Rpb24gaGFzRnVuY3Rpb25PYmplY3RLZXkob2JqKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4sIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaXNGdW5jdGlvbihvYmpba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNSdWxlcyhydWxlcywgYXR0cnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBydWxlID0gcnVsZXNbaV07XG5cbiAgICAvLyByZWN1cnNpdmUgY2FzZVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUpICYmICFpc1N0YXRpY1J1bGVzKHJ1bGUsIGF0dHJzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihydWxlKSAmJiAhaXNTdHlsZWRDb21wb25lbnQocnVsZSkpIHtcbiAgICAgIC8vIGZ1bmN0aW9ucyBhcmUgYWxsb3dlZCB0byBiZSBzdGF0aWMgaWYgdGhleSdyZSBqdXN0IGJlaW5nXG4gICAgICAvLyB1c2VkIHRvIGdldCB0aGUgY2xhc3NuYW1lIG9mIGEgbmVzdGVkIHN0eWxlZCBjb21wb25lbnRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXR0cnMuc29tZShmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHgpIHx8IGhhc0Z1bmN0aW9uT2JqZWN0S2V5KHgpO1xuICB9KSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBcblxuLyogY29tYmluZXMgaGFzaFN0ciAobXVybXVyaGFzaCkgYW5kIG5hbWVHZW5lcmF0b3IgZm9yIGNvbnZlbmllbmNlICovXG52YXIgaGFzaGVyID0gZnVuY3Rpb24gaGFzaGVyKHN0cikge1xuICByZXR1cm4gZ2VuZXJhdGVBbHBoYWJldGljTmFtZShtdXJtdXJoYXNoKHN0cikpO1xufTtcblxuLypcbiBDb21wb25lbnRTdHlsZSBpcyBhbGwgdGhlIENTUy1zcGVjaWZpYyBzdHVmZiwgbm90XG4gdGhlIFJlYWN0LXNwZWNpZmljIHN0dWZmLlxuICovXG5cbnZhciBDb21wb25lbnRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tcG9uZW50U3R5bGUocnVsZXMsIGF0dHJzLCBjb21wb25lbnRJZCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBvbmVudFN0eWxlKTtcblxuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICB0aGlzLmlzU3RhdGljID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiBpc1N0YXRpY1J1bGVzKHJ1bGVzLCBhdHRycyk7XG4gICAgdGhpcy5jb21wb25lbnRJZCA9IGNvbXBvbmVudElkO1xuXG4gICAgaWYgKCFTdHlsZVNoZWV0Lm1hc3Rlci5oYXNJZChjb21wb25lbnRJZCkpIHtcbiAgICAgIFN0eWxlU2hlZXQubWFzdGVyLmRlZmVycmVkSW5qZWN0KGNvbXBvbmVudElkLCBbXSk7XG4gICAgfVxuICB9XG5cbiAgLypcbiAgICogRmxhdHRlbnMgYSBydWxlIHNldCBpbnRvIHZhbGlkIENTU1xuICAgKiBIYXNoZXMgaXQsIHdyYXBzIHRoZSB3aG9sZSBjaHVuayBpbiBhIC5oYXNoMTIzNCB7fVxuICAgKiBSZXR1cm5zIHRoZSBoYXNoIHRvIGJlIGluamVjdGVkIG9uIHJlbmRlcigpXG4gICAqICovXG5cblxuICBDb21wb25lbnRTdHlsZS5wcm90b3R5cGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMgPSBmdW5jdGlvbiBnZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KSB7XG4gICAgdmFyIGlzU3RhdGljID0gdGhpcy5pc1N0YXRpYyxcbiAgICAgICAgY29tcG9uZW50SWQgPSB0aGlzLmNvbXBvbmVudElkLFxuICAgICAgICBsYXN0Q2xhc3NOYW1lID0gdGhpcy5sYXN0Q2xhc3NOYW1lO1xuXG4gICAgaWYgKElTX0JST1dTRVIgJiYgaXNTdGF0aWMgJiYgdHlwZW9mIGxhc3RDbGFzc05hbWUgPT09ICdzdHJpbmcnICYmIHN0eWxlU2hlZXQuaGFzTmFtZUZvcklkKGNvbXBvbmVudElkLCBsYXN0Q2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuIGxhc3RDbGFzc05hbWU7XG4gICAgfVxuXG4gICAgdmFyIGZsYXRDU1MgPSBmbGF0dGVuKHRoaXMucnVsZXMsIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpO1xuICAgIHZhciBuYW1lID0gaGFzaGVyKHRoaXMuY29tcG9uZW50SWQgKyBmbGF0Q1NTLmpvaW4oJycpKTtcbiAgICBpZiAoIXN0eWxlU2hlZXQuaGFzTmFtZUZvcklkKGNvbXBvbmVudElkLCBuYW1lKSkge1xuICAgICAgc3R5bGVTaGVldC5pbmplY3QodGhpcy5jb21wb25lbnRJZCwgc3RyaW5naWZ5UnVsZXMoZmxhdENTUywgJy4nICsgbmFtZSwgdW5kZWZpbmVkLCBjb21wb25lbnRJZCksIG5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdENsYXNzTmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG5cbiAgQ29tcG9uZW50U3R5bGUuZ2VuZXJhdGVOYW1lID0gZnVuY3Rpb24gZ2VuZXJhdGVOYW1lKHN0cikge1xuICAgIHJldHVybiBoYXNoZXIoc3RyKTtcbiAgfTtcblxuICByZXR1cm4gQ29tcG9uZW50U3R5bGU7XG59KCk7XG5cbi8vIFxuXG52YXIgTElNSVQgPSAyMDA7XG5cbnZhciBjcmVhdGVXYXJuVG9vTWFueUNsYXNzZXMgPSAoZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gIHZhciBnZW5lcmF0ZWRDbGFzc2VzID0ge307XG4gIHZhciB3YXJuaW5nU2VlbiA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgaWYgKCF3YXJuaW5nU2Vlbikge1xuICAgICAgZ2VuZXJhdGVkQ2xhc3Nlc1tjbGFzc05hbWVdID0gdHJ1ZTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhnZW5lcmF0ZWRDbGFzc2VzKS5sZW5ndGggPj0gTElNSVQpIHtcbiAgICAgICAgLy8gVW5hYmxlIHRvIGZpbmQgbGF0ZXN0UnVsZSBpbiB0ZXN0IGVudmlyb25tZW50LlxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlLCBwcmVmZXItdGVtcGxhdGUgKi9cbiAgICAgICAgY29uc29sZS53YXJuKCdPdmVyICcgKyBMSU1JVCArICcgY2xhc3NlcyB3ZXJlIGdlbmVyYXRlZCBmb3IgY29tcG9uZW50ICcgKyBkaXNwbGF5TmFtZSArICcuIFxcbicgKyAnQ29uc2lkZXIgdXNpbmcgdGhlIGF0dHJzIG1ldGhvZCwgdG9nZXRoZXIgd2l0aCBhIHN0eWxlIG9iamVjdCBmb3IgZnJlcXVlbnRseSBjaGFuZ2VkIHN0eWxlcy5cXG4nICsgJ0V4YW1wbGU6XFxuJyArICcgIGNvbnN0IENvbXBvbmVudCA9IHN0eWxlZC5kaXYuYXR0cnMocHJvcHMgPT4gKHtcXG4nICsgJyAgICBzdHlsZToge1xcbicgKyAnICAgICAgYmFja2dyb3VuZDogcHJvcHMuYmFja2dyb3VuZCxcXG4nICsgJyAgICB9LFxcbicgKyAnICB9KSlgd2lkdGg6IDEwMCU7YFxcblxcbicgKyAnICA8Q29tcG9uZW50IC8+Jyk7XG4gICAgICAgIHdhcm5pbmdTZWVuID0gdHJ1ZTtcbiAgICAgICAgZ2VuZXJhdGVkQ2xhc3NlcyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyBcblxudmFyIGRldGVybWluZVRoZW1lID0gKGZ1bmN0aW9uIChwcm9wcywgZmFsbGJhY2tUaGVtZSkge1xuICB2YXIgZGVmYXVsdFByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBFTVBUWV9PQkpFQ1Q7XG5cbiAgLy8gUHJvcHMgc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIFRoZW1lUHJvdmlkZXIsIHdoaWNoIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlclxuICAvLyBkZWZhdWx0UHJvcHMsIGJ1dCBSZWFjdCBhdXRvbWF0aWNhbGx5IHB1dHMgZGVmYXVsdFByb3BzIG9uIHByb3BzLlxuXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3Byb3AtdHlwZXMsIGZsb3d0eXBlLWVycm9ycy9zaG93LWVycm9ycyAqL1xuICB2YXIgaXNEZWZhdWx0VGhlbWUgPSBkZWZhdWx0UHJvcHMgPyBwcm9wcy50aGVtZSA9PT0gZGVmYXVsdFByb3BzLnRoZW1lIDogZmFsc2U7XG4gIHZhciB0aGVtZSA9IHByb3BzLnRoZW1lICYmICFpc0RlZmF1bHRUaGVtZSA/IHByb3BzLnRoZW1lIDogZmFsbGJhY2tUaGVtZSB8fCBkZWZhdWx0UHJvcHMudGhlbWU7XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICByZXR1cm4gdGhlbWU7XG59KTtcblxuLy8gXG52YXIgZXNjYXBlUmVnZXggPSAvW1tcXF0uIyokPjwrfj18XjooKSxcIidgLV0rL2c7XG52YXIgZGFzaGVzQXRFbmRzID0gLyheLXwtJCkvZztcblxuLyoqXG4gKiBUT0RPOiBFeHBsb3JlIHVzaW5nIENTUy5lc2NhcGUgd2hlbiBpdCBiZWNvbWVzIG1vcmUgYXZhaWxhYmxlXG4gKiBpbiBldmVyZ3JlZW4gYnJvd3NlcnMuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAvLyBSZXBsYWNlIGFsbCBwb3NzaWJsZSBDU1Mgc2VsZWN0b3JzXG4gIC5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnLScpXG5cbiAgLy8gUmVtb3ZlIGV4dHJhbmVvdXMgaHlwaGVucyBhdCB0aGUgc3RhcnQgYW5kIGVuZFxuICAucmVwbGFjZShkYXNoZXNBdEVuZHMsICcnKTtcbn1cblxuLy8gXG5cbmZ1bmN0aW9uIGlzVGFnKHRhcmdldCkge1xuICByZXR1cm4gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB0YXJnZXQuY2hhckF0KDApID09PSB0YXJnZXQuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgOiB0cnVlKTtcbn1cblxuLy8gXG5cbmZ1bmN0aW9uIGdlbmVyYXRlRGlzcGxheU5hbWUodGFyZ2V0KSB7XG4gIC8vICRGbG93Rml4TWVcbiAgcmV0dXJuIGlzVGFnKHRhcmdldCkgPyAnc3R5bGVkLicgKyB0YXJnZXQgOiAnU3R5bGVkKCcgKyBnZXRDb21wb25lbnROYW1lKHRhcmdldCkgKyAnKSc7XG59XG5cbnZhciBfVFlQRV9TVEFUSUNTO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG5cbnZhciBUWVBFX1NUQVRJQ1MgPSAoX1RZUEVfU1RBVElDUyA9IHt9LCBfVFlQRV9TVEFUSUNTW0ZvcndhcmRSZWZdID0ge1xuICAkJHR5cGVvZjogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlXG59LCBfVFlQRV9TVEFUSUNTKTtcblxudmFyIGRlZmluZVByb3BlcnR5JDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksXG4gICAgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAgIF9PYmplY3QkZ2V0T3duUHJvcGVydCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbXTtcbn0gOiBfT2JqZWN0JGdldE93blByb3BlcnQsXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZixcbiAgICBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIGFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG5cbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcblxuICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBhcnJheVByb3RvdHlwZS5jb25jYXQoZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpLFxuICAgIC8vICRGbG93Rml4TWVcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG5cbiAgICB2YXIgdGFyZ2V0U3RhdGljcyA9IFRZUEVfU1RBVElDU1t0YXJnZXRDb21wb25lbnQuJCR0eXBlb2ZdIHx8IFJFQUNUX1NUQVRJQ1M7XG5cbiAgICB2YXIgc291cmNlU3RhdGljcyA9IFRZUEVfU1RBVElDU1tzb3VyY2VDb21wb25lbnQuJCR0eXBlb2ZdIHx8IFJFQUNUX1NUQVRJQ1M7XG5cbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBkZXNjcmlwdG9yID0gdm9pZCAwO1xuICAgIHZhciBrZXkgPSB2b2lkIDA7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAhS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJlxuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG5cbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgZGVmaW5lUHJvcGVydHkkMSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogZmFpbCBzaWxlbnRseSAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG4vLyBcbmZ1bmN0aW9uIGlzRGVyaXZlZFJlYWN0Q29tcG9uZW50KGZuKSB7XG4gIHJldHVybiAhIShmbiAmJiBmbi5wcm90b3R5cGUgJiYgZm4ucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBcbi8vIEhlbHBlciB0byBjYWxsIGEgZ2l2ZW4gZnVuY3Rpb24sIG9ubHkgb25jZVxudmFyIG9uY2UgPSAoZnVuY3Rpb24gKGNiKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2IuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyBcblxudmFyIFRoZW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcblxudmFyIFRoZW1lQ29uc3VtZXIgPSBUaGVtZUNvbnRleHQuQ29uc3VtZXI7XG5cbi8qKlxuICogUHJvdmlkZSBhIHRoZW1lIHRvIGFuIGVudGlyZSByZWFjdCBjb21wb25lbnQgdHJlZSB2aWEgY29udGV4dFxuICovXG5cbnZhciBUaGVtZVByb3ZpZGVyID0gZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgaW5oZXJpdHMoVGhlbWVQcm92aWRlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVGhlbWVQcm92aWRlcihwcm9wcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFRoZW1lUHJvdmlkZXIpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgIF90aGlzLmdldENvbnRleHQgPSBtZW1vaXplKF90aGlzLmdldENvbnRleHQuYmluZChfdGhpcykpO1xuICAgIF90aGlzLnJlbmRlcklubmVyID0gX3RoaXMucmVuZGVySW5uZXIuYmluZChfdGhpcyk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGhlbWVQcm92aWRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy5jaGlsZHJlbikgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFRoZW1lQ29udGV4dC5Db25zdW1lcixcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLnJlbmRlcklubmVyXG4gICAgKTtcbiAgfTtcblxuICBUaGVtZVByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXJJbm5lciA9IGZ1bmN0aW9uIHJlbmRlcklubmVyKG91dGVyVGhlbWUpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCh0aGlzLnByb3BzLnRoZW1lLCBvdXRlclRoZW1lKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgVGhlbWVDb250ZXh0LlByb3ZpZGVyLFxuICAgICAgeyB2YWx1ZTogY29udGV4dCB9LFxuICAgICAgdGhpcy5wcm9wcy5jaGlsZHJlblxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGhlbWUgZnJvbSB0aGUgcHJvcHMsIHN1cHBvcnRpbmcgYm90aCAob3V0ZXJUaGVtZSkgPT4ge31cbiAgICogYXMgd2VsbCBhcyBvYmplY3Qgbm90YXRpb25cbiAgICovXG5cblxuICBUaGVtZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUaGVtZSA9IGZ1bmN0aW9uIGdldFRoZW1lKHRoZW1lLCBvdXRlclRoZW1lKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhlbWUpKSB7XG4gICAgICB2YXIgbWVyZ2VkVGhlbWUgPSB0aGVtZShvdXRlclRoZW1lKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKG1lcmdlZFRoZW1lID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobWVyZ2VkVGhlbWUpIHx8ICh0eXBlb2YgbWVyZ2VkVGhlbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG1lcmdlZFRoZW1lKSkgIT09ICdvYmplY3QnKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVyZ2VkVGhlbWU7XG4gICAgfVxuXG4gICAgaWYgKHRoZW1lID09PSBudWxsIHx8IEFycmF5LmlzQXJyYXkodGhlbWUpIHx8ICh0eXBlb2YgdGhlbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRoZW1lKSkgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDgpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgb3V0ZXJUaGVtZSwgdGhlbWUpO1xuICB9O1xuXG4gIFRoZW1lUHJvdmlkZXIucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiBnZXRDb250ZXh0KHRoZW1lLCBvdXRlclRoZW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGhlbWUodGhlbWUsIG91dGVyVGhlbWUpO1xuICB9O1xuXG4gIHJldHVybiBUaGVtZVByb3ZpZGVyO1xufShDb21wb25lbnQpO1xuXG4vLyBcblxudmFyIENMT1NJTkdfVEFHX1IgPSAvXlxccyo8XFwvW2Etel0vaTtcblxudmFyIFNlcnZlclN0eWxlU2hlZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlcnZlclN0eWxlU2hlZXQoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VydmVyU3R5bGVTaGVldCk7XG5cbiAgICAvKiBUaGUgbWFzdGVyIHNoZWV0IG1pZ2h0IGJlIHJlc2V0LCBzbyBrZWVwIGEgcmVmZXJlbmNlIGhlcmUgKi9cbiAgICB0aGlzLm1hc3RlclNoZWV0ID0gU3R5bGVTaGVldC5tYXN0ZXI7XG4gICAgdGhpcy5pbnN0YW5jZSA9IHRoaXMubWFzdGVyU2hlZXQuY2xvbmUoKTtcbiAgICB0aGlzLnNlYWxlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhlIFNlcnZlclN0eWxlU2hlZXQgYXMgYmVpbmcgZnVsbHkgZW1pdHRlZCBhbmQgbWFudWFsbHkgR0MgaXQgZnJvbSB0aGVcbiAgICogU3R5bGVTaGVldCBzaW5nbGV0b24uXG4gICAqL1xuXG5cbiAgU2VydmVyU3R5bGVTaGVldC5wcm90b3R5cGUuc2VhbCA9IGZ1bmN0aW9uIHNlYWwoKSB7XG4gICAgaWYgKCF0aGlzLnNlYWxlZCkge1xuICAgICAgLyogUmVtb3ZlIHNlYWxlZCBTdHlsZVNoZWV0cyBmcm9tIHRoZSBtYXN0ZXIgc2hlZXQgKi9cbiAgICAgIHZhciBpbmRleCA9IHRoaXMubWFzdGVyU2hlZXQuY2xvbmVzLmluZGV4T2YodGhpcy5pbnN0YW5jZSk7XG4gICAgICB0aGlzLm1hc3RlclNoZWV0LmNsb25lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5zZWFsZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5jb2xsZWN0U3R5bGVzID0gZnVuY3Rpb24gY29sbGVjdFN0eWxlcyhjaGlsZHJlbikge1xuICAgIGlmICh0aGlzLnNlYWxlZCkge1xuICAgICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcigyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0eWxlU2hlZXRNYW5hZ2VyLFxuICAgICAgeyBzaGVldDogdGhpcy5pbnN0YW5jZSB9LFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9O1xuXG4gIFNlcnZlclN0eWxlU2hlZXQucHJvdG90eXBlLmdldFN0eWxlVGFncyA9IGZ1bmN0aW9uIGdldFN0eWxlVGFncygpIHtcbiAgICB0aGlzLnNlYWwoKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS50b0hUTUwoKTtcbiAgfTtcblxuICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5nZXRTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiBnZXRTdHlsZUVsZW1lbnQoKSB7XG4gICAgdGhpcy5zZWFsKCk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UudG9SZWFjdEVsZW1lbnRzKCk7XG4gIH07XG5cbiAgU2VydmVyU3R5bGVTaGVldC5wcm90b3R5cGUuaW50ZXJsZWF2ZVdpdGhOb2RlU3RyZWFtID0gZnVuY3Rpb24gaW50ZXJsZWF2ZVdpdGhOb2RlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChJU19CUk9XU0VSKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDMpO1xuICAgIH1cblxuICAgIC8qIHRoZSB0YWcgaW5kZXgga2VlcHMgdHJhY2sgb2Ygd2hpY2ggdGFncyBoYXZlIGFscmVhZHkgYmVlbiBlbWl0dGVkICovXG4gICAgdmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZTtcblxuICAgIHZhciBpbnN0YW5jZVRhZ0luZGV4ID0gMDtcblxuICAgIHZhciBzdHJlYW1BdHRyID0gU0NfU1RSRUFNX0FUVFIgKyAnPVwidHJ1ZVwiJztcblxuICAgIHZhciB0cmFuc2Zvcm1lciA9IG5ldyBzdHJlYW0uVHJhbnNmb3JtKHtcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gYXBwZW5kU3R5bGVDaHVua3MoY2h1bmssIC8qIGVuY29kaW5nICovXywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRhZ3MgPSBpbnN0YW5jZS50YWdzO1xuXG4gICAgICAgIHZhciBodG1sID0gJyc7XG5cbiAgICAgICAgLyogcmV0cmlldmUgaHRtbCBmb3IgZWFjaCBuZXcgc3R5bGUgdGFnICovXG4gICAgICAgIGZvciAoOyBpbnN0YW5jZVRhZ0luZGV4IDwgdGFncy5sZW5ndGg7IGluc3RhbmNlVGFnSW5kZXggKz0gMSkge1xuICAgICAgICAgIHZhciB0YWcgPSB0YWdzW2luc3RhbmNlVGFnSW5kZXhdO1xuICAgICAgICAgIGh0bWwgKz0gdGFnLnRvSFRNTChzdHJlYW1BdHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGZvcmNlIG91ciBTdHlsZVNoZWV0cyB0byBlbWl0IGVudGlyZWx5IG5ldyB0YWdzICovXG4gICAgICAgIGluc3RhbmNlLnNlYWxBbGxUYWdzKCk7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVkSHRtbCA9IGNodW5rLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgLyogcHJlcGVuZCBzdHlsZSBodG1sIHRvIGNodW5rLCB1bmxlc3MgdGhlIHN0YXJ0IG9mIHRoZSBjaHVuayBpcyBhIGNsb3NpbmcgdGFnIGluIHdoaWNoIGNhc2UgYXBwZW5kIHJpZ2h0IGFmdGVyIHRoYXQgKi9cbiAgICAgICAgaWYgKENMT1NJTkdfVEFHX1IudGVzdChyZW5kZXJlZEh0bWwpKSB7XG4gICAgICAgICAgdmFyIGVuZE9mQ2xvc2luZ1RhZyA9IHJlbmRlcmVkSHRtbC5pbmRleE9mKCc+Jyk7XG5cbiAgICAgICAgICB0aGlzLnB1c2gocmVuZGVyZWRIdG1sLnNsaWNlKDAsIGVuZE9mQ2xvc2luZ1RhZyArIDEpICsgaHRtbCArIHJlbmRlcmVkSHRtbC5zbGljZShlbmRPZkNsb3NpbmdUYWcgKyAxKSk7XG4gICAgICAgIH0gZWxzZSB0aGlzLnB1c2goaHRtbCArIHJlbmRlcmVkSHRtbCk7XG5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWRhYmxlU3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RoaXMuc2VhbCgpO1xuICAgIH0pO1xuXG4gICAgcmVhZGFibGVTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgX3RoaXMuc2VhbCgpO1xuXG4gICAgICAvLyBmb3J3YXJkIHRoZSBlcnJvciB0byB0aGUgdHJhbnNmb3JtIHN0cmVhbVxuICAgICAgdHJhbnNmb3JtZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlYWRhYmxlU3RyZWFtLnBpcGUodHJhbnNmb3JtZXIpO1xuICB9O1xuXG4gIHJldHVybiBTZXJ2ZXJTdHlsZVNoZWV0O1xufSgpO1xuXG4vLyBcblxudmFyIFN0eWxlU2hlZXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xudmFyIFN0eWxlU2hlZXRDb25zdW1lciA9IFN0eWxlU2hlZXRDb250ZXh0LkNvbnN1bWVyO1xuXG52YXIgU3R5bGVTaGVldE1hbmFnZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTdHlsZVNoZWV0TWFuYWdlciwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3R5bGVTaGVldE1hbmFnZXIocHJvcHMpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZVNoZWV0TWFuYWdlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMuZ2V0Q29udGV4dCA9IG1lbW9pemUoX3RoaXMuZ2V0Q29udGV4dCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU3R5bGVTaGVldE1hbmFnZXIucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiBnZXRDb250ZXh0KHNoZWV0LCB0YXJnZXQpIHtcbiAgICBpZiAoc2hlZXQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCkge1xuICAgICAgcmV0dXJuIG5ldyBTdHlsZVNoZWV0KHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoNCk7XG4gICAgfVxuICB9O1xuXG4gIFN0eWxlU2hlZXRNYW5hZ2VyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuLFxuICAgICAgICBzaGVldCA9IF9wcm9wcy5zaGVldCxcbiAgICAgICAgdGFyZ2V0ID0gX3Byb3BzLnRhcmdldDtcblxuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBTdHlsZVNoZWV0Q29udGV4dC5Qcm92aWRlcixcbiAgICAgIHsgdmFsdWU6IHRoaXMuZ2V0Q29udGV4dChzaGVldCwgdGFyZ2V0KSB9LFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IFJlYWN0LkNoaWxkcmVuLm9ubHkoY2hpbGRyZW4pIDogY2hpbGRyZW5cbiAgICApO1xuICB9O1xuXG4gIHJldHVybiBTdHlsZVNoZWV0TWFuYWdlcjtcbn0oQ29tcG9uZW50KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFN0eWxlU2hlZXRNYW5hZ2VyLnByb3BUeXBlcyA9IHtcbiAgc2hlZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5pbnN0YW5jZU9mKFN0eWxlU2hlZXQpLCBQcm9wVHlwZXMuaW5zdGFuY2VPZihTZXJ2ZXJTdHlsZVNoZWV0KV0pLFxuXG4gIHRhcmdldDogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBhcHBlbmRDaGlsZDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICB9KVxufSA6IHZvaWQgMDtcblxuLy8gXG5cbnZhciBpZGVudGlmaWVycyA9IHt9O1xuXG4vKiBXZSBkZXBlbmQgb24gY29tcG9uZW50cyBoYXZpbmcgdW5pcXVlIElEcyAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVJZChfQ29tcG9uZW50U3R5bGUsIF9kaXNwbGF5TmFtZSwgcGFyZW50Q29tcG9uZW50SWQpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIF9kaXNwbGF5TmFtZSAhPT0gJ3N0cmluZycgPyAnc2MnIDogZXNjYXBlKF9kaXNwbGF5TmFtZSk7XG5cbiAgLyoqXG4gICAqIFRoaXMgZW5zdXJlcyB1bmlxdWVuZXNzIGlmIHR3byBjb21wb25lbnRzIGhhcHBlbiB0byBzaGFyZVxuICAgKiB0aGUgc2FtZSBkaXNwbGF5TmFtZS5cbiAgICovXG4gIHZhciBuciA9IChpZGVudGlmaWVyc1tkaXNwbGF5TmFtZV0gfHwgMCkgKyAxO1xuICBpZGVudGlmaWVyc1tkaXNwbGF5TmFtZV0gPSBucjtcblxuICB2YXIgY29tcG9uZW50SWQgPSBkaXNwbGF5TmFtZSArICctJyArIF9Db21wb25lbnRTdHlsZS5nZW5lcmF0ZU5hbWUoZGlzcGxheU5hbWUgKyBucik7XG5cbiAgcmV0dXJuIHBhcmVudENvbXBvbmVudElkID8gcGFyZW50Q29tcG9uZW50SWQgKyAnLScgKyBjb21wb25lbnRJZCA6IGNvbXBvbmVudElkO1xufVxuXG4vLyAkRmxvd0ZpeE1lXG5cbnZhciBTdHlsZWRDb21wb25lbnQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhTdHlsZWRDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlZENvbXBvbmVudCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZWRDb21wb25lbnQpO1xuXG4gICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfQ29tcG9uZW50LmNhbGwodGhpcykpO1xuXG4gICAgX3RoaXMuYXR0cnMgPSB7fTtcblxuICAgIF90aGlzLnJlbmRlck91dGVyID0gX3RoaXMucmVuZGVyT3V0ZXIuYmluZChfdGhpcyk7XG4gICAgX3RoaXMucmVuZGVySW5uZXIgPSBfdGhpcy5yZW5kZXJJbm5lci5iaW5kKF90aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBfdGhpcy53YXJuSW5uZXJSZWYgPSBvbmNlKGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgXCJpbm5lclJlZlwiIEFQSSBoYXMgYmVlbiByZW1vdmVkIGluIHN0eWxlZC1jb21wb25lbnRzIHY0IGluIGZhdm9yIG9mIFJlYWN0IDE2IHJlZiBmb3J3YXJkaW5nLCB1c2UgXCJyZWZcIiBpbnN0ZWFkIGxpa2UgYSB0eXBpY2FsIGNvbXBvbmVudC4gXCJpbm5lclJlZlwiIHdhcyBkZXRlY3RlZCBvbiBjb21wb25lbnQgXCInICsgZGlzcGxheU5hbWUgKyAnXCIuJylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy53YXJuQXR0cnNGbk9iamVjdEtleURlcHJlY2F0ZWQgPSBvbmNlKGZ1bmN0aW9uIChrZXksIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Z1bmN0aW9ucyBhcyBvYmplY3QtZm9ybSBhdHRycyh7fSkga2V5cyBhcmUgbm93IGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIHN0eWxlZC1jb21wb25lbnRzLiBTd2l0Y2ggdG8gdGhlIG5ldyBhdHRycyhwcm9wcyA9PiAoe30pKSBzeW50YXggaW5zdGVhZCBmb3IgZWFzaWVyIGFuZCBtb3JlIHBvd2VyZnVsIGNvbXBvc2l0aW9uLiBUaGUgYXR0cnMga2V5IGluIHF1ZXN0aW9uIGlzIFwiJyArIGtleSArICdcIiBvbiBjb21wb25lbnQgXCInICsgZGlzcGxheU5hbWUgKyAnXCIuJywgJ1xcbiAnICsgbmV3IEVycm9yKCkuc3RhY2spXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgX3RoaXMud2Fybk5vblN0eWxlZENvbXBvbmVudEF0dHJzT2JqZWN0S2V5ID0gb25jZShmdW5jdGlvbiAoa2V5LCBkaXNwbGF5TmFtZSkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKCdJdCBsb29rcyBsaWtlIHlvdVxcJ3ZlIHVzZWQgYSBub24gc3R5bGVkLWNvbXBvbmVudCBhcyB0aGUgdmFsdWUgZm9yIHRoZSBcIicgKyBrZXkgKyAnXCIgcHJvcCBpbiBhbiBvYmplY3QtZm9ybSBhdHRycyBjb25zdHJ1Y3RvciBvZiBcIicgKyBkaXNwbGF5TmFtZSArICdcIi5cXG4nICsgJ1lvdSBzaG91bGQgdXNlIHRoZSBuZXcgZnVuY3Rpb24tZm9ybSBhdHRycyBjb25zdHJ1Y3RvciB3aGljaCBhdm9pZHMgdGhpcyBpc3N1ZTogYXR0cnMocHJvcHMgPT4gKHsgeW91clN0dWZmIH0pKVxcbicgKyBcIlRvIGNvbnRpbnVlIHVzaW5nIHRoZSBkZXByZWNhdGVkIG9iamVjdCBzeW50YXgsIHlvdSdsbCBuZWVkIHRvIHdyYXAgeW91ciBjb21wb25lbnQgcHJvcCBpbiBhIGZ1bmN0aW9uIHRvIG1ha2UgaXQgYXZhaWxhYmxlIGluc2lkZSB0aGUgc3R5bGVkIGNvbXBvbmVudCAoeW91J2xsIHN0aWxsIGdldCB0aGUgZGVwcmVjYXRpb24gd2FybmluZyB0aG91Z2guKVxcblwiICsgKCdGb3IgZXhhbXBsZSwgeyAnICsga2V5ICsgJzogKCkgPT4gSW5uZXJDb21wb25lbnQgfSBpbnN0ZWFkIG9mIHsgJyArIGtleSArICc6IElubmVyQ29tcG9uZW50IH0nKSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTdHlsZWRDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0eWxlU2hlZXRDb25zdW1lcixcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLnJlbmRlck91dGVyXG4gICAgKTtcbiAgfTtcblxuICBTdHlsZWRDb21wb25lbnQucHJvdG90eXBlLnJlbmRlck91dGVyID0gZnVuY3Rpb24gcmVuZGVyT3V0ZXIoKSB7XG4gICAgdmFyIHN0eWxlU2hlZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFN0eWxlU2hlZXQubWFzdGVyO1xuXG4gICAgdGhpcy5zdHlsZVNoZWV0ID0gc3R5bGVTaGVldDtcblxuICAgIC8vIE5vIG5lZWQgdG8gc3Vic2NyaWJlIGEgc3RhdGljIGNvbXBvbmVudCB0byB0aGVtZSBjaGFuZ2VzLCBpdCB3b24ndCBjaGFuZ2UgYW55dGhpbmdcbiAgICBpZiAodGhpcy5wcm9wcy5mb3J3YXJkZWRDb21wb25lbnQuY29tcG9uZW50U3R5bGUuaXNTdGF0aWMpIHJldHVybiB0aGlzLnJlbmRlcklubmVyKCk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFRoZW1lQ29uc3VtZXIsXG4gICAgICBudWxsLFxuICAgICAgdGhpcy5yZW5kZXJJbm5lclxuICAgICk7XG4gIH07XG5cbiAgU3R5bGVkQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lciA9IGZ1bmN0aW9uIHJlbmRlcklubmVyKHRoZW1lKSB7XG4gICAgdmFyIF9wcm9wcyRmb3J3YXJkZWRDb21wbyA9IHRoaXMucHJvcHMuZm9yd2FyZGVkQ29tcG9uZW50LFxuICAgICAgICBjb21wb25lbnRTdHlsZSA9IF9wcm9wcyRmb3J3YXJkZWRDb21wby5jb21wb25lbnRTdHlsZSxcbiAgICAgICAgZGVmYXVsdFByb3BzID0gX3Byb3BzJGZvcndhcmRlZENvbXBvLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgZGlzcGxheU5hbWUgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8uZGlzcGxheU5hbWUsXG4gICAgICAgIGZvbGRlZENvbXBvbmVudElkcyA9IF9wcm9wcyRmb3J3YXJkZWRDb21wby5mb2xkZWRDb21wb25lbnRJZHMsXG4gICAgICAgIHN0eWxlZENvbXBvbmVudElkID0gX3Byb3BzJGZvcndhcmRlZENvbXBvLnN0eWxlZENvbXBvbmVudElkLFxuICAgICAgICB0YXJnZXQgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8udGFyZ2V0O1xuXG5cbiAgICB2YXIgZ2VuZXJhdGVkQ2xhc3NOYW1lID0gdm9pZCAwO1xuICAgIGlmIChjb21wb25lbnRTdHlsZS5pc1N0YXRpYykge1xuICAgICAgZ2VuZXJhdGVkQ2xhc3NOYW1lID0gdGhpcy5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhFTVBUWV9PQkpFQ1QsIHRoaXMucHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5lcmF0ZWRDbGFzc05hbWUgPSB0aGlzLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKGRldGVybWluZVRoZW1lKHRoaXMucHJvcHMsIHRoZW1lLCBkZWZhdWx0UHJvcHMpIHx8IEVNUFRZX09CSkVDVCwgdGhpcy5wcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRUb0JlQ3JlYXRlZCA9IHRoaXMucHJvcHMuYXMgfHwgdGhpcy5hdHRycy5hcyB8fCB0YXJnZXQ7XG4gICAgdmFyIGlzVGFyZ2V0VGFnID0gaXNUYWcoZWxlbWVudFRvQmVDcmVhdGVkKTtcblxuICAgIHZhciBwcm9wc0ZvckVsZW1lbnQgPSB7fTtcbiAgICB2YXIgY29tcHV0ZWRQcm9wcyA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB0aGlzLmF0dHJzKTtcblxuICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAoa2V5IGluIGNvbXB1dGVkUHJvcHMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSA9PT0gJ2lubmVyUmVmJyAmJiBpc1RhcmdldFRhZykge1xuICAgICAgICB0aGlzLndhcm5Jbm5lclJlZihkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgPT09ICdmb3J3YXJkZWRDb21wb25lbnQnIHx8IGtleSA9PT0gJ2FzJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZm9yd2FyZGVkUmVmJykgcHJvcHNGb3JFbGVtZW50LnJlZiA9IGNvbXB1dGVkUHJvcHNba2V5XTtlbHNlIGlmIChrZXkgPT09ICdmb3J3YXJkZWRBcycpIHByb3BzRm9yRWxlbWVudC5hcyA9IGNvbXB1dGVkUHJvcHNba2V5XTtlbHNlIGlmICghaXNUYXJnZXRUYWcgfHwgdmFsaWRBdHRyKGtleSkpIHtcbiAgICAgICAgLy8gRG9uJ3QgcGFzcyB0aHJvdWdoIG5vbiBIVE1MIHRhZ3MgdGhyb3VnaCB0byBIVE1MIGVsZW1lbnRzXG4gICAgICAgIHByb3BzRm9yRWxlbWVudFtrZXldID0gY29tcHV0ZWRQcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLnN0eWxlICYmIHRoaXMuYXR0cnMuc3R5bGUpIHtcbiAgICAgIHByb3BzRm9yRWxlbWVudC5zdHlsZSA9IF9leHRlbmRzKHt9LCB0aGlzLmF0dHJzLnN0eWxlLCB0aGlzLnByb3BzLnN0eWxlKTtcbiAgICB9XG5cbiAgICBwcm9wc0ZvckVsZW1lbnQuY2xhc3NOYW1lID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdChmb2xkZWRDb21wb25lbnRJZHMsIHN0eWxlZENvbXBvbmVudElkLCBnZW5lcmF0ZWRDbGFzc05hbWUgIT09IHN0eWxlZENvbXBvbmVudElkID8gZ2VuZXJhdGVkQ2xhc3NOYW1lIDogbnVsbCwgdGhpcy5wcm9wcy5jbGFzc05hbWUsIHRoaXMuYXR0cnMuY2xhc3NOYW1lKS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoZWxlbWVudFRvQmVDcmVhdGVkLCBwcm9wc0ZvckVsZW1lbnQpO1xuICB9O1xuXG4gIFN0eWxlZENvbXBvbmVudC5wcm90b3R5cGUuYnVpbGRFeGVjdXRpb25Db250ZXh0ID0gZnVuY3Rpb24gYnVpbGRFeGVjdXRpb25Db250ZXh0KHRoZW1lLCBwcm9wcywgYXR0cnMpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBjb250ZXh0ID0gX2V4dGVuZHMoe30sIHByb3BzLCB7IHRoZW1lOiB0aGVtZSB9KTtcblxuICAgIGlmICghYXR0cnMubGVuZ3RoKSByZXR1cm4gY29udGV4dDtcblxuICAgIHRoaXMuYXR0cnMgPSB7fTtcblxuICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJEZWYpIHtcbiAgICAgIHZhciByZXNvbHZlZEF0dHJEZWYgPSBhdHRyRGVmO1xuICAgICAgdmFyIGF0dHJEZWZXYXNGbiA9IGZhbHNlO1xuICAgICAgdmFyIGF0dHIgPSB2b2lkIDA7XG4gICAgICB2YXIga2V5ID0gdm9pZCAwO1xuXG4gICAgICBpZiAoaXNGdW5jdGlvbihyZXNvbHZlZEF0dHJEZWYpKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgcmVzb2x2ZWRBdHRyRGVmID0gcmVzb2x2ZWRBdHRyRGVmKGNvbnRleHQpO1xuICAgICAgICBhdHRyRGVmV2FzRm4gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGZvciAoa2V5IGluIHJlc29sdmVkQXR0ckRlZikge1xuICAgICAgICBhdHRyID0gcmVzb2x2ZWRBdHRyRGVmW2tleV07XG5cbiAgICAgICAgaWYgKCFhdHRyRGVmV2FzRm4pIHtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhdHRyKSAmJiAhaXNEZXJpdmVkUmVhY3RDb21wb25lbnQoYXR0cikgJiYgIWlzU3R5bGVkQ29tcG9uZW50KGF0dHIpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICBfdGhpczIud2FybkF0dHJzRm5PYmplY3RLZXlEZXByZWNhdGVkKGtleSwgcHJvcHMuZm9yd2FyZGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXR0ciA9IGF0dHIoY29udGV4dCk7XG5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIFJlYWN0LmlzVmFsaWRFbGVtZW50KGF0dHIpKSB7XG4gICAgICAgICAgICAgIF90aGlzMi53YXJuTm9uU3R5bGVkQ29tcG9uZW50QXR0cnNPYmplY3RLZXkoa2V5LCBwcm9wcy5mb3J3YXJkZWRDb21wb25lbnQuZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5hdHRyc1trZXldID0gYXR0cjtcbiAgICAgICAgY29udGV4dFtrZXldID0gYXR0cjtcbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9KTtcblxuICAgIHJldHVybiBjb250ZXh0O1xuICB9O1xuXG4gIFN0eWxlZENvbXBvbmVudC5wcm90b3R5cGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMgPSBmdW5jdGlvbiBnZW5lcmF0ZUFuZEluamVjdFN0eWxlcyh0aGVtZSwgcHJvcHMpIHtcbiAgICB2YXIgX3Byb3BzJGZvcndhcmRlZENvbXBvMiA9IHByb3BzLmZvcndhcmRlZENvbXBvbmVudCxcbiAgICAgICAgYXR0cnMgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8yLmF0dHJzLFxuICAgICAgICBjb21wb25lbnRTdHlsZSA9IF9wcm9wcyRmb3J3YXJkZWRDb21wbzIuY29tcG9uZW50U3R5bGUsXG4gICAgICAgIHdhcm5Ub29NYW55Q2xhc3NlcyA9IF9wcm9wcyRmb3J3YXJkZWRDb21wbzIud2FyblRvb01hbnlDbGFzc2VzO1xuXG4gICAgLy8gc3RhdGljYWxseSBzdHlsZWQtY29tcG9uZW50cyBkb24ndCBuZWVkIHRvIGJ1aWxkIGFuIGV4ZWN1dGlvbiBjb250ZXh0IG9iamVjdCxcbiAgICAvLyBhbmQgc2hvdWxkbid0IGJlIGluY3JlYXNpbmcgdGhlIG51bWJlciBvZiBjbGFzcyBuYW1lc1xuXG4gICAgaWYgKGNvbXBvbmVudFN0eWxlLmlzU3RhdGljICYmICFhdHRycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRTdHlsZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyhFTVBUWV9PQkpFQ1QsIHRoaXMuc3R5bGVTaGVldCk7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzTmFtZSA9IGNvbXBvbmVudFN0eWxlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKHRoaXMuYnVpbGRFeGVjdXRpb25Db250ZXh0KHRoZW1lLCBwcm9wcywgYXR0cnMpLCB0aGlzLnN0eWxlU2hlZXQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FyblRvb01hbnlDbGFzc2VzKSB3YXJuVG9vTWFueUNsYXNzZXMoY2xhc3NOYW1lKTtcblxuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlZENvbXBvbmVudDtcbn0oQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVkQ29tcG9uZW50KHRhcmdldCwgb3B0aW9ucywgcnVsZXMpIHtcbiAgdmFyIGlzVGFyZ2V0U3R5bGVkQ29tcCA9IGlzU3R5bGVkQ29tcG9uZW50KHRhcmdldCk7XG4gIHZhciBpc0NsYXNzID0gIWlzVGFnKHRhcmdldCk7XG5cbiAgdmFyIF9vcHRpb25zJGRpc3BsYXlOYW1lID0gb3B0aW9ucy5kaXNwbGF5TmFtZSxcbiAgICAgIGRpc3BsYXlOYW1lID0gX29wdGlvbnMkZGlzcGxheU5hbWUgPT09IHVuZGVmaW5lZCA/IGdlbmVyYXRlRGlzcGxheU5hbWUodGFyZ2V0KSA6IF9vcHRpb25zJGRpc3BsYXlOYW1lLFxuICAgICAgX29wdGlvbnMkY29tcG9uZW50SWQgPSBvcHRpb25zLmNvbXBvbmVudElkLFxuICAgICAgY29tcG9uZW50SWQgPSBfb3B0aW9ucyRjb21wb25lbnRJZCA9PT0gdW5kZWZpbmVkID8gZ2VuZXJhdGVJZChDb21wb25lbnRTdHlsZSwgb3B0aW9ucy5kaXNwbGF5TmFtZSwgb3B0aW9ucy5wYXJlbnRDb21wb25lbnRJZCkgOiBfb3B0aW9ucyRjb21wb25lbnRJZCxcbiAgICAgIF9vcHRpb25zJFBhcmVudENvbXBvbiA9IG9wdGlvbnMuUGFyZW50Q29tcG9uZW50LFxuICAgICAgUGFyZW50Q29tcG9uZW50ID0gX29wdGlvbnMkUGFyZW50Q29tcG9uID09PSB1bmRlZmluZWQgPyBTdHlsZWRDb21wb25lbnQgOiBfb3B0aW9ucyRQYXJlbnRDb21wb24sXG4gICAgICBfb3B0aW9ucyRhdHRycyA9IG9wdGlvbnMuYXR0cnMsXG4gICAgICBhdHRycyA9IF9vcHRpb25zJGF0dHJzID09PSB1bmRlZmluZWQgPyBFTVBUWV9BUlJBWSA6IF9vcHRpb25zJGF0dHJzO1xuXG5cbiAgdmFyIHN0eWxlZENvbXBvbmVudElkID0gb3B0aW9ucy5kaXNwbGF5TmFtZSAmJiBvcHRpb25zLmNvbXBvbmVudElkID8gZXNjYXBlKG9wdGlvbnMuZGlzcGxheU5hbWUpICsgJy0nICsgb3B0aW9ucy5jb21wb25lbnRJZCA6IG9wdGlvbnMuY29tcG9uZW50SWQgfHwgY29tcG9uZW50SWQ7XG5cbiAgLy8gZm9sZCB0aGUgdW5kZXJseWluZyBTdHlsZWRDb21wb25lbnQgYXR0cnMgdXAgKGltcGxpY2l0IGV4dGVuZClcbiAgdmFyIGZpbmFsQXR0cnMgPVxuICAvLyAkRmxvd0ZpeE1lXG4gIGlzVGFyZ2V0U3R5bGVkQ29tcCAmJiB0YXJnZXQuYXR0cnMgPyBBcnJheS5wcm90b3R5cGUuY29uY2F0KHRhcmdldC5hdHRycywgYXR0cnMpLmZpbHRlcihCb29sZWFuKSA6IGF0dHJzO1xuXG4gIHZhciBjb21wb25lbnRTdHlsZSA9IG5ldyBDb21wb25lbnRTdHlsZShpc1RhcmdldFN0eWxlZENvbXAgPyAvLyBmb2xkIHRoZSB1bmRlcmx5aW5nIFN0eWxlZENvbXBvbmVudCBydWxlcyB1cCAoaW1wbGljaXQgZXh0ZW5kKVxuICAvLyAkRmxvd0ZpeE1lXG4gIHRhcmdldC5jb21wb25lbnRTdHlsZS5ydWxlcy5jb25jYXQocnVsZXMpIDogcnVsZXMsIGZpbmFsQXR0cnMsIHN0eWxlZENvbXBvbmVudElkKTtcblxuICAvKipcbiAgICogZm9yd2FyZFJlZiBjcmVhdGVzIGEgbmV3IGludGVyaW0gY29tcG9uZW50LCB3aGljaCB3ZSdsbCB0YWtlIGFkdmFudGFnZSBvZlxuICAgKiBpbnN0ZWFkIG9mIGV4dGVuZGluZyBQYXJlbnRDb21wb25lbnQgdG8gY3JlYXRlIF9hbm90aGVyXyBpbnRlcmltIGNsYXNzXG4gICAqL1xuICB2YXIgV3JhcHBlZFN0eWxlZENvbXBvbmVudCA9IHZvaWQgMDtcbiAgdmFyIGZvcndhcmRSZWYgPSBmdW5jdGlvbiBmb3J3YXJkUmVmKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQYXJlbnRDb21wb25lbnQsIF9leHRlbmRzKHt9LCBwcm9wcywgeyBmb3J3YXJkZWRDb21wb25lbnQ6IFdyYXBwZWRTdHlsZWRDb21wb25lbnQsIGZvcndhcmRlZFJlZjogcmVmIH0pKTtcbiAgfTtcbiAgZm9yd2FyZFJlZi5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50ID0gUmVhY3QuZm9yd2FyZFJlZihmb3J3YXJkUmVmKTtcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuXG4gIC8vICRGbG93Rml4TWVcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC5hdHRycyA9IGZpbmFsQXR0cnM7XG4gIC8vICRGbG93Rml4TWVcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC5jb21wb25lbnRTdHlsZSA9IGNvbXBvbmVudFN0eWxlO1xuXG4gIC8vICRGbG93Rml4TWVcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC5mb2xkZWRDb21wb25lbnRJZHMgPSBpc1RhcmdldFN0eWxlZENvbXAgPyAvLyAkRmxvd0ZpeE1lXG4gIEFycmF5LnByb3RvdHlwZS5jb25jYXQodGFyZ2V0LmZvbGRlZENvbXBvbmVudElkcywgdGFyZ2V0LnN0eWxlZENvbXBvbmVudElkKSA6IEVNUFRZX0FSUkFZO1xuXG4gIC8vICRGbG93Rml4TWVcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC5zdHlsZWRDb21wb25lbnRJZCA9IHN0eWxlZENvbXBvbmVudElkO1xuXG4gIC8vIGZvbGQgdGhlIHVuZGVybHlpbmcgU3R5bGVkQ29tcG9uZW50IHRhcmdldCB1cCBzaW5jZSB3ZSBmb2xkZWQgdGhlIHN0eWxlc1xuICAvLyAkRmxvd0ZpeE1lXG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQudGFyZ2V0ID0gaXNUYXJnZXRTdHlsZWRDb21wID8gdGFyZ2V0LnRhcmdldCA6IHRhcmdldDtcblxuICAvLyAkRmxvd0ZpeE1lXG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQud2l0aENvbXBvbmVudCA9IGZ1bmN0aW9uIHdpdGhDb21wb25lbnQodGFnKSB7XG4gICAgdmFyIHByZXZpb3VzQ29tcG9uZW50SWQgPSBvcHRpb25zLmNvbXBvbmVudElkLFxuICAgICAgICBvcHRpb25zVG9Db3B5ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob3B0aW9ucywgWydjb21wb25lbnRJZCddKTtcblxuXG4gICAgdmFyIG5ld0NvbXBvbmVudElkID0gcHJldmlvdXNDb21wb25lbnRJZCAmJiBwcmV2aW91c0NvbXBvbmVudElkICsgJy0nICsgKGlzVGFnKHRhZykgPyB0YWcgOiBlc2NhcGUoZ2V0Q29tcG9uZW50TmFtZSh0YWcpKSk7XG5cbiAgICB2YXIgbmV3T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvcHRpb25zVG9Db3B5LCB7XG4gICAgICBhdHRyczogZmluYWxBdHRycyxcbiAgICAgIGNvbXBvbmVudElkOiBuZXdDb21wb25lbnRJZCxcbiAgICAgIFBhcmVudENvbXBvbmVudDogUGFyZW50Q29tcG9uZW50XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY3JlYXRlU3R5bGVkQ29tcG9uZW50KHRhZywgbmV3T3B0aW9ucywgcnVsZXMpO1xuICB9O1xuXG4gIC8vICRGbG93Rml4TWVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZWRTdHlsZWRDb21wb25lbnQsICdkZWZhdWx0UHJvcHMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZm9sZGVkRGVmYXVsdFByb3BzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQkJDEob2JqKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICB0aGlzLl9mb2xkZWREZWZhdWx0UHJvcHMgPSBpc1RhcmdldFN0eWxlZENvbXAgPyBtZXJnZSh0YXJnZXQuZGVmYXVsdFByb3BzLCBvYmopIDogb2JqO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC53YXJuVG9vTWFueUNsYXNzZXMgPSBjcmVhdGVXYXJuVG9vTWFueUNsYXNzZXMoZGlzcGxheU5hbWUpO1xuICB9XG5cbiAgLy8gJEZsb3dGaXhNZVxuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnLicgKyBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LnN0eWxlZENvbXBvbmVudElkO1xuICB9O1xuXG4gIGlmIChpc0NsYXNzKSB7XG4gICAgaG9pc3ROb25SZWFjdFN0YXRpY3MoV3JhcHBlZFN0eWxlZENvbXBvbmVudCwgdGFyZ2V0LCB7XG4gICAgICAvLyBhbGwgU0Mtc3BlY2lmaWMgdGhpbmdzIHNob3VsZCBub3QgYmUgaG9pc3RlZFxuICAgICAgYXR0cnM6IHRydWUsXG4gICAgICBjb21wb25lbnRTdHlsZTogdHJ1ZSxcbiAgICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgICAgZm9sZGVkQ29tcG9uZW50SWRzOiB0cnVlLFxuICAgICAgc3R5bGVkQ29tcG9uZW50SWQ6IHRydWUsXG4gICAgICB0YXJnZXQ6IHRydWUsXG4gICAgICB3aXRoQ29tcG9uZW50OiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gV3JhcHBlZFN0eWxlZENvbXBvbmVudDtcbn1cblxuLy8gXG4vLyBUaGFua3MgdG8gUmVhY3RET01GYWN0b3JpZXMgZm9yIHRoaXMgaGFuZHkgbGlzdCFcblxudmFyIGRvbUVsZW1lbnRzID0gWydhJywgJ2FiYnInLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiYXNlJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtJywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbGluaycsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ21ldGVyJywgJ25hdicsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BhcmFtJywgJ3BpY3R1cmUnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFuJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInLFxuXG4vLyBTVkdcbidjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2ZvcmVpZ25PYmplY3QnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbEdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdmcnLCAndGV4dCcsICd0c3BhbiddO1xuXG4vLyBcblxudmFyIHN0eWxlZCA9IGZ1bmN0aW9uIHN0eWxlZCh0YWcpIHtcbiAgcmV0dXJuIGNvbnN0cnVjdFdpdGhPcHRpb25zKGNyZWF0ZVN0eWxlZENvbXBvbmVudCwgdGFnKTtcbn07XG5cbi8vIFNob3J0aGFuZHMgZm9yIGFsbCB2YWxpZCBIVE1MIEVsZW1lbnRzXG5kb21FbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChkb21FbGVtZW50KSB7XG4gIHN0eWxlZFtkb21FbGVtZW50XSA9IHN0eWxlZChkb21FbGVtZW50KTtcbn0pO1xuXG4vLyBcblxudmFyIEdsb2JhbFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxTdHlsZShydWxlcywgY29tcG9uZW50SWQpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBHbG9iYWxTdHlsZSk7XG5cbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5jb21wb25lbnRJZCA9IGNvbXBvbmVudElkO1xuICAgIHRoaXMuaXNTdGF0aWMgPSBpc1N0YXRpY1J1bGVzKHJ1bGVzLCBFTVBUWV9BUlJBWSk7XG5cbiAgICBpZiAoIVN0eWxlU2hlZXQubWFzdGVyLmhhc0lkKGNvbXBvbmVudElkKSkge1xuICAgICAgU3R5bGVTaGVldC5tYXN0ZXIuZGVmZXJyZWRJbmplY3QoY29tcG9uZW50SWQsIFtdKTtcbiAgICB9XG4gIH1cblxuICBHbG9iYWxTdHlsZS5wcm90b3R5cGUuY3JlYXRlU3R5bGVzID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVzKGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpIHtcbiAgICB2YXIgZmxhdENTUyA9IGZsYXR0ZW4odGhpcy5ydWxlcywgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCk7XG4gICAgdmFyIGNzcyA9IHN0cmluZ2lmeVJ1bGVzKGZsYXRDU1MsICcnKTtcblxuICAgIHN0eWxlU2hlZXQuaW5qZWN0KHRoaXMuY29tcG9uZW50SWQsIGNzcyk7XG4gIH07XG5cbiAgR2xvYmFsU3R5bGUucHJvdG90eXBlLnJlbW92ZVN0eWxlcyA9IGZ1bmN0aW9uIHJlbW92ZVN0eWxlcyhzdHlsZVNoZWV0KSB7XG4gICAgdmFyIGNvbXBvbmVudElkID0gdGhpcy5jb21wb25lbnRJZDtcblxuICAgIGlmIChzdHlsZVNoZWV0Lmhhc0lkKGNvbXBvbmVudElkKSkge1xuICAgICAgc3R5bGVTaGVldC5yZW1vdmUoY29tcG9uZW50SWQpO1xuICAgIH1cbiAgfTtcblxuICAvLyBUT0RPOiBvdmVyd3JpdGUgaW4tcGxhY2UgaW5zdGVhZCBvZiByZW1vdmUrY3JlYXRlP1xuXG5cbiAgR2xvYmFsU3R5bGUucHJvdG90eXBlLnJlbmRlclN0eWxlcyA9IGZ1bmN0aW9uIHJlbmRlclN0eWxlcyhleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KSB7XG4gICAgdGhpcy5yZW1vdmVTdHlsZXMoc3R5bGVTaGVldCk7XG4gICAgdGhpcy5jcmVhdGVTdHlsZXMoZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCk7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbFN0eWxlO1xufSgpO1xuXG4vLyBcblxuLy8gcGxhY2Ugb3VyIGNhY2hlIGludG8gc2hhcmVkIGNvbnRleHQgc28gaXQnbGwgcGVyc2lzdCBiZXR3ZWVuIEhNUnNcbmlmIChJU19CUk9XU0VSKSB7XG4gIHdpbmRvdy5zY0NHU0hNUkNhY2hlID0ge307XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUdsb2JhbFN0eWxlKHN0cmluZ3MpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGludGVycG9sYXRpb25zID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGludGVycG9sYXRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBydWxlcyA9IGNzcy5hcHBseSh1bmRlZmluZWQsIFtzdHJpbmdzXS5jb25jYXQoaW50ZXJwb2xhdGlvbnMpKTtcbiAgdmFyIGlkID0gJ3NjLWdsb2JhbC0nICsgbXVybXVyaGFzaChKU09OLnN0cmluZ2lmeShydWxlcykpO1xuICB2YXIgc3R5bGUgPSBuZXcgR2xvYmFsU3R5bGUocnVsZXMsIGlkKTtcblxuICB2YXIgR2xvYmFsU3R5bGVDb21wb25lbnQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICAgIGluaGVyaXRzKEdsb2JhbFN0eWxlQ29tcG9uZW50LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIEdsb2JhbFN0eWxlQ29tcG9uZW50KHByb3BzKSB7XG4gICAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBHbG9iYWxTdHlsZUNvbXBvbmVudCk7XG5cbiAgICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgIHZhciBfdGhpcyRjb25zdHJ1Y3RvciA9IF90aGlzLmNvbnN0cnVjdG9yLFxuICAgICAgICAgIGdsb2JhbFN0eWxlID0gX3RoaXMkY29uc3RydWN0b3IuZ2xvYmFsU3R5bGUsXG4gICAgICAgICAgc3R5bGVkQ29tcG9uZW50SWQgPSBfdGhpcyRjb25zdHJ1Y3Rvci5zdHlsZWRDb21wb25lbnRJZDtcblxuXG4gICAgICBpZiAoSVNfQlJPV1NFUikge1xuICAgICAgICB3aW5kb3cuc2NDR1NITVJDYWNoZVtzdHlsZWRDb21wb25lbnRJZF0gPSAod2luZG93LnNjQ0dTSE1SQ2FjaGVbc3R5bGVkQ29tcG9uZW50SWRdIHx8IDApICsgMTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGZpeGVzIEhNUiBjb21wYXRpYmlsaXR5LiBEb24ndCBhc2sgbWUgd2h5LCBidXQgdGhpcyBjb21iaW5hdGlvbiBvZlxuICAgICAgICogY2FjaGluZyB0aGUgY2xvc3VyZSB2YXJpYWJsZXMgdmlhIHN0YXRpY3MgYW5kIHRoZW4gcGVyc2lzdGluZyB0aGUgc3RhdGljcyBpblxuICAgICAgICogc3RhdGUgd29ya3MgYWNyb3NzIEhNUiB3aGVyZSBubyBvdGhlciBjb21iaW5hdGlvbiBkaWQuIMKvXFxfKOODhClfL8KvXG4gICAgICAgKi9cbiAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICBnbG9iYWxTdHlsZTogZ2xvYmFsU3R5bGUsXG4gICAgICAgIHN0eWxlZENvbXBvbmVudElkOiBzdHlsZWRDb21wb25lbnRJZFxuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBHbG9iYWxTdHlsZUNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh3aW5kb3cuc2NDR1NITVJDYWNoZVt0aGlzLnN0YXRlLnN0eWxlZENvbXBvbmVudElkXSkge1xuICAgICAgICB3aW5kb3cuc2NDR1NITVJDYWNoZVt0aGlzLnN0YXRlLnN0eWxlZENvbXBvbmVudElkXSAtPSAxO1xuICAgICAgfVxuICAgICAgLyoqXG4gICAgICAgKiBEZXBlbmRpbmcgb24gdGhlIG9yZGVyIFwicmVuZGVyXCIgaXMgY2FsbGVkIHRoaXMgY2FuIGNhdXNlIHRoZSBzdHlsZXMgdG8gYmUgbG9zdFxuICAgICAgICogdW50aWwgdGhlIG5leHQgcmVuZGVyIHBhc3Mgb2YgdGhlIHJlbWFpbmluZyBpbnN0YW5jZSwgd2hpY2ggbWF5XG4gICAgICAgKiBub3QgYmUgaW1tZWRpYXRlLlxuICAgICAgICovXG4gICAgICBpZiAod2luZG93LnNjQ0dTSE1SQ2FjaGVbdGhpcy5zdGF0ZS5zdHlsZWRDb21wb25lbnRJZF0gPT09IDApIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5nbG9iYWxTdHlsZS5yZW1vdmVTdHlsZXModGhpcy5zdHlsZVNoZWV0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgR2xvYmFsU3R5bGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBSZWFjdC5DaGlsZHJlbi5jb3VudCh0aGlzLnByb3BzLmNoaWxkcmVuKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBnbG9iYWwgc3R5bGUgY29tcG9uZW50ICcgKyB0aGlzLnN0YXRlLnN0eWxlZENvbXBvbmVudElkICsgJyB3YXMgZ2l2ZW4gY2hpbGQgSlNYLiBjcmVhdGVHbG9iYWxTdHlsZSBkb2VzIG5vdCByZW5kZXIgY2hpbGRyZW4uJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICBTdHlsZVNoZWV0Q29uc3VtZXIsXG4gICAgICAgIG51bGwsXG4gICAgICAgIGZ1bmN0aW9uIChzdHlsZVNoZWV0KSB7XG4gICAgICAgICAgX3RoaXMyLnN0eWxlU2hlZXQgPSBzdHlsZVNoZWV0IHx8IFN0eWxlU2hlZXQubWFzdGVyO1xuXG4gICAgICAgICAgdmFyIGdsb2JhbFN0eWxlID0gX3RoaXMyLnN0YXRlLmdsb2JhbFN0eWxlO1xuXG5cbiAgICAgICAgICBpZiAoZ2xvYmFsU3R5bGUuaXNTdGF0aWMpIHtcbiAgICAgICAgICAgIGdsb2JhbFN0eWxlLnJlbmRlclN0eWxlcyhTVEFUSUNfRVhFQ1VUSU9OX0NPTlRFWFQsIF90aGlzMi5zdHlsZVNoZWV0KTtcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgICAgICBUaGVtZUNvbnN1bWVyLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IF90aGlzMi5jb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHM7XG5cblxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gX2V4dGVuZHMoe30sIF90aGlzMi5wcm9wcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoZW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgY29udGV4dC50aGVtZSA9IGRldGVybWluZVRoZW1lKF90aGlzMi5wcm9wcywgdGhlbWUsIGRlZmF1bHRQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2xvYmFsU3R5bGUucmVuZGVyU3R5bGVzKGNvbnRleHQsIF90aGlzMi5zdHlsZVNoZWV0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEdsb2JhbFN0eWxlQ29tcG9uZW50O1xuICB9KFJlYWN0LkNvbXBvbmVudCk7XG5cbiAgR2xvYmFsU3R5bGVDb21wb25lbnQuZ2xvYmFsU3R5bGUgPSBzdHlsZTtcbiAgR2xvYmFsU3R5bGVDb21wb25lbnQuc3R5bGVkQ29tcG9uZW50SWQgPSBpZDtcblxuXG4gIHJldHVybiBHbG9iYWxTdHlsZUNvbXBvbmVudDtcbn1cblxuLy8gXG5cbnZhciByZXBsYWNlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2VXaGl0ZXNwYWNlKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcc3xcXFxcbi9nLCAnJyk7XG59O1xuXG5mdW5jdGlvbiBrZXlmcmFtZXMoc3RyaW5ncykge1xuICAvKiBXYXJuaW5nIGlmIHlvdSd2ZSB1c2VkIGtleWZyYW1lcyBvbiBSZWFjdCBOYXRpdmUgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybignYGtleWZyYW1lc2AgY2Fubm90IGJlIHVzZWQgb24gUmVhY3ROYXRpdmUsIG9ubHkgb24gdGhlIHdlYi4gVG8gZG8gYW5pbWF0aW9uIGluIFJlYWN0TmF0aXZlIHBsZWFzZSB1c2UgQW5pbWF0ZWQuJyk7XG4gIH1cblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaW50ZXJwb2xhdGlvbnMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgaW50ZXJwb2xhdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIHJ1bGVzID0gY3NzLmFwcGx5KHVuZGVmaW5lZCwgW3N0cmluZ3NdLmNvbmNhdChpbnRlcnBvbGF0aW9ucykpO1xuXG4gIHZhciBuYW1lID0gZ2VuZXJhdGVBbHBoYWJldGljTmFtZShtdXJtdXJoYXNoKHJlcGxhY2VXaGl0ZXNwYWNlKEpTT04uc3RyaW5naWZ5KHJ1bGVzKSkpKTtcblxuICByZXR1cm4gbmV3IEtleWZyYW1lcyhuYW1lLCBzdHJpbmdpZnlSdWxlcyhydWxlcywgbmFtZSwgJ0BrZXlmcmFtZXMnKSk7XG59XG5cbi8vIFxuXG52YXIgd2l0aFRoZW1lID0gKGZ1bmN0aW9uIChDb21wb25lbnQkJDEpIHtcbiAgdmFyIFdpdGhUaGVtZSA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFRoZW1lQ29uc3VtZXIsXG4gICAgICBudWxsLFxuICAgICAgZnVuY3Rpb24gKHRoZW1lKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudCQkMS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgICAgdmFyIHRoZW1lUHJvcCA9IGRldGVybWluZVRoZW1lKHByb3BzLCB0aGVtZSwgZGVmYXVsdFByb3BzKTtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0aGVtZVByb3AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS53YXJuKCdbd2l0aFRoZW1lXSBZb3UgYXJlIG5vdCB1c2luZyBhIFRoZW1lUHJvdmlkZXIgbm9yIHBhc3NpbmcgYSB0aGVtZSBwcm9wIG9yIGEgdGhlbWUgaW4gZGVmYXVsdFByb3BzIGluIGNvbXBvbmVudCBjbGFzcyBcIicgKyBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCQkMSkgKyAnXCInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCQkMSwgX2V4dGVuZHMoe30sIHByb3BzLCB7IHRoZW1lOiB0aGVtZVByb3AsIHJlZjogcmVmIH0pKTtcbiAgICAgIH1cbiAgICApO1xuICB9KTtcblxuICBob2lzdE5vblJlYWN0U3RhdGljcyhXaXRoVGhlbWUsIENvbXBvbmVudCQkMSk7XG5cbiAgV2l0aFRoZW1lLmRpc3BsYXlOYW1lID0gJ1dpdGhUaGVtZSgnICsgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQkJDEpICsgJyknO1xuXG4gIHJldHVybiBXaXRoVGhlbWU7XG59KTtcblxuLy8gXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0hBVU5URURfQllfU1BPT0tZX0dIT1NUUyA9IHtcbiAgU3R5bGVTaGVldDogU3R5bGVTaGVldFxufTtcblxuLy8gXG5cbi8qIFdhcm5pbmcgaWYgeW91J3ZlIGltcG9ydGVkIHRoaXMgZmlsZSBvbiBSZWFjdCBOYXRpdmUgKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUud2FybihcIkl0IGxvb2tzIGxpa2UgeW91J3ZlIGltcG9ydGVkICdzdHlsZWQtY29tcG9uZW50cycgb24gUmVhY3QgTmF0aXZlLlxcblwiICsgXCJQZXJoYXBzIHlvdSdyZSBsb29raW5nIHRvIGltcG9ydCAnc3R5bGVkLWNvbXBvbmVudHMvbmF0aXZlJz9cXG5cIiArICdSZWFkIG1vcmUgYWJvdXQgdGhpcyBhdCBodHRwczovL3d3dy5zdHlsZWQtY29tcG9uZW50cy5jb20vZG9jcy9iYXNpY3MjcmVhY3QtbmF0aXZlJyk7XG59XG5cbi8qIFdhcm5pbmcgaWYgdGhlcmUgYXJlIHNldmVyYWwgaW5zdGFuY2VzIG9mIHN0eWxlZC1jb21wb25lbnRzICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ05vZGUuanMnKSA9PT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdqc2RvbScpID09PSAtMSkge1xuICB3aW5kb3dbJ19fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fJ10gPSB3aW5kb3dbJ19fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fJ10gfHwgMDtcblxuICBpZiAod2luZG93WydfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfXyddID09PSAxKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXCJJdCBsb29rcyBsaWtlIHRoZXJlIGFyZSBzZXZlcmFsIGluc3RhbmNlcyBvZiAnc3R5bGVkLWNvbXBvbmVudHMnIGluaXRpYWxpemVkIGluIHRoaXMgYXBwbGljYXRpb24uIFwiICsgJ1RoaXMgbWF5IGNhdXNlIGR5bmFtaWMgc3R5bGVzIG5vdCByZW5kZXJpbmcgcHJvcGVybHksIGVycm9ycyBoYXBwZW5pbmcgZHVyaW5nIHJlaHlkcmF0aW9uIHByb2Nlc3MgJyArICdhbmQgbWFrZXMgeW91ciBhcHBsaWNhdGlvbiBiaWdnZXIgd2l0aG91dCBhIGdvb2QgcmVhc29uLlxcblxcbicgKyAnU2VlIGh0dHBzOi8vcy1jLnNoLzJCQVh6ZWQgZm9yIG1vcmUgaW5mby4nKTtcbiAgfVxuXG4gIHdpbmRvd1snX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSArPSAxO1xufVxuXG4vL1xuXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQ7XG5leHBvcnQgeyBjcmVhdGVHbG9iYWxTdHlsZSwgY3NzLCBpc1N0eWxlZENvbXBvbmVudCwga2V5ZnJhbWVzLCBTZXJ2ZXJTdHlsZVNoZWV0LCBTdHlsZVNoZWV0Q29uc3VtZXIsIFN0eWxlU2hlZXRDb250ZXh0LCBTdHlsZVNoZWV0TWFuYWdlciwgVGhlbWVDb25zdW1lciwgVGhlbWVDb250ZXh0LCBUaGVtZVByb3ZpZGVyLCB3aXRoVGhlbWUsIF9fRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9IQVVOVEVEX0JZX1NQT09LWV9HSE9TVFMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlZC1jb21wb25lbnRzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJTdHlsaXMiLCJfaW5zZXJ0UnVsZVBsdWdpbiIsIlJlYWN0IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlQ29udGV4dCIsIkNvbXBvbmVudCIsImNyZWF0ZUVsZW1lbnQiLCJ1bml0bGVzcyIsImlzRWxlbWVudCIsImlzVmFsaWRFbGVtZW50VHlwZSIsIkZvcndhcmRSZWYiLCJtZW1vaXplIiwic3RyZWFtIiwiUHJvcFR5cGVzIiwidmFsaWRBdHRyIiwibWVyZ2UiLCJpbnRlcmxlYXZlIiwic3RyaW5ncyIsImludGVycG9sYXRpb25zIiwicmVzdWx0IiwiaSIsImxlbiIsImxlbmd0aCIsInB1c2giLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJvYmoiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsImNsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIlR5cGVFcnJvciIsImNyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsImNyZWF0ZSIsInZhbHVlIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJvYmplY3RXaXRob3V0UHJvcGVydGllcyIsImtleXMiLCJpbmRleE9mIiwicG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsImlzUGxhaW5PYmplY3QiLCJ4IiwiRU1QVFlfQVJSQVkiLCJmcmVlemUiLCJFTVBUWV9PQkpFQ1QiLCJpc0Z1bmN0aW9uIiwidGVzdCIsImdldENvbXBvbmVudE5hbWUiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiaXNTdGF0ZWxlc3NGdW5jdGlvbiIsImlzUmVhY3RDb21wb25lbnQiLCJpc1N0eWxlZENvbXBvbmVudCIsInN0eWxlZENvbXBvbmVudElkIiwiU0NfQVRUUiIsImVudiIsIlJFQUNUX0FQUF9TQ19BVFRSIiwiU0NfVkVSU0lPTl9BVFRSIiwiU0NfU1RSRUFNX0FUVFIiLCJJU19CUk9XU0VSIiwid2luZG93IiwiRElTQUJMRV9TUEVFRFkiLCJTQ19ESVNBQkxFX1NQRUVEWSIsIlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSIsIlNUQVRJQ19FWEVDVVRJT05fQ09OVEVYVCIsIkVSUk9SUyIsImZvcm1hdCIsImEiLCJ1bmRlZmluZWQiLCJiIiwiYyIsImZvckVhY2giLCJkIiwicmVwbGFjZSIsIlN0eWxlZENvbXBvbmVudHNFcnJvciIsIl9FcnJvciIsImNvZGUiLCJfbGVuIiwiQXJyYXkiLCJfa2V5IiwiX3RoaXMiLCJqb2luIiwiYXBwbHkiLCJjb25jYXQiLCJ0cmltIiwiRXJyb3IiLCJTQ19DT01QT05FTlRfSUQiLCJleHRyYWN0Q29tcHMiLCJtYXliZUNTUyIsImNzcyIsImV4aXN0aW5nQ29tcG9uZW50cyIsIm1hdGNoIiwiY29tcG9uZW50SWQiLCJtYXRjaEluZGV4IiwibWFwIiwiX3JlZiIsIm5leHRDb21wIiwiY3NzRnJvbURPTSIsInNsaWNlIiwiQ09NTUVOVF9SRUdFWCIsInN0eWxpc1NwbGl0dGVyIiwiZ2xvYmFsIiwiY2FzY2FkZSIsImtleWZyYW1lIiwicHJlZml4IiwiY29tcHJlc3MiLCJzZW1pY29sb24iLCJzdHlsaXMiLCJwYXJzaW5nUnVsZXMiLCJyZXR1cm5SdWxlc1BsdWdpbiIsImNvbnRleHQiLCJwYXJzZWRSdWxlcyIsInBhcnNlUnVsZXNQbHVnaW4iLCJydWxlIiwiX2NvbXBvbmVudElkIiwiX3NlbGVjdG9yIiwiX3NlbGVjdG9yUmVnZXhwIiwic2VsZlJlZmVyZW5jZVJlcGxhY2VyIiwib2Zmc2V0Iiwic3RyaW5nIiwic2VsZlJlZmVyZW5jZVJlcGxhY2VtZW50UGx1Z2luIiwiXyIsInNlbGVjdG9ycyIsImxhc3RJbmRleE9mIiwidXNlIiwic3BsaXRCeVJ1bGVzIiwic3RyaW5naWZ5UnVsZXMiLCJydWxlcyIsInNlbGVjdG9yIiwiZmxhdENTUyIsImNzc1N0ciIsIlJlZ0V4cCIsImdldE5vbmNlIiwiX193ZWJwYWNrX25vbmNlX18iLCJhZGROYW1lRm9ySWQiLCJuYW1lcyIsImlkIiwibmFtZXNGb3JJZCIsInJlc2V0SWROYW1lcyIsImhhc05hbWVGb3JJZCIsInN0cmluZ2lmeU5hbWVzIiwic3RyIiwiY2xvbmVOYW1lcyIsImNsb25lIiwic2hlZXRGb3JUYWciLCJ0YWciLCJzaGVldCIsInNpemUiLCJvd25lckRvY3VtZW50Iiwic3R5bGVTaGVldHMiLCJvd25lck5vZGUiLCJzYWZlSW5zZXJ0UnVsZSIsImNzc1J1bGUiLCJpbmRleCIsIm1heEluZGV4IiwiY3NzUnVsZXMiLCJpbnNlcnRSdWxlIiwiZXJyIiwiZGVsZXRlUnVsZXMiLCJyZW1vdmFsSW5kZXgiLCJsb3dlckJvdW5kIiwiZGVsZXRlUnVsZSIsIm1ha2VUZXh0TWFya2VyIiwiYWRkVXBVbnRpbEluZGV4Iiwic2l6ZXMiLCJ0b3RhbFVwVG9JbmRleCIsIm1ha2VTdHlsZVRhZyIsInRhZ0VsIiwiaW5zZXJ0QmVmb3JlIiwidGFyZ2V0RG9jdW1lbnQiLCJkb2N1bWVudCIsImVsIiwic2V0QXR0cmlidXRlIiwibm9uY2UiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwicGFyZW50Tm9kZSIsIm5leHRTaWJsaW5nIiwid3JhcEFzSHRtbFRhZyIsImFkZGl0aW9uYWxBdHRycyIsImF0dHJzIiwiaHRtbEF0dHIiLCJmaWx0ZXIiLCJCb29sZWFuIiwid3JhcEFzRWxlbWVudCIsIl9wcm9wcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5IiwibWFya2VycyIsIm1ha2VTcGVlZHlUYWciLCJnZXRJbXBvcnRSdWxlVGFnIiwiZXh0cmFjdEltcG9ydCIsInVzZWRJbXBvcnRSdWxlVGFnIiwiaW5zZXJ0TWFya2VyIiwicHJldiIsImluc2VydFJ1bGVzIiwibWFya2VyIiwiaW5zZXJ0SW5kZXgiLCJpbmplY3RlZFJ1bGVzIiwiaW1wb3J0UnVsZXMiLCJjc3NSdWxlc1NpemUiLCJtYXlIYXZlSW1wb3J0IiwicmVtb3ZlUnVsZXMiLCJpc0Nvbm5lY3RlZCIsIl9zaGVldEZvclRhZyIsImVuZCIsImNzc1RleHQiLCJnZXRJZHMiLCJzZWFsZWQiLCJzdHlsZVRhZyIsInRvRWxlbWVudCIsInRvSFRNTCIsIm1ha2VUZXh0Tm9kZSIsIm1ha2VCcm93c2VyVGFnIiwic2VwYXJhdG9yIiwiYXBwZW5kRGF0YSIsIm5ld01hcmtlciIsInJlcGxhY2VDaGlsZCIsImRhdGEiLCJtYWtlU2VydmVyVGFnIiwibmFtZXNBcmciLCJtYXJrZXJzQXJnIiwiY3NzRm9ySWQiLCJuYW1lc0Nsb25lIiwibWFya2Vyc0Nsb25lIiwibWFrZVRhZyIsImZvcmNlU2VydmVyIiwicmVoeWRyYXRlIiwiZWxzIiwiZXh0cmFjdGVkIiwiX2V4dHJhY3RlZCRpIiwiX2kiLCJyZW1vdmVDaGlsZCIsIlNQTElUX1JFR0VYIiwiTUFYX1NJWkUiLCJzaGVldFJ1bm5pbmdJZCIsIm1hc3RlciIsIlN0eWxlU2hlZXQiLCJoZWFkIiwiaW1wb3J0UnVsZVRhZyIsImZpcnN0VGFnIiwidGFncyIsInRhZ01hcCIsImRlZmVycmVkIiwicmVoeWRyYXRlZE5hbWVzIiwiaWdub3JlUmVoeWRyYXRlZE5hbWVzIiwiY2FwYWNpdHkiLCJjbG9uZXMiLCJyZWh5ZHJhdGUkJDEiLCJpc1N0cmVhbWVkIiwibm9kZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwibm9kZXNTaXplIiwiZ2V0QXR0cmlidXRlIiwiZWxOYW1lcyIsInNwbGl0IiwiZWxOYW1lc1NpemUiLCJqIiwidGV4dENvbnRlbnQiLCJleHRyYWN0ZWRTaXplIiwiTWF0aCIsIm1heCIsIl9qIiwicmVzZXQiLCJpZHMiLCJuZXdUYWciLCJzZWFsQWxsVGFncyIsIm1ha2VUYWckJDEiLCJsYXN0RWwiLCJnZXRUYWdGb3JJZCIsImhhc0lkIiwiZGVmZXJyZWRJbmplY3QiLCJpbmplY3QiLCJyZW1vdmUiLCJ0b1JlYWN0RWxlbWVudHMiLCJnZXQiLCJnZXQkJDEiLCJLZXlmcmFtZXMiLCJzdHlsZVNoZWV0IiwidG9TdHJpbmciLCJTdHJpbmciLCJnZXROYW1lIiwidXBwZXJjYXNlUGF0dGVybiIsIm1zUGF0dGVybiIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsInRvTG93ZXJDYXNlIiwiYWRkVW5pdElmTmVlZGVkIiwiaXNGYWxzaXNoIiwiY2h1bmsiLCJvYmpUb0Nzc0FycmF5IiwicHJldktleSIsImZsYXR0ZW4iLCJleGVjdXRpb25Db250ZXh0IiwiaXNBcnJheSIsInJ1bGVTZXQiLCJfcmVzdWx0IiwiY29uc29sZSIsIndhcm4iLCJzdHlsZXMiLCJjb25zdHJ1Y3RXaXRoT3B0aW9ucyIsImNvbXBvbmVudENvbnN0cnVjdG9yIiwib3B0aW9ucyIsInRlbXBsYXRlRnVuY3Rpb24iLCJ3aXRoQ29uZmlnIiwiY29uZmlnIiwibXVybXVyaGFzaCIsImUiLCJjaGFyQ29kZUF0IiwiY2hhcnNMZW5ndGgiLCJnZXRBbHBoYWJldGljQ2hhciIsImZyb21DaGFyQ29kZSIsImdlbmVyYXRlQWxwaGFiZXRpY05hbWUiLCJmbG9vciIsImhhc0Z1bmN0aW9uT2JqZWN0S2V5IiwiaXNTdGF0aWNSdWxlcyIsInNvbWUiLCJoYXNoZXIiLCJDb21wb25lbnRTdHlsZSIsImlzU3RhdGljIiwiZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMiLCJsYXN0Q2xhc3NOYW1lIiwiZ2VuZXJhdGVOYW1lIiwiTElNSVQiLCJjcmVhdGVXYXJuVG9vTWFueUNsYXNzZXMiLCJnZW5lcmF0ZWRDbGFzc2VzIiwid2FybmluZ1NlZW4iLCJjbGFzc05hbWUiLCJkZXRlcm1pbmVUaGVtZSIsImZhbGxiYWNrVGhlbWUiLCJkZWZhdWx0UHJvcHMiLCJpc0RlZmF1bHRUaGVtZSIsInRoZW1lIiwiZXNjYXBlUmVnZXgiLCJkYXNoZXNBdEVuZHMiLCJlc2NhcGUiLCJpc1RhZyIsImNoYXJBdCIsImdlbmVyYXRlRGlzcGxheU5hbWUiLCJfVFlQRV9TVEFUSUNTIiwiUkVBQ1RfU1RBVElDUyIsImNoaWxkQ29udGV4dFR5cGVzIiwiY29udGV4dFR5cGVzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwicHJvcFR5cGVzIiwidHlwZSIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJjYWxsZWUiLCJhcml0eSIsIlRZUEVfU1RBVElDUyIsIiQkdHlwZW9mIiwicmVuZGVyIiwiZGVmaW5lUHJvcGVydHkkMSIsImdldE93blByb3BlcnR5TmFtZXMiLCJfT2JqZWN0JGdldE93blByb3BlcnQiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXRQcm90b3R5cGVPZiIsIm9iamVjdFByb3RvdHlwZSIsImFycmF5UHJvdG90eXBlIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJibGFja2xpc3QiLCJpbmhlcml0ZWRDb21wb25lbnQiLCJ0YXJnZXRTdGF0aWNzIiwic291cmNlU3RhdGljcyIsImlzRGVyaXZlZFJlYWN0Q29tcG9uZW50IiwiZm4iLCJvbmNlIiwiY2IiLCJjYWxsZWQiLCJUaGVtZUNvbnRleHQiLCJUaGVtZUNvbnN1bWVyIiwiQ29uc3VtZXIiLCJUaGVtZVByb3ZpZGVyIiwiX0NvbXBvbmVudCIsImdldENvbnRleHQiLCJiaW5kIiwicmVuZGVySW5uZXIiLCJjaGlsZHJlbiIsIm91dGVyVGhlbWUiLCJQcm92aWRlciIsImdldFRoZW1lIiwibWVyZ2VkVGhlbWUiLCJDTE9TSU5HX1RBR19SIiwiU2VydmVyU3R5bGVTaGVldCIsIm1hc3RlclNoZWV0Iiwic2VhbCIsInNwbGljZSIsImNvbGxlY3RTdHlsZXMiLCJTdHlsZVNoZWV0TWFuYWdlciIsImdldFN0eWxlVGFncyIsImdldFN0eWxlRWxlbWVudCIsImludGVybGVhdmVXaXRoTm9kZVN0cmVhbSIsInJlYWRhYmxlU3RyZWFtIiwiaW5zdGFuY2VUYWdJbmRleCIsInN0cmVhbUF0dHIiLCJ0cmFuc2Zvcm1lciIsIlRyYW5zZm9ybSIsInRyYW5zZm9ybSIsImFwcGVuZFN0eWxlQ2h1bmtzIiwiY2FsbGJhY2siLCJodG1sIiwicmVuZGVyZWRIdG1sIiwiZW5kT2ZDbG9zaW5nVGFnIiwib24iLCJlbWl0IiwicGlwZSIsIlN0eWxlU2hlZXRDb250ZXh0IiwiU3R5bGVTaGVldENvbnN1bWVyIiwiQ2hpbGRyZW4iLCJvbmx5Iiwib25lT2ZUeXBlIiwiaW5zdGFuY2VPZiIsInNoYXBlIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJpZGVudGlmaWVycyIsImdlbmVyYXRlSWQiLCJfQ29tcG9uZW50U3R5bGUiLCJfZGlzcGxheU5hbWUiLCJwYXJlbnRDb21wb25lbnRJZCIsIm5yIiwiU3R5bGVkQ29tcG9uZW50IiwicmVuZGVyT3V0ZXIiLCJ3YXJuSW5uZXJSZWYiLCJ3YXJuQXR0cnNGbk9iamVjdEtleURlcHJlY2F0ZWQiLCJzdGFjayIsIndhcm5Ob25TdHlsZWRDb21wb25lbnRBdHRyc09iamVjdEtleSIsImZvcndhcmRlZENvbXBvbmVudCIsImNvbXBvbmVudFN0eWxlIiwiX3Byb3BzJGZvcndhcmRlZENvbXBvIiwiZm9sZGVkQ29tcG9uZW50SWRzIiwiZ2VuZXJhdGVkQ2xhc3NOYW1lIiwiZWxlbWVudFRvQmVDcmVhdGVkIiwiYXMiLCJpc1RhcmdldFRhZyIsInByb3BzRm9yRWxlbWVudCIsImNvbXB1dGVkUHJvcHMiLCJyZWYiLCJzdHlsZSIsImJ1aWxkRXhlY3V0aW9uQ29udGV4dCIsIl90aGlzMiIsImF0dHJEZWYiLCJyZXNvbHZlZEF0dHJEZWYiLCJhdHRyRGVmV2FzRm4iLCJhdHRyIiwiaXNWYWxpZEVsZW1lbnQiLCJfcHJvcHMkZm9yd2FyZGVkQ29tcG8yIiwid2FyblRvb01hbnlDbGFzc2VzIiwiY3JlYXRlU3R5bGVkQ29tcG9uZW50IiwiaXNUYXJnZXRTdHlsZWRDb21wIiwiaXNDbGFzcyIsIl9vcHRpb25zJGRpc3BsYXlOYW1lIiwiX29wdGlvbnMkY29tcG9uZW50SWQiLCJfb3B0aW9ucyRQYXJlbnRDb21wb24iLCJQYXJlbnRDb21wb25lbnQiLCJfb3B0aW9ucyRhdHRycyIsImZpbmFsQXR0cnMiLCJXcmFwcGVkU3R5bGVkQ29tcG9uZW50IiwiZm9yd2FyZFJlZiIsImZvcndhcmRlZFJlZiIsIndpdGhDb21wb25lbnQiLCJwcmV2aW91c0NvbXBvbmVudElkIiwib3B0aW9uc1RvQ29weSIsIm5ld0NvbXBvbmVudElkIiwibmV3T3B0aW9ucyIsIl9mb2xkZWREZWZhdWx0UHJvcHMiLCJzZXQiLCJzZXQkJDEiLCJkb21FbGVtZW50cyIsInN0eWxlZCIsImRvbUVsZW1lbnQiLCJHbG9iYWxTdHlsZSIsImNyZWF0ZVN0eWxlcyIsInJlbW92ZVN0eWxlcyIsInJlbmRlclN0eWxlcyIsInNjQ0dTSE1SQ2FjaGUiLCJjcmVhdGVHbG9iYWxTdHlsZSIsIkpTT04iLCJzdHJpbmdpZnkiLCJHbG9iYWxTdHlsZUNvbXBvbmVudCIsIl9SZWFjdCRDb21wb25lbnQiLCJfdGhpcyRjb25zdHJ1Y3RvciIsImdsb2JhbFN0eWxlIiwic3RhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImNvdW50IiwicmVwbGFjZVdoaXRlc3BhY2UiLCJrZXlmcmFtZXMiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0Iiwid2l0aFRoZW1lIiwiQ29tcG9uZW50JCQxIiwiV2l0aFRoZW1lIiwidGhlbWVQcm9wIiwiX19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0hBVU5URURfQllfU1BPT0tZX0dIT1NUUyIsInVzZXJBZ2VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/node_modules/styled-components/dist/styled-components.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/better-react-carousel/node_modules/stylis-rule-sheet/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/better-react-carousel/node_modules/stylis-rule-sheet/index.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("(function(factory) {\n     true ? module[\"exports\"] = factory() : 0;\n})(function() {\n    \"use strict\";\n    return function(insertRule) {\n        var delimiter = \"/*|*/\";\n        var needle = delimiter + \"}\";\n        function toSheet(block) {\n            if (block) try {\n                insertRule(block + \"}\");\n            } catch (e) {}\n        }\n        return function ruleSheet(context, content, selectors, parents, line, column, length, ns, depth, at) {\n            switch(context){\n                // property\n                case 1:\n                    // @import\n                    if (depth === 0 && content.charCodeAt(0) === 64) return insertRule(content + \";\"), \"\";\n                    break;\n                // selector\n                case 2:\n                    if (ns === 0) return content + delimiter;\n                    break;\n                // at-rule\n                case 3:\n                    switch(ns){\n                        // @font-face, @page\n                        case 102:\n                        case 112:\n                            return insertRule(selectors[0] + content), \"\";\n                        default:\n                            return content + (at === 0 ? delimiter : \"\");\n                    }\n                case -2:\n                    content.split(needle).forEach(toSheet);\n            }\n        };\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9zdHlsaXMtcnVsZS1zaGVldC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxPQUFPO0lBQ2pCLEtBQWlELEdBQWVFLE1BQU0sQ0FBQyxVQUFVLEdBQUdGLFlBQ25GLENBQ3VDQTtBQUN6QyxHQUFFO0lBRUQ7SUFFQSxPQUFPLFNBQVVLLFVBQVU7UUFDMUIsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxTQUFTRCxZQUFVO1FBRXZCLFNBQVNFLFFBQVNDLEtBQUs7WUFDdEIsSUFBSUEsT0FDSCxJQUFJO2dCQUNISixXQUFXSSxRQUFRO1lBQ3BCLEVBQUUsT0FBT0MsR0FBRyxDQUFDO1FBQ2Y7UUFFQSxPQUFPLFNBQVNDLFVBQVdDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxLQUFLLEVBQUVDLEVBQUU7WUFDbkcsT0FBUVQ7Z0JBQ1AsV0FBVztnQkFDWCxLQUFLO29CQUNKLFVBQVU7b0JBQ1YsSUFBSVEsVUFBVSxLQUFLUCxRQUFRUyxVQUFVLENBQUMsT0FBTyxJQUM1QyxPQUFPakIsV0FBV1EsVUFBUSxNQUFNO29CQUNqQztnQkFDRCxXQUFXO2dCQUNYLEtBQUs7b0JBQ0osSUFBSU0sT0FBTyxHQUNWLE9BQU9OLFVBQVVQO29CQUNsQjtnQkFDRCxVQUFVO2dCQUNWLEtBQUs7b0JBQ0osT0FBUWE7d0JBQ1Asb0JBQW9CO3dCQUNwQixLQUFLO3dCQUNMLEtBQUs7NEJBQ0osT0FBT2QsV0FBV1MsU0FBUyxDQUFDLEVBQUUsR0FBQ0QsVUFBVTt3QkFDMUM7NEJBQ0MsT0FBT0EsVUFBV1EsQ0FBQUEsT0FBTyxJQUFJZixZQUFZLEVBQUM7b0JBQzVDO2dCQUNELEtBQUssQ0FBQztvQkFDTE8sUUFBUVUsS0FBSyxDQUFDaEIsUUFBUWlCLE9BQU8sQ0FBQ2hCO1lBQ2hDO1FBQ0Q7SUFDRDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHVoYWNrc18zLy4vbm9kZV9tb2R1bGVzL2JldHRlci1yZWFjdC1jYXJvdXNlbC9ub2RlX21vZHVsZXMvc3R5bGlzLXJ1bGUtc2hlZXQvaW5kZXguanM/OGE2MCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gKG1vZHVsZVsnZXhwb3J0cyddID0gZmFjdG9yeSgpKSA6XG5cdFx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddID8gZGVmaW5lKGZhY3RvcnkoKSkgOlxuXHRcdFx0KHdpbmRvd1snc3R5bGlzUnVsZVNoZWV0J10gPSBmYWN0b3J5KCkpXG59KGZ1bmN0aW9uICgpIHtcblxuXHQndXNlIHN0cmljdCdcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluc2VydFJ1bGUpIHtcblx0XHR2YXIgZGVsaW1pdGVyID0gJy8qfCovJ1xuXHRcdHZhciBuZWVkbGUgPSBkZWxpbWl0ZXIrJ30nXG5cblx0XHRmdW5jdGlvbiB0b1NoZWV0IChibG9jaykge1xuXHRcdFx0aWYgKGJsb2NrKVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGluc2VydFJ1bGUoYmxvY2sgKyAnfScpXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJ1bGVTaGVldCAoY29udGV4dCwgY29udGVudCwgc2VsZWN0b3JzLCBwYXJlbnRzLCBsaW5lLCBjb2x1bW4sIGxlbmd0aCwgbnMsIGRlcHRoLCBhdCkge1xuXHRcdFx0c3dpdGNoIChjb250ZXh0KSB7XG5cdFx0XHRcdC8vIHByb3BlcnR5XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHQvLyBAaW1wb3J0XG5cdFx0XHRcdFx0aWYgKGRlcHRoID09PSAwICYmIGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gNjQpXG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5zZXJ0UnVsZShjb250ZW50Kyc7JyksICcnXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Ly8gc2VsZWN0b3Jcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdGlmIChucyA9PT0gMClcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ICsgZGVsaW1pdGVyXG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0Ly8gYXQtcnVsZVxuXHRcdFx0XHRjYXNlIDM6XG5cdFx0XHRcdFx0c3dpdGNoIChucykge1xuXHRcdFx0XHRcdFx0Ly8gQGZvbnQtZmFjZSwgQHBhZ2Vcblx0XHRcdFx0XHRcdGNhc2UgMTAyOlxuXHRcdFx0XHRcdFx0Y2FzZSAxMTI6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpbnNlcnRSdWxlKHNlbGVjdG9yc1swXStjb250ZW50KSwgJydcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ICsgKGF0ID09PSAwID8gZGVsaW1pdGVyIDogJycpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIC0yOlxuXHRcdFx0XHRcdGNvbnRlbnQuc3BsaXQobmVlZGxlKS5mb3JFYWNoKHRvU2hlZXQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59KSlcbiJdLCJuYW1lcyI6WyJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsIndpbmRvdyIsImluc2VydFJ1bGUiLCJkZWxpbWl0ZXIiLCJuZWVkbGUiLCJ0b1NoZWV0IiwiYmxvY2siLCJlIiwicnVsZVNoZWV0IiwiY29udGV4dCIsImNvbnRlbnQiLCJzZWxlY3RvcnMiLCJwYXJlbnRzIiwibGluZSIsImNvbHVtbiIsImxlbmd0aCIsIm5zIiwiZGVwdGgiLCJhdCIsImNoYXJDb2RlQXQiLCJzcGxpdCIsImZvckVhY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/node_modules/stylis-rule-sheet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/better-react-carousel/node_modules/stylis/stylis.min.js":
/*!******************************************************************************!*\
  !*** ./node_modules/better-react-carousel/node_modules/stylis/stylis.min.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("!function(e) {\n     true ? module.exports = e(null) : 0;\n}(function e(a) {\n    \"use strict\";\n    var r = /^\\0+/g, c = /[\\0\\r\\f]/g, s = /: */g, t = /zoo|gra/, i = /([,: ])(transform)/g, f = /,+\\s*(?![^(]*[)])/g, n = / +\\s*(?![^(]*[)])/g, l = / *[\\0] */g, o = /,\\r+?/g, h = /([\\t\\r\\n ])*\\f?&/g, u = /:global\\(((?:[^\\(\\)\\[\\]]*|\\[.*\\]|\\([^\\(\\)]*\\))*)\\)/g, d = /\\W+/g, b = /@(k\\w+)\\s*(\\S*)\\s*/, p = /::(place)/g, k = /:(read-only)/g, g = /\\s+(?=[{\\];=:>])/g, A = /([[}=:>])\\s+/g, C = /(\\{[^{]+?);(?=\\})/g, w = /\\s{2,}/g, v = /([^\\(])(:+) */g, m = /[svh]\\w+-[tblr]{2}/, x = /\\(\\s*(.*)\\s*\\)/g, $ = /([\\s\\S]*?);/g, y = /-self|flex-/g, O = /[^]*?(:[rp][el]a[\\w-]+)[^]*/, j = /stretch|:\\s*\\w+\\-(?:conte|avail)/, z = /([^-])(image-set\\()/, N = \"-webkit-\", S = \"-moz-\", F = \"-ms-\", W = 59, q = 125, B = 123, D = 40, E = 41, G = 91, H = 93, I = 10, J = 13, K = 9, L = 64, M = 32, P = 38, Q = 45, R = 95, T = 42, U = 44, V = 58, X = 39, Y = 34, Z = 47, _ = 62, ee = 43, ae = 126, re = 0, ce = 12, se = 11, te = 107, ie = 109, fe = 115, ne = 112, le = 111, oe = 105, he = 99, ue = 100, de = 112, be = 1, pe = 1, ke = 0, ge = 1, Ae = 1, Ce = 1, we = 0, ve = 0, me = 0, xe = [], $e = [], ye = 0, Oe = null, je = -2, ze = -1, Ne = 0, Se = 1, Fe = 2, We = 3, qe = 0, Be = 1, De = \"\", Ee = \"\", Ge = \"\";\n    function He(e, a, s, t, i) {\n        for(var f, n, o = 0, h = 0, u = 0, d = 0, g = 0, A = 0, C = 0, w = 0, m = 0, $ = 0, y = 0, O = 0, j = 0, z = 0, R = 0, we = 0, $e = 0, Oe = 0, je = 0, ze = s.length, Je = ze - 1, Re = \"\", Te = \"\", Ue = \"\", Ve = \"\", Xe = \"\", Ye = \"\"; R < ze;){\n            if (C = s.charCodeAt(R), R === Je) {\n                if (h + d + u + o !== 0) {\n                    if (0 !== h) C = h === Z ? I : Z;\n                    d = u = o = 0, ze++, Je++;\n                }\n            }\n            if (h + d + u + o === 0) {\n                if (R === Je) {\n                    if (we > 0) Te = Te.replace(c, \"\");\n                    if (Te.trim().length > 0) {\n                        switch(C){\n                            case M:\n                            case K:\n                            case W:\n                            case J:\n                            case I:\n                                break;\n                            default:\n                                Te += s.charAt(R);\n                        }\n                        C = W;\n                    }\n                }\n                if (1 === $e) switch(C){\n                    case B:\n                    case q:\n                    case W:\n                    case Y:\n                    case X:\n                    case D:\n                    case E:\n                    case U:\n                        $e = 0;\n                    case K:\n                    case J:\n                    case I:\n                    case M:\n                        break;\n                    default:\n                        for($e = 0, je = R, g = C, R--, C = W; je < ze;)switch(s.charCodeAt(je++)){\n                            case I:\n                            case J:\n                            case W:\n                                ++R, C = g, je = ze;\n                                break;\n                            case V:\n                                if (we > 0) ++R, C = g;\n                            case B:\n                                je = ze;\n                        }\n                }\n                switch(C){\n                    case B:\n                        for(g = (Te = Te.trim()).charCodeAt(0), y = 1, je = ++R; R < ze;){\n                            switch(C = s.charCodeAt(R)){\n                                case B:\n                                    y++;\n                                    break;\n                                case q:\n                                    y--;\n                                    break;\n                                case Z:\n                                    switch(A = s.charCodeAt(R + 1)){\n                                        case T:\n                                        case Z:\n                                            R = Qe(A, R, Je, s);\n                                    }\n                                    break;\n                                case G:\n                                    C++;\n                                case D:\n                                    C++;\n                                case Y:\n                                case X:\n                                    for(; R++ < Je && s.charCodeAt(R) !== C;);\n                            }\n                            if (0 === y) break;\n                            R++;\n                        }\n                        if (Ue = s.substring(je, R), g === re) g = (Te = Te.replace(r, \"\").trim()).charCodeAt(0);\n                        switch(g){\n                            case L:\n                                if (we > 0) Te = Te.replace(c, \"\");\n                                switch(A = Te.charCodeAt(1)){\n                                    case ue:\n                                    case ie:\n                                    case fe:\n                                    case Q:\n                                        f = a;\n                                        break;\n                                    default:\n                                        f = xe;\n                                }\n                                if (je = (Ue = He(a, f, Ue, A, i + 1)).length, me > 0 && 0 === je) je = Te.length;\n                                if (ye > 0) {\n                                    if (f = Ie(xe, Te, Oe), n = Pe(We, Ue, f, a, pe, be, je, A, i, t), Te = f.join(\"\"), void 0 !== n) {\n                                        if (0 === (je = (Ue = n.trim()).length)) A = 0, Ue = \"\";\n                                    }\n                                }\n                                if (je > 0) switch(A){\n                                    case fe:\n                                        Te = Te.replace(x, Me);\n                                    case ue:\n                                    case ie:\n                                    case Q:\n                                        Ue = Te + \"{\" + Ue + \"}\";\n                                        break;\n                                    case te:\n                                        if (Ue = (Te = Te.replace(b, \"$1 $2\" + (Be > 0 ? De : \"\"))) + \"{\" + Ue + \"}\", 1 === Ae || 2 === Ae && Le(\"@\" + Ue, 3)) Ue = \"@\" + N + Ue + \"@\" + Ue;\n                                        else Ue = \"@\" + Ue;\n                                        break;\n                                    default:\n                                        if (Ue = Te + Ue, t === de) Ve += Ue, Ue = \"\";\n                                }\n                                else Ue = \"\";\n                                break;\n                            default:\n                                Ue = He(a, Ie(a, Te, Oe), Ue, t, i + 1);\n                        }\n                        Xe += Ue, O = 0, $e = 0, z = 0, we = 0, Oe = 0, j = 0, Te = \"\", Ue = \"\", C = s.charCodeAt(++R);\n                        break;\n                    case q:\n                    case W:\n                        if ((je = (Te = (we > 0 ? Te.replace(c, \"\") : Te).trim()).length) > 1) {\n                            if (0 === z) {\n                                if ((g = Te.charCodeAt(0)) === Q || g > 96 && g < 123) je = (Te = Te.replace(\" \", \":\")).length;\n                            }\n                            if (ye > 0) {\n                                if (void 0 !== (n = Pe(Se, Te, a, e, pe, be, Ve.length, t, i, t))) {\n                                    if (0 === (je = (Te = n.trim()).length)) Te = \"\\x00\\x00\";\n                                }\n                            }\n                            switch(g = Te.charCodeAt(0), A = Te.charCodeAt(1), g){\n                                case re:\n                                    break;\n                                case L:\n                                    if (A === oe || A === he) {\n                                        Ye += Te + s.charAt(R);\n                                        break;\n                                    }\n                                default:\n                                    if (Te.charCodeAt(je - 1) === V) break;\n                                    Ve += Ke(Te, g, A, Te.charCodeAt(2));\n                            }\n                        }\n                        O = 0, $e = 0, z = 0, we = 0, Oe = 0, Te = \"\", C = s.charCodeAt(++R);\n                }\n            }\n            switch(C){\n                case J:\n                case I:\n                    if (h + d + u + o + ve === 0) switch($){\n                        case E:\n                        case X:\n                        case Y:\n                        case L:\n                        case ae:\n                        case _:\n                        case T:\n                        case ee:\n                        case Z:\n                        case Q:\n                        case V:\n                        case U:\n                        case W:\n                        case B:\n                        case q:\n                            break;\n                        default:\n                            if (z > 0) $e = 1;\n                    }\n                    if (h === Z) h = 0;\n                    else if (ge + O === 0 && t !== te && Te.length > 0) we = 1, Te += \"\\x00\";\n                    if (ye * qe > 0) Pe(Ne, Te, a, e, pe, be, Ve.length, t, i, t);\n                    be = 1, pe++;\n                    break;\n                case W:\n                case q:\n                    if (h + d + u + o === 0) {\n                        be++;\n                        break;\n                    }\n                default:\n                    switch(be++, Re = s.charAt(R), C){\n                        case K:\n                        case M:\n                            if (d + o + h === 0) switch(w){\n                                case U:\n                                case V:\n                                case K:\n                                case M:\n                                    Re = \"\";\n                                    break;\n                                default:\n                                    if (C !== M) Re = \" \";\n                            }\n                            break;\n                        case re:\n                            Re = \"\\\\0\";\n                            break;\n                        case ce:\n                            Re = \"\\\\f\";\n                            break;\n                        case se:\n                            Re = \"\\\\v\";\n                            break;\n                        case P:\n                            if (d + h + o === 0 && ge > 0) Oe = 1, we = 1, Re = \"\\f\" + Re;\n                            break;\n                        case 108:\n                            if (d + h + o + ke === 0 && z > 0) switch(R - z){\n                                case 2:\n                                    if (w === ne && s.charCodeAt(R - 3) === V) ke = w;\n                                case 8:\n                                    if (m === le) ke = m;\n                            }\n                            break;\n                        case V:\n                            if (d + h + o === 0) z = R;\n                            break;\n                        case U:\n                            if (h + u + d + o === 0) we = 1, Re += \"\\r\";\n                            break;\n                        case Y:\n                        case X:\n                            if (0 === h) d = d === C ? 0 : 0 === d ? C : d;\n                            break;\n                        case G:\n                            if (d + h + u === 0) o++;\n                            break;\n                        case H:\n                            if (d + h + u === 0) o--;\n                            break;\n                        case E:\n                            if (d + h + o === 0) u--;\n                            break;\n                        case D:\n                            if (d + h + o === 0) {\n                                if (0 === O) switch(2 * w + 3 * m){\n                                    case 533:\n                                        break;\n                                    default:\n                                        y = 0, O = 1;\n                                }\n                                u++;\n                            }\n                            break;\n                        case L:\n                            if (h + u + d + o + z + j === 0) j = 1;\n                            break;\n                        case T:\n                        case Z:\n                            if (d + o + u > 0) break;\n                            switch(h){\n                                case 0:\n                                    switch(2 * C + 3 * s.charCodeAt(R + 1)){\n                                        case 235:\n                                            h = Z;\n                                            break;\n                                        case 220:\n                                            je = R, h = T;\n                                    }\n                                    break;\n                                case T:\n                                    if (C === Z && w === T && je + 2 !== R) {\n                                        if (33 === s.charCodeAt(je + 2)) Ve += s.substring(je, R + 1);\n                                        Re = \"\", h = 0;\n                                    }\n                            }\n                    }\n                    if (0 === h) {\n                        if (ge + d + o + j === 0 && t !== te && C !== W) switch(C){\n                            case U:\n                            case ae:\n                            case _:\n                            case ee:\n                            case E:\n                            case D:\n                                if (0 === O) {\n                                    switch(w){\n                                        case K:\n                                        case M:\n                                        case I:\n                                        case J:\n                                            Re += \"\\x00\";\n                                            break;\n                                        default:\n                                            Re = \"\\x00\" + Re + (C === U ? \"\" : \"\\x00\");\n                                    }\n                                    we = 1;\n                                } else switch(C){\n                                    case D:\n                                        if (z + 7 === R && 108 === w) z = 0;\n                                        O = ++y;\n                                        break;\n                                    case E:\n                                        if (0 == (O = --y)) we = 1, Re += \"\\x00\";\n                                }\n                                break;\n                            case K:\n                            case M:\n                                switch(w){\n                                    case re:\n                                    case B:\n                                    case q:\n                                    case W:\n                                    case U:\n                                    case ce:\n                                    case K:\n                                    case M:\n                                    case I:\n                                    case J:\n                                        break;\n                                    default:\n                                        if (0 === O) we = 1, Re += \"\\x00\";\n                                }\n                        }\n                        if (Te += Re, C !== M && C !== K) $ = C;\n                    }\n            }\n            m = w, w = C, R++;\n        }\n        if (je = Ve.length, me > 0) {\n            if (0 === je && 0 === Xe.length && 0 === a[0].length == false) {\n                if (t !== ie || 1 === a.length && (ge > 0 ? Ee : Ge) === a[0]) je = a.join(\",\").length + 2;\n            }\n        }\n        if (je > 0) {\n            if (f = 0 === ge && t !== te ? function(e) {\n                for(var a, r, s = 0, t = e.length, i = Array(t); s < t; ++s){\n                    for(var f = e[s].split(l), n = \"\", o = 0, h = 0, u = 0, d = 0, b = f.length; o < b; ++o){\n                        if (0 === (h = (r = f[o]).length) && b > 1) continue;\n                        if (u = n.charCodeAt(n.length - 1), d = r.charCodeAt(0), a = \"\", 0 !== o) switch(u){\n                            case T:\n                            case ae:\n                            case _:\n                            case ee:\n                            case M:\n                            case D:\n                                break;\n                            default:\n                                a = \" \";\n                        }\n                        switch(d){\n                            case P:\n                                r = a + Ee;\n                            case ae:\n                            case _:\n                            case ee:\n                            case M:\n                            case E:\n                            case D:\n                                break;\n                            case G:\n                                r = a + r + Ee;\n                                break;\n                            case V:\n                                switch(2 * r.charCodeAt(1) + 3 * r.charCodeAt(2)){\n                                    case 530:\n                                        if (Ce > 0) {\n                                            r = a + r.substring(8, h - 1);\n                                            break;\n                                        }\n                                    default:\n                                        if (o < 1 || f[o - 1].length < 1) r = a + Ee + r;\n                                }\n                                break;\n                            case U:\n                                a = \"\";\n                            default:\n                                if (h > 1 && r.indexOf(\":\") > 0) r = a + r.replace(v, \"$1\" + Ee + \"$2\");\n                                else r = a + r + Ee;\n                        }\n                        n += r;\n                    }\n                    i[s] = n.replace(c, \"\").trim();\n                }\n                return i;\n            }(a) : a, ye > 0) {\n                if (void 0 !== (n = Pe(Fe, Ve, f, e, pe, be, je, t, i, t)) && 0 === (Ve = n).length) return Ye + Ve + Xe;\n            }\n            if (Ve = f.join(\",\") + \"{\" + Ve + \"}\", Ae * ke != 0) {\n                if (2 === Ae && !Le(Ve, 2)) ke = 0;\n                switch(ke){\n                    case le:\n                        Ve = Ve.replace(k, \":\" + S + \"$1\") + Ve;\n                        break;\n                    case ne:\n                        Ve = Ve.replace(p, \"::\" + N + \"input-$1\") + Ve.replace(p, \"::\" + S + \"$1\") + Ve.replace(p, \":\" + F + \"input-$1\") + Ve;\n                }\n                ke = 0;\n            }\n        }\n        return Ye + Ve + Xe;\n    }\n    function Ie(e, a, r) {\n        var c = a.trim().split(o), s = c, t = c.length, i = e.length;\n        switch(i){\n            case 0:\n            case 1:\n                for(var f = 0, n = 0 === i ? \"\" : e[0] + \" \"; f < t; ++f)s[f] = Je(n, s[f], r, i).trim();\n                break;\n            default:\n                f = 0;\n                var l = 0;\n                for(s = []; f < t; ++f)for(var h = 0; h < i; ++h)s[l++] = Je(e[h] + \" \", c[f], r, i).trim();\n        }\n        return s;\n    }\n    function Je(e, a, r, c) {\n        var s = a, t = s.charCodeAt(0);\n        if (t < 33) t = (s = s.trim()).charCodeAt(0);\n        switch(t){\n            case P:\n                switch(ge + c){\n                    case 0:\n                    case 1:\n                        if (0 === e.trim().length) break;\n                    default:\n                        return s.replace(h, \"$1\" + e.trim());\n                }\n                break;\n            case V:\n                switch(s.charCodeAt(1)){\n                    case 103:\n                        if (Ce > 0 && ge > 0) return s.replace(u, \"$1\").replace(h, \"$1\" + Ge);\n                        break;\n                    default:\n                        return e.trim() + s.replace(h, \"$1\" + e.trim());\n                }\n            default:\n                if (r * ge > 0 && s.indexOf(\"\\f\") > 0) return s.replace(h, (e.charCodeAt(0) === V ? \"\" : \"$1\") + e.trim());\n        }\n        return e + s;\n    }\n    function Ke(e, a, r, c) {\n        var l, o = 0, h = e + \";\", u = 2 * a + 3 * r + 4 * c;\n        if (944 === u) return function(e) {\n            var a = e.length, r = e.indexOf(\":\", 9) + 1, c = e.substring(0, r).trim(), s = e.substring(r, a - 1).trim();\n            switch(e.charCodeAt(9) * Be){\n                case 0:\n                    break;\n                case Q:\n                    if (110 !== e.charCodeAt(10)) break;\n                default:\n                    for(var t = s.split((s = \"\", f)), i = 0, r = 0, a = t.length; i < a; r = 0, ++i){\n                        for(var l = t[i], o = l.split(n); l = o[r];){\n                            var h = l.charCodeAt(0);\n                            if (1 === Be && (h > L && h < 90 || h > 96 && h < 123 || h === R || h === Q && l.charCodeAt(1) !== Q)) switch(isNaN(parseFloat(l)) + (-1 !== l.indexOf(\"(\"))){\n                                case 1:\n                                    switch(l){\n                                        case \"infinite\":\n                                        case \"alternate\":\n                                        case \"backwards\":\n                                        case \"running\":\n                                        case \"normal\":\n                                        case \"forwards\":\n                                        case \"both\":\n                                        case \"none\":\n                                        case \"linear\":\n                                        case \"ease\":\n                                        case \"ease-in\":\n                                        case \"ease-out\":\n                                        case \"ease-in-out\":\n                                        case \"paused\":\n                                        case \"reverse\":\n                                        case \"alternate-reverse\":\n                                        case \"inherit\":\n                                        case \"initial\":\n                                        case \"unset\":\n                                        case \"step-start\":\n                                        case \"step-end\":\n                                            break;\n                                        default:\n                                            l += De;\n                                    }\n                            }\n                            o[r++] = l;\n                        }\n                        s += (0 === i ? \"\" : \",\") + o.join(\" \");\n                    }\n            }\n            if (s = c + s + \";\", 1 === Ae || 2 === Ae && Le(s, 1)) return N + s + s;\n            return s;\n        }(h);\n        else if (0 === Ae || 2 === Ae && !Le(h, 1)) return h;\n        switch(u){\n            case 1015:\n                return 97 === h.charCodeAt(10) ? N + h + h : h;\n            case 951:\n                return 116 === h.charCodeAt(3) ? N + h + h : h;\n            case 963:\n                return 110 === h.charCodeAt(5) ? N + h + h : h;\n            case 1009:\n                if (100 !== h.charCodeAt(4)) break;\n            case 969:\n            case 942:\n                return N + h + h;\n            case 978:\n                return N + h + S + h + h;\n            case 1019:\n            case 983:\n                return N + h + S + h + F + h + h;\n            case 883:\n                if (h.charCodeAt(8) === Q) return N + h + h;\n                if (h.indexOf(\"image-set(\", 11) > 0) return h.replace(z, \"$1\" + N + \"$2\") + h;\n                return h;\n            case 932:\n                if (h.charCodeAt(4) === Q) switch(h.charCodeAt(5)){\n                    case 103:\n                        return N + \"box-\" + h.replace(\"-grow\", \"\") + N + h + F + h.replace(\"grow\", \"positive\") + h;\n                    case 115:\n                        return N + h + F + h.replace(\"shrink\", \"negative\") + h;\n                    case 98:\n                        return N + h + F + h.replace(\"basis\", \"preferred-size\") + h;\n                }\n                return N + h + F + h + h;\n            case 964:\n                return N + h + F + \"flex-\" + h + h;\n            case 1023:\n                if (99 !== h.charCodeAt(8)) break;\n                return l = h.substring(h.indexOf(\":\", 15)).replace(\"flex-\", \"\").replace(\"space-between\", \"justify\"), N + \"box-pack\" + l + N + h + F + \"flex-pack\" + l + h;\n            case 1005:\n                return t.test(h) ? h.replace(s, \":\" + N) + h.replace(s, \":\" + S) + h : h;\n            case 1e3:\n                switch(o = (l = h.substring(13).trim()).indexOf(\"-\") + 1, l.charCodeAt(0) + l.charCodeAt(o)){\n                    case 226:\n                        l = h.replace(m, \"tb\");\n                        break;\n                    case 232:\n                        l = h.replace(m, \"tb-rl\");\n                        break;\n                    case 220:\n                        l = h.replace(m, \"lr\");\n                        break;\n                    default:\n                        return h;\n                }\n                return N + h + F + l + h;\n            case 1017:\n                if (-1 === h.indexOf(\"sticky\", 9)) return h;\n            case 975:\n                switch(o = (h = e).length - 10, u = (l = (33 === h.charCodeAt(o) ? h.substring(0, o) : h).substring(e.indexOf(\":\", 7) + 1).trim()).charCodeAt(0) + (0 | l.charCodeAt(7))){\n                    case 203:\n                        if (l.charCodeAt(8) < 111) break;\n                    case 115:\n                        h = h.replace(l, N + l) + \";\" + h;\n                        break;\n                    case 207:\n                    case 102:\n                        h = h.replace(l, N + (u > 102 ? \"inline-\" : \"\") + \"box\") + \";\" + h.replace(l, N + l) + \";\" + h.replace(l, F + l + \"box\") + \";\" + h;\n                }\n                return h + \";\";\n            case 938:\n                if (h.charCodeAt(5) === Q) switch(h.charCodeAt(6)){\n                    case 105:\n                        return l = h.replace(\"-items\", \"\"), N + h + N + \"box-\" + l + F + \"flex-\" + l + h;\n                    case 115:\n                        return N + h + F + \"flex-item-\" + h.replace(y, \"\") + h;\n                    default:\n                        return N + h + F + \"flex-line-pack\" + h.replace(\"align-content\", \"\").replace(y, \"\") + h;\n                }\n                break;\n            case 973:\n            case 989:\n                if (h.charCodeAt(3) !== Q || 122 === h.charCodeAt(4)) break;\n            case 931:\n            case 953:\n                if (true === j.test(e)) if (115 === (l = e.substring(e.indexOf(\":\") + 1)).charCodeAt(0)) return Ke(e.replace(\"stretch\", \"fill-available\"), a, r, c).replace(\":fill-available\", \":stretch\");\n                else return h.replace(l, N + l) + h.replace(l, S + l.replace(\"fill-\", \"\")) + h;\n                break;\n            case 962:\n                if (h = N + h + (102 === h.charCodeAt(5) ? F + h : \"\") + h, r + c === 211 && 105 === h.charCodeAt(13) && h.indexOf(\"transform\", 10) > 0) return h.substring(0, h.indexOf(\";\", 27) + 1).replace(i, \"$1\" + N + \"$2\") + h;\n        }\n        return h;\n    }\n    function Le(e, a) {\n        var r = e.indexOf(1 === a ? \":\" : \"{\"), c = e.substring(0, 3 !== a ? r : 10), s = e.substring(r + 1, e.length - 1);\n        return Oe(2 !== a ? c : c.replace(O, \"$1\"), s, a);\n    }\n    function Me(e, a) {\n        var r = Ke(a, a.charCodeAt(0), a.charCodeAt(1), a.charCodeAt(2));\n        return r !== a + \";\" ? r.replace($, \" or ($1)\").substring(4) : \"(\" + a + \")\";\n    }\n    function Pe(e, a, r, c, s, t, i, f, n, l) {\n        for(var o, h = 0, u = a; h < ye; ++h)switch(o = $e[h].call(Te, e, u, r, c, s, t, i, f, n, l)){\n            case void 0:\n            case false:\n            case true:\n            case null:\n                break;\n            default:\n                u = o;\n        }\n        if (u !== a) return u;\n    }\n    function Qe(e, a, r, c) {\n        for(var s = a + 1; s < r; ++s)switch(c.charCodeAt(s)){\n            case Z:\n                if (e === T) {\n                    if (c.charCodeAt(s - 1) === T && a + 2 !== s) return s + 1;\n                }\n                break;\n            case I:\n                if (e === Z) return s + 1;\n        }\n        return s;\n    }\n    function Re(e) {\n        for(var a in e){\n            var r = e[a];\n            switch(a){\n                case \"keyframe\":\n                    Be = 0 | r;\n                    break;\n                case \"global\":\n                    Ce = 0 | r;\n                    break;\n                case \"cascade\":\n                    ge = 0 | r;\n                    break;\n                case \"compress\":\n                    we = 0 | r;\n                    break;\n                case \"semicolon\":\n                    ve = 0 | r;\n                    break;\n                case \"preserve\":\n                    me = 0 | r;\n                    break;\n                case \"prefix\":\n                    if (Oe = null, !r) Ae = 0;\n                    else if (\"function\" != typeof r) Ae = 1;\n                    else Ae = 2, Oe = r;\n            }\n        }\n        return Re;\n    }\n    function Te(a, r) {\n        if (void 0 !== this && this.constructor === Te) return e(a);\n        var s = a, t = s.charCodeAt(0);\n        if (t < 33) t = (s = s.trim()).charCodeAt(0);\n        if (Be > 0) De = s.replace(d, t === G ? \"\" : \"-\");\n        if (t = 1, 1 === ge) Ge = s;\n        else Ee = s;\n        var i, f = [\n            Ge\n        ];\n        if (ye > 0) {\n            if (void 0 !== (i = Pe(ze, r, f, f, pe, be, 0, 0, 0, 0)) && \"string\" == typeof i) r = i;\n        }\n        var n = He(xe, f, r, 0, 0);\n        if (ye > 0) {\n            if (void 0 !== (i = Pe(je, n, f, f, pe, be, n.length, 0, 0, 0)) && \"string\" != typeof (n = i)) t = 0;\n        }\n        return De = \"\", Ge = \"\", Ee = \"\", ke = 0, pe = 1, be = 1, we * t == 0 ? n : n.replace(c, \"\").replace(g, \"\").replace(A, \"$1\").replace(C, \"$1\").replace(w, \" \");\n    }\n    if (Te.use = function e(a) {\n        switch(a){\n            case void 0:\n            case null:\n                ye = $e.length = 0;\n                break;\n            default:\n                if (\"function\" == typeof a) $e[ye++] = a;\n                else if (\"object\" == typeof a) for(var r = 0, c = a.length; r < c; ++r)e(a[r]);\n                else qe = 0 | !!a;\n        }\n        return e;\n    }, Te.set = Re, void 0 !== a) Re(a);\n    return Te;\n}); //# sourceMappingURL=stylis.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9zdHlsaXMvc3R5bGlzLm1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxDQUFDLFNBQVNBLENBQUM7SUFBRSxLQUFvREUsR0FBQ0EsT0FBT0QsT0FBTyxHQUFDRCxFQUFFLFFBQU0sQ0FBMkU7QUFBQSxFQUFFLFNBQVNBLEVBQUVPLENBQUM7SUFBRTtJQUFhLElBQUlDLElBQUUsU0FBUUMsSUFBRSxhQUFZQyxJQUFFLFFBQU9DLElBQUUsV0FBVUMsSUFBRSx1QkFBc0JDLElBQUUsc0JBQXFCQyxJQUFFLHNCQUFxQkMsSUFBRSxhQUFZQyxJQUFFLFVBQVNDLElBQUUscUJBQW9CQyxJQUFFLHVEQUFzREMsSUFBRSxRQUFPQyxJQUFFLHNCQUFxQkMsSUFBRSxjQUFhQyxJQUFFLGlCQUFnQkMsSUFBRSxxQkFBb0JDLElBQUUsaUJBQWdCQyxJQUFFLHNCQUFxQkMsSUFBRSxXQUFVQyxJQUFFLGtCQUFpQkMsSUFBRSxzQkFBcUJDLElBQUUsbUJBQWtCQyxJQUFFLGdCQUFlQyxJQUFFLGdCQUFlQyxJQUFFLCtCQUE4QkMsSUFBRSxvQ0FBbUNDLElBQUUsdUJBQXNCQyxJQUFFLFlBQVdDLElBQUUsU0FBUUMsSUFBRSxRQUFPQyxJQUFFLElBQUdDLElBQUUsS0FBSUMsSUFBRSxLQUFJQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLEdBQUVDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLEtBQUcsSUFBR0MsS0FBRyxLQUFJQyxLQUFHLEdBQUVDLEtBQUcsSUFBR0MsS0FBRyxJQUFHQyxLQUFHLEtBQUlDLEtB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QUUsRUFBRUQsRUFBRVIsRUFBRU8sQ0FBQyxDQUFDQyxFQUFFO3FCQUFPcUYsS0FBRyxJQUFFLENBQUMsQ0FBQ3RGO1FBQUM7UUFBQyxPQUFPUDtJQUFDLEdBQUVzRyxHQUFHMEIsR0FBRyxHQUFDM0IsSUFBRyxLQUFLLE1BQUk5RixHQUFFOEYsR0FBRzlGO0lBQUcsT0FBTytGO0FBQUUsSUFDMzFYLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2R1aGFja3NfMy8uL25vZGVfbW9kdWxlcy9iZXR0ZXItcmVhY3QtY2Fyb3VzZWwvbm9kZV9tb2R1bGVzL3N0eWxpcy9zdHlsaXMubWluLmpzPzUwNGUiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPWUobnVsbCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKG51bGwpKTp3aW5kb3cuc3R5bGlzPWUobnVsbCl9KGZ1bmN0aW9uIGUoYSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHI9L15cXDArL2csYz0vW1xcMFxcclxcZl0vZyxzPS86ICovZyx0PS96b298Z3JhLyxpPS8oWyw6IF0pKHRyYW5zZm9ybSkvZyxmPS8sK1xccyooPyFbXihdKlspXSkvZyxuPS8gK1xccyooPyFbXihdKlspXSkvZyxsPS8gKltcXDBdICovZyxvPS8sXFxyKz8vZyxoPS8oW1xcdFxcclxcbiBdKSpcXGY/Ji9nLHU9LzpnbG9iYWxcXCgoKD86W15cXChcXClcXFtcXF1dKnxcXFsuKlxcXXxcXChbXlxcKFxcKV0qXFwpKSopXFwpL2csZD0vXFxXKy9nLGI9L0Aoa1xcdyspXFxzKihcXFMqKVxccyovLHA9Lzo6KHBsYWNlKS9nLGs9LzoocmVhZC1vbmx5KS9nLGc9L1xccysoPz1be1xcXTs9Oj5dKS9nLEE9LyhbW309Oj5dKVxccysvZyxDPS8oXFx7W157XSs/KTsoPz1cXH0pL2csdz0vXFxzezIsfS9nLHY9LyhbXlxcKF0pKDorKSAqL2csbT0vW3N2aF1cXHcrLVt0YmxyXXsyfS8seD0vXFwoXFxzKiguKilcXHMqXFwpL2csJD0vKFtcXHNcXFNdKj8pOy9nLHk9Ly1zZWxmfGZsZXgtL2csTz0vW15dKj8oOltycF1bZWxdYVtcXHctXSspW15dKi8saj0vc3RyZXRjaHw6XFxzKlxcdytcXC0oPzpjb250ZXxhdmFpbCkvLHo9LyhbXi1dKShpbWFnZS1zZXRcXCgpLyxOPVwiLXdlYmtpdC1cIixTPVwiLW1vei1cIixGPVwiLW1zLVwiLFc9NTkscT0xMjUsQj0xMjMsRD00MCxFPTQxLEc9OTEsSD05MyxJPTEwLEo9MTMsSz05LEw9NjQsTT0zMixQPTM4LFE9NDUsUj05NSxUPTQyLFU9NDQsVj01OCxYPTM5LFk9MzQsWj00NyxfPTYyLGVlPTQzLGFlPTEyNixyZT0wLGNlPTEyLHNlPTExLHRlPTEwNyxpZT0xMDksZmU9MTE1LG5lPTExMixsZT0xMTEsb2U9MTA1LGhlPTk5LHVlPTEwMCxkZT0xMTIsYmU9MSxwZT0xLGtlPTAsZ2U9MSxBZT0xLENlPTEsd2U9MCx2ZT0wLG1lPTAseGU9W10sJGU9W10seWU9MCxPZT1udWxsLGplPS0yLHplPS0xLE5lPTAsU2U9MSxGZT0yLFdlPTMscWU9MCxCZT0xLERlPVwiXCIsRWU9XCJcIixHZT1cIlwiO2Z1bmN0aW9uIEhlKGUsYSxzLHQsaSl7Zm9yKHZhciBmLG4sbz0wLGg9MCx1PTAsZD0wLGc9MCxBPTAsQz0wLHc9MCxtPTAsJD0wLHk9MCxPPTAsaj0wLHo9MCxSPTAsd2U9MCwkZT0wLE9lPTAsamU9MCx6ZT1zLmxlbmd0aCxKZT16ZS0xLFJlPVwiXCIsVGU9XCJcIixVZT1cIlwiLFZlPVwiXCIsWGU9XCJcIixZZT1cIlwiO1I8emU7KXtpZihDPXMuY2hhckNvZGVBdChSKSxSPT09SmUpaWYoaCtkK3UrbyE9PTApe2lmKDAhPT1oKUM9aD09PVo/STpaO2Q9dT1vPTAsemUrKyxKZSsrfWlmKGgrZCt1K289PT0wKXtpZihSPT09SmUpe2lmKHdlPjApVGU9VGUucmVwbGFjZShjLFwiXCIpO2lmKFRlLnRyaW0oKS5sZW5ndGg+MCl7c3dpdGNoKEMpe2Nhc2UgTTpjYXNlIEs6Y2FzZSBXOmNhc2UgSjpjYXNlIEk6YnJlYWs7ZGVmYXVsdDpUZSs9cy5jaGFyQXQoUil9Qz1XfX1pZigxPT09JGUpc3dpdGNoKEMpe2Nhc2UgQjpjYXNlIHE6Y2FzZSBXOmNhc2UgWTpjYXNlIFg6Y2FzZSBEOmNhc2UgRTpjYXNlIFU6JGU9MDtjYXNlIEs6Y2FzZSBKOmNhc2UgSTpjYXNlIE06YnJlYWs7ZGVmYXVsdDpmb3IoJGU9MCxqZT1SLGc9QyxSLS0sQz1XO2plPHplOylzd2l0Y2gocy5jaGFyQ29kZUF0KGplKyspKXtjYXNlIEk6Y2FzZSBKOmNhc2UgVzorK1IsQz1nLGplPXplO2JyZWFrO2Nhc2UgVjppZih3ZT4wKSsrUixDPWc7Y2FzZSBCOmplPXplfX1zd2l0Y2goQyl7Y2FzZSBCOmZvcihnPShUZT1UZS50cmltKCkpLmNoYXJDb2RlQXQoMCkseT0xLGplPSsrUjtSPHplOyl7c3dpdGNoKEM9cy5jaGFyQ29kZUF0KFIpKXtjYXNlIEI6eSsrO2JyZWFrO2Nhc2UgcTp5LS07YnJlYWs7Y2FzZSBaOnN3aXRjaChBPXMuY2hhckNvZGVBdChSKzEpKXtjYXNlIFQ6Y2FzZSBaOlI9UWUoQSxSLEplLHMpfWJyZWFrO2Nhc2UgRzpDKys7Y2FzZSBEOkMrKztjYXNlIFk6Y2FzZSBYOmZvcig7UisrPEplJiZzLmNoYXJDb2RlQXQoUikhPT1DOyk7fWlmKDA9PT15KWJyZWFrO1IrK31pZihVZT1zLnN1YnN0cmluZyhqZSxSKSxnPT09cmUpZz0oVGU9VGUucmVwbGFjZShyLFwiXCIpLnRyaW0oKSkuY2hhckNvZGVBdCgwKTtzd2l0Y2goZyl7Y2FzZSBMOmlmKHdlPjApVGU9VGUucmVwbGFjZShjLFwiXCIpO3N3aXRjaChBPVRlLmNoYXJDb2RlQXQoMSkpe2Nhc2UgdWU6Y2FzZSBpZTpjYXNlIGZlOmNhc2UgUTpmPWE7YnJlYWs7ZGVmYXVsdDpmPXhlfWlmKGplPShVZT1IZShhLGYsVWUsQSxpKzEpKS5sZW5ndGgsbWU+MCYmMD09PWplKWplPVRlLmxlbmd0aDtpZih5ZT4wKWlmKGY9SWUoeGUsVGUsT2UpLG49UGUoV2UsVWUsZixhLHBlLGJlLGplLEEsaSx0KSxUZT1mLmpvaW4oXCJcIiksdm9pZCAwIT09bilpZigwPT09KGplPShVZT1uLnRyaW0oKSkubGVuZ3RoKSlBPTAsVWU9XCJcIjtpZihqZT4wKXN3aXRjaChBKXtjYXNlIGZlOlRlPVRlLnJlcGxhY2UoeCxNZSk7Y2FzZSB1ZTpjYXNlIGllOmNhc2UgUTpVZT1UZStcIntcIitVZStcIn1cIjticmVhaztjYXNlIHRlOmlmKFVlPShUZT1UZS5yZXBsYWNlKGIsXCIkMSAkMlwiKyhCZT4wP0RlOlwiXCIpKSkrXCJ7XCIrVWUrXCJ9XCIsMT09PUFlfHwyPT09QWUmJkxlKFwiQFwiK1VlLDMpKVVlPVwiQFwiK04rVWUrXCJAXCIrVWU7ZWxzZSBVZT1cIkBcIitVZTticmVhaztkZWZhdWx0OmlmKFVlPVRlK1VlLHQ9PT1kZSlWZSs9VWUsVWU9XCJcIn1lbHNlIFVlPVwiXCI7YnJlYWs7ZGVmYXVsdDpVZT1IZShhLEllKGEsVGUsT2UpLFVlLHQsaSsxKX1YZSs9VWUsTz0wLCRlPTAsej0wLHdlPTAsT2U9MCxqPTAsVGU9XCJcIixVZT1cIlwiLEM9cy5jaGFyQ29kZUF0KCsrUik7YnJlYWs7Y2FzZSBxOmNhc2UgVzppZigoamU9KFRlPSh3ZT4wP1RlLnJlcGxhY2UoYyxcIlwiKTpUZSkudHJpbSgpKS5sZW5ndGgpPjEpe2lmKDA9PT16KWlmKChnPVRlLmNoYXJDb2RlQXQoMCkpPT09UXx8Zz45NiYmZzwxMjMpamU9KFRlPVRlLnJlcGxhY2UoXCIgXCIsXCI6XCIpKS5sZW5ndGg7aWYoeWU+MClpZih2b2lkIDAhPT0obj1QZShTZSxUZSxhLGUscGUsYmUsVmUubGVuZ3RoLHQsaSx0KSkpaWYoMD09PShqZT0oVGU9bi50cmltKCkpLmxlbmd0aCkpVGU9XCJcXDBcXDBcIjtzd2l0Y2goZz1UZS5jaGFyQ29kZUF0KDApLEE9VGUuY2hhckNvZGVBdCgxKSxnKXtjYXNlIHJlOmJyZWFrO2Nhc2UgTDppZihBPT09b2V8fEE9PT1oZSl7WWUrPVRlK3MuY2hhckF0KFIpO2JyZWFrfWRlZmF1bHQ6aWYoVGUuY2hhckNvZGVBdChqZS0xKT09PVYpYnJlYWs7VmUrPUtlKFRlLGcsQSxUZS5jaGFyQ29kZUF0KDIpKX19Tz0wLCRlPTAsej0wLHdlPTAsT2U9MCxUZT1cIlwiLEM9cy5jaGFyQ29kZUF0KCsrUil9fXN3aXRjaChDKXtjYXNlIEo6Y2FzZSBJOmlmKGgrZCt1K28rdmU9PT0wKXN3aXRjaCgkKXtjYXNlIEU6Y2FzZSBYOmNhc2UgWTpjYXNlIEw6Y2FzZSBhZTpjYXNlIF86Y2FzZSBUOmNhc2UgZWU6Y2FzZSBaOmNhc2UgUTpjYXNlIFY6Y2FzZSBVOmNhc2UgVzpjYXNlIEI6Y2FzZSBxOmJyZWFrO2RlZmF1bHQ6aWYoej4wKSRlPTF9aWYoaD09PVopaD0wO2Vsc2UgaWYoZ2UrTz09PTAmJnQhPT10ZSYmVGUubGVuZ3RoPjApd2U9MSxUZSs9XCJcXDBcIjtpZih5ZSpxZT4wKVBlKE5lLFRlLGEsZSxwZSxiZSxWZS5sZW5ndGgsdCxpLHQpO2JlPTEscGUrKzticmVhaztjYXNlIFc6Y2FzZSBxOmlmKGgrZCt1K289PT0wKXtiZSsrO2JyZWFrfWRlZmF1bHQ6c3dpdGNoKGJlKyssUmU9cy5jaGFyQXQoUiksQyl7Y2FzZSBLOmNhc2UgTTppZihkK28raD09PTApc3dpdGNoKHcpe2Nhc2UgVTpjYXNlIFY6Y2FzZSBLOmNhc2UgTTpSZT1cIlwiO2JyZWFrO2RlZmF1bHQ6aWYoQyE9PU0pUmU9XCIgXCJ9YnJlYWs7Y2FzZSByZTpSZT1cIlxcXFwwXCI7YnJlYWs7Y2FzZSBjZTpSZT1cIlxcXFxmXCI7YnJlYWs7Y2FzZSBzZTpSZT1cIlxcXFx2XCI7YnJlYWs7Y2FzZSBQOmlmKGQraCtvPT09MCYmZ2U+MClPZT0xLHdlPTEsUmU9XCJcXGZcIitSZTticmVhaztjYXNlIDEwODppZihkK2grbytrZT09PTAmJno+MClzd2l0Y2goUi16KXtjYXNlIDI6aWYodz09PW5lJiZzLmNoYXJDb2RlQXQoUi0zKT09PVYpa2U9dztjYXNlIDg6aWYobT09PWxlKWtlPW19YnJlYWs7Y2FzZSBWOmlmKGQraCtvPT09MCl6PVI7YnJlYWs7Y2FzZSBVOmlmKGgrdStkK289PT0wKXdlPTEsUmUrPVwiXFxyXCI7YnJlYWs7Y2FzZSBZOmNhc2UgWDppZigwPT09aClkPWQ9PT1DPzA6MD09PWQ/QzpkO2JyZWFrO2Nhc2UgRzppZihkK2grdT09PTApbysrO2JyZWFrO2Nhc2UgSDppZihkK2grdT09PTApby0tO2JyZWFrO2Nhc2UgRTppZihkK2grbz09PTApdS0tO2JyZWFrO2Nhc2UgRDppZihkK2grbz09PTApe2lmKDA9PT1PKXN3aXRjaCgyKncrMyptKXtjYXNlIDUzMzpicmVhaztkZWZhdWx0Onk9MCxPPTF9dSsrfWJyZWFrO2Nhc2UgTDppZihoK3UrZCtvK3oraj09PTApaj0xO2JyZWFrO2Nhc2UgVDpjYXNlIFo6aWYoZCtvK3U+MClicmVhaztzd2l0Y2goaCl7Y2FzZSAwOnN3aXRjaCgyKkMrMypzLmNoYXJDb2RlQXQoUisxKSl7Y2FzZSAyMzU6aD1aO2JyZWFrO2Nhc2UgMjIwOmplPVIsaD1UfWJyZWFrO2Nhc2UgVDppZihDPT09WiYmdz09PVQmJmplKzIhPT1SKXtpZigzMz09PXMuY2hhckNvZGVBdChqZSsyKSlWZSs9cy5zdWJzdHJpbmcoamUsUisxKTtSZT1cIlwiLGg9MH19fWlmKDA9PT1oKXtpZihnZStkK28raj09PTAmJnQhPT10ZSYmQyE9PVcpc3dpdGNoKEMpe2Nhc2UgVTpjYXNlIGFlOmNhc2UgXzpjYXNlIGVlOmNhc2UgRTpjYXNlIEQ6aWYoMD09PU8pe3N3aXRjaCh3KXtjYXNlIEs6Y2FzZSBNOmNhc2UgSTpjYXNlIEo6UmUrPVwiXFwwXCI7YnJlYWs7ZGVmYXVsdDpSZT1cIlxcMFwiK1JlKyhDPT09VT9cIlwiOlwiXFwwXCIpfXdlPTF9ZWxzZSBzd2l0Y2goQyl7Y2FzZSBEOmlmKHorNz09PVImJjEwOD09PXcpej0wO089Kyt5O2JyZWFrO2Nhc2UgRTppZigwPT0oTz0tLXkpKXdlPTEsUmUrPVwiXFwwXCJ9YnJlYWs7Y2FzZSBLOmNhc2UgTTpzd2l0Y2godyl7Y2FzZSByZTpjYXNlIEI6Y2FzZSBxOmNhc2UgVzpjYXNlIFU6Y2FzZSBjZTpjYXNlIEs6Y2FzZSBNOmNhc2UgSTpjYXNlIEo6YnJlYWs7ZGVmYXVsdDppZigwPT09Tyl3ZT0xLFJlKz1cIlxcMFwifX1pZihUZSs9UmUsQyE9PU0mJkMhPT1LKSQ9Q319bT13LHc9QyxSKyt9aWYoamU9VmUubGVuZ3RoLG1lPjApaWYoMD09PWplJiYwPT09WGUubGVuZ3RoJiYwPT09YVswXS5sZW5ndGg9PWZhbHNlKWlmKHQhPT1pZXx8MT09PWEubGVuZ3RoJiYoZ2U+MD9FZTpHZSk9PT1hWzBdKWplPWEuam9pbihcIixcIikubGVuZ3RoKzI7aWYoamU+MCl7aWYoZj0wPT09Z2UmJnQhPT10ZT9mdW5jdGlvbihlKXtmb3IodmFyIGEscixzPTAsdD1lLmxlbmd0aCxpPUFycmF5KHQpO3M8dDsrK3Mpe2Zvcih2YXIgZj1lW3NdLnNwbGl0KGwpLG49XCJcIixvPTAsaD0wLHU9MCxkPTAsYj1mLmxlbmd0aDtvPGI7KytvKXtpZigwPT09KGg9KHI9ZltvXSkubGVuZ3RoKSYmYj4xKWNvbnRpbnVlO2lmKHU9bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTEpLGQ9ci5jaGFyQ29kZUF0KDApLGE9XCJcIiwwIT09bylzd2l0Y2godSl7Y2FzZSBUOmNhc2UgYWU6Y2FzZSBfOmNhc2UgZWU6Y2FzZSBNOmNhc2UgRDpicmVhaztkZWZhdWx0OmE9XCIgXCJ9c3dpdGNoKGQpe2Nhc2UgUDpyPWErRWU7Y2FzZSBhZTpjYXNlIF86Y2FzZSBlZTpjYXNlIE06Y2FzZSBFOmNhc2UgRDpicmVhaztjYXNlIEc6cj1hK3IrRWU7YnJlYWs7Y2FzZSBWOnN3aXRjaCgyKnIuY2hhckNvZGVBdCgxKSszKnIuY2hhckNvZGVBdCgyKSl7Y2FzZSA1MzA6aWYoQ2U+MCl7cj1hK3Iuc3Vic3RyaW5nKDgsaC0xKTticmVha31kZWZhdWx0OmlmKG88MXx8ZltvLTFdLmxlbmd0aDwxKXI9YStFZStyfWJyZWFrO2Nhc2UgVTphPVwiXCI7ZGVmYXVsdDppZihoPjEmJnIuaW5kZXhPZihcIjpcIik+MClyPWErci5yZXBsYWNlKHYsXCIkMVwiK0VlK1wiJDJcIik7ZWxzZSByPWErcitFZX1uKz1yfWlbc109bi5yZXBsYWNlKGMsXCJcIikudHJpbSgpfXJldHVybiBpfShhKTphLHllPjApaWYodm9pZCAwIT09KG49UGUoRmUsVmUsZixlLHBlLGJlLGplLHQsaSx0KSkmJjA9PT0oVmU9bikubGVuZ3RoKXJldHVybiBZZStWZStYZTtpZihWZT1mLmpvaW4oXCIsXCIpK1wie1wiK1ZlK1wifVwiLEFlKmtlIT0wKXtpZigyPT09QWUmJiFMZShWZSwyKSlrZT0wO3N3aXRjaChrZSl7Y2FzZSBsZTpWZT1WZS5yZXBsYWNlKGssXCI6XCIrUytcIiQxXCIpK1ZlO2JyZWFrO2Nhc2UgbmU6VmU9VmUucmVwbGFjZShwLFwiOjpcIitOK1wiaW5wdXQtJDFcIikrVmUucmVwbGFjZShwLFwiOjpcIitTK1wiJDFcIikrVmUucmVwbGFjZShwLFwiOlwiK0YrXCJpbnB1dC0kMVwiKStWZX1rZT0wfX1yZXR1cm4gWWUrVmUrWGV9ZnVuY3Rpb24gSWUoZSxhLHIpe3ZhciBjPWEudHJpbSgpLnNwbGl0KG8pLHM9Yyx0PWMubGVuZ3RoLGk9ZS5sZW5ndGg7c3dpdGNoKGkpe2Nhc2UgMDpjYXNlIDE6Zm9yKHZhciBmPTAsbj0wPT09aT9cIlwiOmVbMF0rXCIgXCI7Zjx0OysrZilzW2ZdPUplKG4sc1tmXSxyLGkpLnRyaW0oKTticmVhaztkZWZhdWx0OmY9MDt2YXIgbD0wO2ZvcihzPVtdO2Y8dDsrK2YpZm9yKHZhciBoPTA7aDxpOysraClzW2wrK109SmUoZVtoXStcIiBcIixjW2ZdLHIsaSkudHJpbSgpfXJldHVybiBzfWZ1bmN0aW9uIEplKGUsYSxyLGMpe3ZhciBzPWEsdD1zLmNoYXJDb2RlQXQoMCk7aWYodDwzMyl0PShzPXMudHJpbSgpKS5jaGFyQ29kZUF0KDApO3N3aXRjaCh0KXtjYXNlIFA6c3dpdGNoKGdlK2Mpe2Nhc2UgMDpjYXNlIDE6aWYoMD09PWUudHJpbSgpLmxlbmd0aClicmVhaztkZWZhdWx0OnJldHVybiBzLnJlcGxhY2UoaCxcIiQxXCIrZS50cmltKCkpfWJyZWFrO2Nhc2UgVjpzd2l0Y2gocy5jaGFyQ29kZUF0KDEpKXtjYXNlIDEwMzppZihDZT4wJiZnZT4wKXJldHVybiBzLnJlcGxhY2UodSxcIiQxXCIpLnJlcGxhY2UoaCxcIiQxXCIrR2UpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIGUudHJpbSgpK3MucmVwbGFjZShoLFwiJDFcIitlLnRyaW0oKSl9ZGVmYXVsdDppZihyKmdlPjAmJnMuaW5kZXhPZihcIlxcZlwiKT4wKXJldHVybiBzLnJlcGxhY2UoaCwoZS5jaGFyQ29kZUF0KDApPT09Vj9cIlwiOlwiJDFcIikrZS50cmltKCkpfXJldHVybiBlK3N9ZnVuY3Rpb24gS2UoZSxhLHIsYyl7dmFyIGwsbz0wLGg9ZStcIjtcIix1PTIqYSszKnIrNCpjO2lmKDk0ND09PXUpcmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciBhPWUubGVuZ3RoLHI9ZS5pbmRleE9mKFwiOlwiLDkpKzEsYz1lLnN1YnN0cmluZygwLHIpLnRyaW0oKSxzPWUuc3Vic3RyaW5nKHIsYS0xKS50cmltKCk7c3dpdGNoKGUuY2hhckNvZGVBdCg5KSpCZSl7Y2FzZSAwOmJyZWFrO2Nhc2UgUTppZigxMTAhPT1lLmNoYXJDb2RlQXQoMTApKWJyZWFrO2RlZmF1bHQ6Zm9yKHZhciB0PXMuc3BsaXQoKHM9XCJcIixmKSksaT0wLHI9MCxhPXQubGVuZ3RoO2k8YTtyPTAsKytpKXtmb3IodmFyIGw9dFtpXSxvPWwuc3BsaXQobik7bD1vW3JdOyl7dmFyIGg9bC5jaGFyQ29kZUF0KDApO2lmKDE9PT1CZSYmKGg+TCYmaDw5MHx8aD45NiYmaDwxMjN8fGg9PT1SfHxoPT09USYmbC5jaGFyQ29kZUF0KDEpIT09USkpc3dpdGNoKGlzTmFOKHBhcnNlRmxvYXQobCkpKygtMSE9PWwuaW5kZXhPZihcIihcIikpKXtjYXNlIDE6c3dpdGNoKGwpe2Nhc2VcImluZmluaXRlXCI6Y2FzZVwiYWx0ZXJuYXRlXCI6Y2FzZVwiYmFja3dhcmRzXCI6Y2FzZVwicnVubmluZ1wiOmNhc2VcIm5vcm1hbFwiOmNhc2VcImZvcndhcmRzXCI6Y2FzZVwiYm90aFwiOmNhc2VcIm5vbmVcIjpjYXNlXCJsaW5lYXJcIjpjYXNlXCJlYXNlXCI6Y2FzZVwiZWFzZS1pblwiOmNhc2VcImVhc2Utb3V0XCI6Y2FzZVwiZWFzZS1pbi1vdXRcIjpjYXNlXCJwYXVzZWRcIjpjYXNlXCJyZXZlcnNlXCI6Y2FzZVwiYWx0ZXJuYXRlLXJldmVyc2VcIjpjYXNlXCJpbmhlcml0XCI6Y2FzZVwiaW5pdGlhbFwiOmNhc2VcInVuc2V0XCI6Y2FzZVwic3RlcC1zdGFydFwiOmNhc2VcInN0ZXAtZW5kXCI6YnJlYWs7ZGVmYXVsdDpsKz1EZX19b1tyKytdPWx9cys9KDA9PT1pP1wiXCI6XCIsXCIpK28uam9pbihcIiBcIil9fWlmKHM9YytzK1wiO1wiLDE9PT1BZXx8Mj09PUFlJiZMZShzLDEpKXJldHVybiBOK3MrcztyZXR1cm4gc30oaCk7ZWxzZSBpZigwPT09QWV8fDI9PT1BZSYmIUxlKGgsMSkpcmV0dXJuIGg7c3dpdGNoKHUpe2Nhc2UgMTAxNTpyZXR1cm4gOTc9PT1oLmNoYXJDb2RlQXQoMTApP04raCtoOmg7Y2FzZSA5NTE6cmV0dXJuIDExNj09PWguY2hhckNvZGVBdCgzKT9OK2graDpoO2Nhc2UgOTYzOnJldHVybiAxMTA9PT1oLmNoYXJDb2RlQXQoNSk/TitoK2g6aDtjYXNlIDEwMDk6aWYoMTAwIT09aC5jaGFyQ29kZUF0KDQpKWJyZWFrO2Nhc2UgOTY5OmNhc2UgOTQyOnJldHVybiBOK2graDtjYXNlIDk3ODpyZXR1cm4gTitoK1MraCtoO2Nhc2UgMTAxOTpjYXNlIDk4MzpyZXR1cm4gTitoK1MraCtGK2graDtjYXNlIDg4MzppZihoLmNoYXJDb2RlQXQoOCk9PT1RKXJldHVybiBOK2graDtpZihoLmluZGV4T2YoXCJpbWFnZS1zZXQoXCIsMTEpPjApcmV0dXJuIGgucmVwbGFjZSh6LFwiJDFcIitOK1wiJDJcIikraDtyZXR1cm4gaDtjYXNlIDkzMjppZihoLmNoYXJDb2RlQXQoNCk9PT1RKXN3aXRjaChoLmNoYXJDb2RlQXQoNSkpe2Nhc2UgMTAzOnJldHVybiBOK1wiYm94LVwiK2gucmVwbGFjZShcIi1ncm93XCIsXCJcIikrTitoK0YraC5yZXBsYWNlKFwiZ3Jvd1wiLFwicG9zaXRpdmVcIikraDtjYXNlIDExNTpyZXR1cm4gTitoK0YraC5yZXBsYWNlKFwic2hyaW5rXCIsXCJuZWdhdGl2ZVwiKStoO2Nhc2UgOTg6cmV0dXJuIE4raCtGK2gucmVwbGFjZShcImJhc2lzXCIsXCJwcmVmZXJyZWQtc2l6ZVwiKStofXJldHVybiBOK2grRitoK2g7Y2FzZSA5NjQ6cmV0dXJuIE4raCtGK1wiZmxleC1cIitoK2g7Y2FzZSAxMDIzOmlmKDk5IT09aC5jaGFyQ29kZUF0KDgpKWJyZWFrO3JldHVybiBsPWguc3Vic3RyaW5nKGguaW5kZXhPZihcIjpcIiwxNSkpLnJlcGxhY2UoXCJmbGV4LVwiLFwiXCIpLnJlcGxhY2UoXCJzcGFjZS1iZXR3ZWVuXCIsXCJqdXN0aWZ5XCIpLE4rXCJib3gtcGFja1wiK2wrTitoK0YrXCJmbGV4LXBhY2tcIitsK2g7Y2FzZSAxMDA1OnJldHVybiB0LnRlc3QoaCk/aC5yZXBsYWNlKHMsXCI6XCIrTikraC5yZXBsYWNlKHMsXCI6XCIrUykraDpoO2Nhc2UgMWUzOnN3aXRjaChvPShsPWguc3Vic3RyaW5nKDEzKS50cmltKCkpLmluZGV4T2YoXCItXCIpKzEsbC5jaGFyQ29kZUF0KDApK2wuY2hhckNvZGVBdChvKSl7Y2FzZSAyMjY6bD1oLnJlcGxhY2UobSxcInRiXCIpO2JyZWFrO2Nhc2UgMjMyOmw9aC5yZXBsYWNlKG0sXCJ0Yi1ybFwiKTticmVhaztjYXNlIDIyMDpsPWgucmVwbGFjZShtLFwibHJcIik7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gaH1yZXR1cm4gTitoK0YrbCtoO2Nhc2UgMTAxNzppZigtMT09PWguaW5kZXhPZihcInN0aWNreVwiLDkpKXJldHVybiBoO2Nhc2UgOTc1OnN3aXRjaChvPShoPWUpLmxlbmd0aC0xMCx1PShsPSgzMz09PWguY2hhckNvZGVBdChvKT9oLnN1YnN0cmluZygwLG8pOmgpLnN1YnN0cmluZyhlLmluZGV4T2YoXCI6XCIsNykrMSkudHJpbSgpKS5jaGFyQ29kZUF0KDApKygwfGwuY2hhckNvZGVBdCg3KSkpe2Nhc2UgMjAzOmlmKGwuY2hhckNvZGVBdCg4KTwxMTEpYnJlYWs7Y2FzZSAxMTU6aD1oLnJlcGxhY2UobCxOK2wpK1wiO1wiK2g7YnJlYWs7Y2FzZSAyMDc6Y2FzZSAxMDI6aD1oLnJlcGxhY2UobCxOKyh1PjEwMj9cImlubGluZS1cIjpcIlwiKStcImJveFwiKStcIjtcIitoLnJlcGxhY2UobCxOK2wpK1wiO1wiK2gucmVwbGFjZShsLEYrbCtcImJveFwiKStcIjtcIitofXJldHVybiBoK1wiO1wiO2Nhc2UgOTM4OmlmKGguY2hhckNvZGVBdCg1KT09PVEpc3dpdGNoKGguY2hhckNvZGVBdCg2KSl7Y2FzZSAxMDU6cmV0dXJuIGw9aC5yZXBsYWNlKFwiLWl0ZW1zXCIsXCJcIiksTitoK04rXCJib3gtXCIrbCtGK1wiZmxleC1cIitsK2g7Y2FzZSAxMTU6cmV0dXJuIE4raCtGK1wiZmxleC1pdGVtLVwiK2gucmVwbGFjZSh5LFwiXCIpK2g7ZGVmYXVsdDpyZXR1cm4gTitoK0YrXCJmbGV4LWxpbmUtcGFja1wiK2gucmVwbGFjZShcImFsaWduLWNvbnRlbnRcIixcIlwiKS5yZXBsYWNlKHksXCJcIikraH1icmVhaztjYXNlIDk3MzpjYXNlIDk4OTppZihoLmNoYXJDb2RlQXQoMykhPT1RfHwxMjI9PT1oLmNoYXJDb2RlQXQoNCkpYnJlYWs7Y2FzZSA5MzE6Y2FzZSA5NTM6aWYodHJ1ZT09PWoudGVzdChlKSlpZigxMTU9PT0obD1lLnN1YnN0cmluZyhlLmluZGV4T2YoXCI6XCIpKzEpKS5jaGFyQ29kZUF0KDApKXJldHVybiBLZShlLnJlcGxhY2UoXCJzdHJldGNoXCIsXCJmaWxsLWF2YWlsYWJsZVwiKSxhLHIsYykucmVwbGFjZShcIjpmaWxsLWF2YWlsYWJsZVwiLFwiOnN0cmV0Y2hcIik7ZWxzZSByZXR1cm4gaC5yZXBsYWNlKGwsTitsKStoLnJlcGxhY2UobCxTK2wucmVwbGFjZShcImZpbGwtXCIsXCJcIikpK2g7YnJlYWs7Y2FzZSA5NjI6aWYoaD1OK2grKDEwMj09PWguY2hhckNvZGVBdCg1KT9GK2g6XCJcIikraCxyK2M9PT0yMTEmJjEwNT09PWguY2hhckNvZGVBdCgxMykmJmguaW5kZXhPZihcInRyYW5zZm9ybVwiLDEwKT4wKXJldHVybiBoLnN1YnN0cmluZygwLGguaW5kZXhPZihcIjtcIiwyNykrMSkucmVwbGFjZShpLFwiJDFcIitOK1wiJDJcIikraH1yZXR1cm4gaH1mdW5jdGlvbiBMZShlLGEpe3ZhciByPWUuaW5kZXhPZigxPT09YT9cIjpcIjpcIntcIiksYz1lLnN1YnN0cmluZygwLDMhPT1hP3I6MTApLHM9ZS5zdWJzdHJpbmcocisxLGUubGVuZ3RoLTEpO3JldHVybiBPZSgyIT09YT9jOmMucmVwbGFjZShPLFwiJDFcIikscyxhKX1mdW5jdGlvbiBNZShlLGEpe3ZhciByPUtlKGEsYS5jaGFyQ29kZUF0KDApLGEuY2hhckNvZGVBdCgxKSxhLmNoYXJDb2RlQXQoMikpO3JldHVybiByIT09YStcIjtcIj9yLnJlcGxhY2UoJCxcIiBvciAoJDEpXCIpLnN1YnN0cmluZyg0KTpcIihcIithK1wiKVwifWZ1bmN0aW9uIFBlKGUsYSxyLGMscyx0LGksZixuLGwpe2Zvcih2YXIgbyxoPTAsdT1hO2g8eWU7KytoKXN3aXRjaChvPSRlW2hdLmNhbGwoVGUsZSx1LHIsYyxzLHQsaSxmLG4sbCkpe2Nhc2Ugdm9pZCAwOmNhc2UgZmFsc2U6Y2FzZSB0cnVlOmNhc2UgbnVsbDpicmVhaztkZWZhdWx0OnU9b31pZih1IT09YSlyZXR1cm4gdX1mdW5jdGlvbiBRZShlLGEscixjKXtmb3IodmFyIHM9YSsxO3M8cjsrK3Mpc3dpdGNoKGMuY2hhckNvZGVBdChzKSl7Y2FzZSBaOmlmKGU9PT1UKWlmKGMuY2hhckNvZGVBdChzLTEpPT09VCYmYSsyIT09cylyZXR1cm4gcysxO2JyZWFrO2Nhc2UgSTppZihlPT09WilyZXR1cm4gcysxfXJldHVybiBzfWZ1bmN0aW9uIFJlKGUpe2Zvcih2YXIgYSBpbiBlKXt2YXIgcj1lW2FdO3N3aXRjaChhKXtjYXNlXCJrZXlmcmFtZVwiOkJlPTB8cjticmVhaztjYXNlXCJnbG9iYWxcIjpDZT0wfHI7YnJlYWs7Y2FzZVwiY2FzY2FkZVwiOmdlPTB8cjticmVhaztjYXNlXCJjb21wcmVzc1wiOndlPTB8cjticmVhaztjYXNlXCJzZW1pY29sb25cIjp2ZT0wfHI7YnJlYWs7Y2FzZVwicHJlc2VydmVcIjptZT0wfHI7YnJlYWs7Y2FzZVwicHJlZml4XCI6aWYoT2U9bnVsbCwhcilBZT0wO2Vsc2UgaWYoXCJmdW5jdGlvblwiIT10eXBlb2YgcilBZT0xO2Vsc2UgQWU9MixPZT1yfX1yZXR1cm4gUmV9ZnVuY3Rpb24gVGUoYSxyKXtpZih2b2lkIDAhPT10aGlzJiZ0aGlzLmNvbnN0cnVjdG9yPT09VGUpcmV0dXJuIGUoYSk7dmFyIHM9YSx0PXMuY2hhckNvZGVBdCgwKTtpZih0PDMzKXQ9KHM9cy50cmltKCkpLmNoYXJDb2RlQXQoMCk7aWYoQmU+MClEZT1zLnJlcGxhY2UoZCx0PT09Rz9cIlwiOlwiLVwiKTtpZih0PTEsMT09PWdlKUdlPXM7ZWxzZSBFZT1zO3ZhciBpLGY9W0dlXTtpZih5ZT4wKWlmKHZvaWQgMCE9PShpPVBlKHplLHIsZixmLHBlLGJlLDAsMCwwLDApKSYmXCJzdHJpbmdcIj09dHlwZW9mIGkpcj1pO3ZhciBuPUhlKHhlLGYsciwwLDApO2lmKHllPjApaWYodm9pZCAwIT09KGk9UGUoamUsbixmLGYscGUsYmUsbi5sZW5ndGgsMCwwLDApKSYmXCJzdHJpbmdcIiE9dHlwZW9mKG49aSkpdD0wO3JldHVybiBEZT1cIlwiLEdlPVwiXCIsRWU9XCJcIixrZT0wLHBlPTEsYmU9MSx3ZSp0PT0wP246bi5yZXBsYWNlKGMsXCJcIikucmVwbGFjZShnLFwiXCIpLnJlcGxhY2UoQSxcIiQxXCIpLnJlcGxhY2UoQyxcIiQxXCIpLnJlcGxhY2UodyxcIiBcIil9aWYoVGUudXNlPWZ1bmN0aW9uIGUoYSl7c3dpdGNoKGEpe2Nhc2Ugdm9pZCAwOmNhc2UgbnVsbDp5ZT0kZS5sZW5ndGg9MDticmVhaztkZWZhdWx0OmlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGEpJGVbeWUrK109YTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBhKWZvcih2YXIgcj0wLGM9YS5sZW5ndGg7cjxjOysrcillKGFbcl0pO2Vsc2UgcWU9MHwhIWF9cmV0dXJuIGV9LFRlLnNldD1SZSx2b2lkIDAhPT1hKVJlKGEpO3JldHVybiBUZX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGlzLm1pbi5qcy5tYXAiXSwibmFtZXMiOlsiZSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJ3aW5kb3ciLCJzdHlsaXMiLCJhIiwiciIsImMiLCJzIiwidCIsImkiLCJmIiwibiIsImwiLCJvIiwiaCIsInUiLCJkIiwiYiIsInAiLCJrIiwiZyIsIkEiLCJDIiwidyIsInYiLCJtIiwieCIsIiQiLCJ5IiwiTyIsImoiLCJ6IiwiTiIsIlMiLCJGIiwiVyIsInEiLCJCIiwiRCIsIkUiLCJHIiwiSCIsIkkiLCJKIiwiSyIsIkwiLCJNIiwiUCIsIlEiLCJSIiwiVCIsIlUiLCJWIiwiWCIsIlkiLCJaIiwiXyIsImVlIiwiYWUiLCJyZSIsImNlIiwic2UiLCJ0ZSIsImllIiwiZmUiLCJuZSIsImxlIiwib2UiLCJoZSIsInVlIiwiZGUiLCJiZSIsInBlIiwia2UiLCJnZSIsIkFlIiwiQ2UiLCJ3ZSIsInZlIiwibWUiLCJ4ZSIsIiRlIiwieWUiLCJPZSIsImplIiwiemUiLCJOZSIsIlNlIiwiRmUiLCJXZSIsInFlIiwiQmUiLCJEZSIsIkVlIiwiR2UiLCJIZSIsImxlbmd0aCIsIkplIiwiUmUiLCJUZSIsIlVlIiwiVmUiLCJYZSIsIlllIiwiY2hhckNvZGVBdCIsInJlcGxhY2UiLCJ0cmltIiwiY2hhckF0IiwiUWUiLCJzdWJzdHJpbmciLCJJZSIsIlBlIiwiam9pbiIsIk1lIiwiTGUiLCJLZSIsIkFycmF5Iiwic3BsaXQiLCJpbmRleE9mIiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwidGVzdCIsImNhbGwiLCJjb25zdHJ1Y3RvciIsInVzZSIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/node_modules/stylis/stylis.min.js\n");

/***/ })

};
;