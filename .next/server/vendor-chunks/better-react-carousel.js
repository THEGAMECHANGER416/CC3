/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-react-carousel";
exports.ids = ["vendor-chunks/better-react-carousel"];
exports.modules = {

/***/ "(ssr)/./node_modules/better-react-carousel/dist/bundle.js":
/*!***********************************************************!*\
  !*** ./node_modules/better-react-carousel/dist/bundle.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nfunction _interopDefault(ex) {\n    return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n}\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar React__default = _interopDefault(React);\nvar styled = _interopDefault(__webpack_require__(/*! styled-components */ \"(ssr)/./node_modules/better-react-carousel/node_modules/styled-components/dist/styled-components.esm.js\"));\nvar PropTypes = _interopDefault(__webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\"));\nvar smoothscroll = _interopDefault(__webpack_require__(/*! smoothscroll-polyfill */ \"(ssr)/./node_modules/smoothscroll-polyfill/dist/smoothscroll.js\"));\nvar debounce = _interopDefault(__webpack_require__(/*! lodash.debounce */ \"(ssr)/./node_modules/lodash.debounce/index.js\"));\nfunction _typeof(obj) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n        return typeof obj;\n    } : function(obj) {\n        return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar ButtonWrapper = styled.div.withConfig({\n    displayName: \"ArrowButton__ButtonWrapper\",\n    componentId: \"sc-1ikb0hj-0\"\n})([\n    \"@media screen and (max-width:\",\n    \"px){display:none;}\"\n], function(_ref) {\n    var mobileBreakpoint = _ref.mobileBreakpoint;\n    return mobileBreakpoint;\n});\nvar Button = styled.span.withConfig({\n    displayName: \"ArrowButton__Button\",\n    componentId: \"sc-1ikb0hj-1\"\n})([\n    \"position:absolute;top:calc(50% - 17.5px);height:35px;width:35px;background:#fff;border-radius:50%;box-shadow:0 0 5px 0 #0009;z-index:10;cursor:pointer;font-size:10px;opacity:0.6;transition:opacity 0.25s;left:\",\n    \";right:\",\n    \";&:hover{opacity:1;}&::before{content:'';height:10px;width:10px;background:transparent;border-top:2px solid #000;border-right:2px solid #000;display:inline-block;position:absolute;top:50%;left:50%;transform:\",\n    \";}\"\n], function(_ref2) {\n    var type = _ref2.type;\n    return type === \"prev\" ? \"5px\" : \"initial\";\n}, function(_ref3) {\n    var type = _ref3.type;\n    return type === \"next\" ? \"5px\" : \"initial\";\n}, function(_ref4) {\n    var type = _ref4.type;\n    return type === \"prev\" ? \"translate(-25%, -50%) rotate(-135deg)\" : \"translate(-75%, -50%) rotate(45deg)\";\n});\nvar ArrowButton = function ArrowButton(_ref5) {\n    var type = _ref5.type, _ref5$mobileBreakpoin = _ref5.mobileBreakpoint, mobileBreakpoint = _ref5$mobileBreakpoin === void 0 ? 1 : _ref5$mobileBreakpoin, _ref5$hidden = _ref5.hidden, hidden = _ref5$hidden === void 0 ? false : _ref5$hidden, CustomBtn = _ref5.CustomBtn, onClick = _ref5.onClick;\n    return /*#__PURE__*/ React__default.createElement(ButtonWrapper, {\n        mobileBreakpoint: mobileBreakpoint,\n        hidden: hidden,\n        onClick: onClick\n    }, CustomBtn ? typeof CustomBtn === \"function\" ? /*#__PURE__*/ React__default.createElement(CustomBtn, null) : CustomBtn : /*#__PURE__*/ React__default.createElement(Button, {\n        type: type\n    }));\n};\nArrowButton.propTypes = {\n    type: PropTypes.oneOf([\n        \"prev\",\n        \"next\"\n    ]).isRequired,\n    mobileBreakpoint: PropTypes.number,\n    hidden: PropTypes.bool,\n    CustomBtn: PropTypes.oneOfType([\n        PropTypes.node,\n        PropTypes.element,\n        PropTypes.elementType\n    ]),\n    onClick: PropTypes.func.isRequired\n};\nvar DotWrapper = styled.div.withConfig({\n    displayName: \"Dot__DotWrapper\",\n    componentId: \"sc-176tc56-0\"\n})([\n    \"display:flex;margin:0 5px;cursor:pointer;\"\n]);\nvar DotDefault = styled.div.withConfig({\n    displayName: \"Dot__DotDefault\",\n    componentId: \"sc-176tc56-1\"\n})([\n    \"width:8px;height:8px;border-radius:50%;background:\",\n    \";\"\n], function(_ref) {\n    var color = _ref.color;\n    return color;\n});\nvar Dot = function Dot(_ref2) {\n    var index = _ref2.index, _ref2$isActive = _ref2.isActive, isActive = _ref2$isActive === void 0 ? false : _ref2$isActive, dotColorInactive = _ref2.dotColorInactive, dotColorActive = _ref2.dotColorActive, DotCustom = _ref2.dot, onClick = _ref2.onClick;\n    var handleClick = React.useCallback(function() {\n        onClick(index);\n    }, [\n        index,\n        onClick\n    ]);\n    return /*#__PURE__*/ React__default.createElement(DotWrapper, {\n        onClick: handleClick\n    }, DotCustom ? /*#__PURE__*/ React__default.createElement(DotCustom, {\n        isActive: isActive\n    }) : /*#__PURE__*/ React__default.createElement(DotDefault, {\n        color: isActive ? dotColorActive : dotColorInactive\n    }));\n};\nDot.propTypes = {\n    index: PropTypes.number.isRequired,\n    isActive: PropTypes.bool,\n    dotColorInactive: PropTypes.string,\n    dotColorActive: PropTypes.string,\n    dot: PropTypes.oneOfType([\n        PropTypes.node,\n        PropTypes.element,\n        PropTypes.elementType\n    ]),\n    onClick: PropTypes.func.isRequired\n};\nvar HANDLER_NAME_SPACE = \"__react-grid-carousle-resize-handler\";\nvar handleResize = debounce(function(e) {\n    Object.values(window[HANDLER_NAME_SPACE]).forEach(function(handler) {\n        if (typeof handler === \"function\") {\n            handler(e);\n        }\n    });\n}, 16);\nvar setupListener = function setupListener() {\n    window.addEventListener(\"resize\", handleResize);\n};\nvar removeListener = function removeListener() {\n    window.removeEventListener(\"resize\", handleResize);\n};\nvar addResizeHandler = function addResizeHandler(key, handler) {\n    if (_typeof(window[HANDLER_NAME_SPACE]) !== \"object\") {\n        window[HANDLER_NAME_SPACE] = {};\n        setupListener();\n    }\n    window[HANDLER_NAME_SPACE][key] = handler;\n};\nvar removeResizeHandler = function removeResizeHandler(key) {\n    delete window[HANDLER_NAME_SPACE][key];\n    if (!Object.keys(window[HANDLER_NAME_SPACE])) {\n        delete window[HANDLER_NAME_SPACE];\n        removeListener();\n    }\n};\nvar useResponsiveLayout = function useResponsiveLayout() {\n    var breakpointList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var _useState = React.useState(), _useState2 = _slicedToArray(_useState, 2), currentBreakpointSetting = _useState2[0], setCurrentBreakpointSetting = _useState2[1];\n    var random = React.useMemo(function() {\n        return \"\".concat(Math.random(), \"-\").concat(Math.random());\n    }, []);\n    var sortedBreakpointList = React.useMemo(function() {\n        return _toConsumableArray(breakpointList).sort(function(a, b) {\n            return (b.breakpoint || 0) - (a.breakpoint || 0);\n        });\n    }, [\n        breakpointList\n    ]);\n    var handleResize = React.useCallback(function() {\n        var windowWidth = window.innerWidth;\n        var matchedSetting;\n        sortedBreakpointList.find(function(setting) {\n            if (windowWidth <= setting.breakpoint) {\n                matchedSetting = setting;\n            } else {\n                return true;\n            }\n        });\n        setCurrentBreakpointSetting(matchedSetting);\n    }, [\n        sortedBreakpointList\n    ]);\n    React.useEffect(function() {\n        if (breakpointList.length) {\n            handleResize();\n            addResizeHandler(\"responsiveLayout-\".concat(random), handleResize);\n            return function() {\n                removeResizeHandler(\"responsiveLayout-\".concat(random));\n            };\n        }\n    }, [\n        breakpointList,\n        handleResize,\n        random\n    ]);\n    return currentBreakpointSetting;\n};\nvar Container = styled.div.withConfig({\n    displayName: \"Carousel__Container\",\n    componentId: \"sc-hyhecw-0\"\n})([\n    \"position:relative;\"\n]);\nvar RailWrapper = styled.div.withConfig({\n    displayName: \"Carousel__RailWrapper\",\n    componentId: \"sc-hyhecw-1\"\n})([\n    \"overflow:hidden;margin:\",\n    \";@media screen and (max-width:\",\n    \"px){overflow-x:auto;margin:0;scroll-snap-type:\",\n    \";scrollbar-width:none;&::-webkit-scrollbar{display:none;}}\"\n], function(_ref) {\n    var showDots = _ref.showDots;\n    return showDots ? \"0 20px 15px 20px\" : \"0 20px\";\n}, function(_ref2) {\n    var mobileBreakpoint = _ref2.mobileBreakpoint;\n    return mobileBreakpoint;\n}, function(_ref3) {\n    var scrollSnap = _ref3.scrollSnap;\n    return scrollSnap ? \"x mandatory\" : \"\";\n});\nvar Rail = styled.div.withConfig({\n    displayName: \"Carousel__Rail\",\n    componentId: \"sc-hyhecw-2\"\n})([\n    \"display:grid;grid-column-gap:\",\n    \";position:relative;transition:transform 0.5s cubic-bezier(0.2,1,0.3,1) 0s;grid-template-columns:\",\n    \";transform:\",\n    \";@media screen and (max-width:\",\n    \"px){padding-left:\",\n    \";grid-template-columns:\",\n    \";grid-column-gap:\",\n    \";transform:translateX(0);}\"\n], function(_ref4) {\n    var gap = _ref4.gap;\n    return \"\".concat(gap, \"px\");\n}, function(_ref5) {\n    var page = _ref5.page;\n    return \"repeat(\".concat(page, \", 100%)\");\n}, function(_ref6) {\n    var currentPage = _ref6.currentPage, gap = _ref6.gap;\n    return \"translateX(calc(\".concat(-100 * currentPage, \"% - \").concat(gap * currentPage, \"px))\");\n}, function(_ref7) {\n    var mobileBreakpoint = _ref7.mobileBreakpoint;\n    return mobileBreakpoint;\n}, function(_ref8) {\n    var gap = _ref8.gap;\n    return \"\".concat(gap, \"px\");\n}, function(_ref9) {\n    var page = _ref9.page;\n    return \"repeat(\".concat(page, \", 90%)\");\n}, function(_ref10) {\n    var cols = _ref10.cols, rows = _ref10.rows, gap = _ref10.gap;\n    return \"calc(\".concat((cols * rows - 1) * 90, \"% + \").concat(cols * rows * gap, \"px)\");\n});\nvar ItemSet = styled.div.withConfig({\n    displayName: \"Carousel__ItemSet\",\n    componentId: \"sc-hyhecw-3\"\n})([\n    \"display:grid;grid-template-columns:\",\n    \";grid-template-rows:\",\n    \";grid-gap:\",\n    \";@media screen and (max-width:\",\n    \"px){grid-template-columns:\",\n    \";grid-template-rows:1fr;&:last-of-type > \",\n    \":last-of-type{padding-right:\",\n    \";margin-right:\",\n    \";}}\"\n], function(_ref11) {\n    var cols = _ref11.cols;\n    return \"repeat(\".concat(cols, \", 1fr)\");\n}, function(_ref12) {\n    var rows = _ref12.rows;\n    return \"repeat(\".concat(rows, \", 1fr)\");\n}, function(_ref13) {\n    var gap = _ref13.gap;\n    return \"\".concat(gap, \"px\");\n}, function(_ref14) {\n    var mobileBreakpoint = _ref14.mobileBreakpoint;\n    return mobileBreakpoint;\n}, function(_ref15) {\n    var cols = _ref15.cols, rows = _ref15.rows;\n    return \"repeat(\".concat(cols * rows, \", 100%)\");\n}, /* sc-sel */ Item, function(_ref16) {\n    var gap = _ref16.gap;\n    return \"\".concat(gap, \"px\");\n}, function(_ref17) {\n    var gap = _ref17.gap;\n    return \"-\".concat(gap, \"px\");\n});\nvar Dots = styled.div.withConfig({\n    displayName: \"Carousel__Dots\",\n    componentId: \"sc-hyhecw-4\"\n})([\n    \"position:absolute;display:flex;align-items:center;justify-content:center;bottom:-12px;height:10px;width:100%;line-height:10px;text-align:center;@media screen and (max-width:\",\n    \"px){display:none;}\"\n], function(_ref18) {\n    var mobileBreakpoint = _ref18.mobileBreakpoint;\n    return mobileBreakpoint;\n});\nvar Item = styled.div.withConfig({\n    displayName: \"Carousel__Item\",\n    componentId: \"sc-hyhecw-5\"\n})([\n    \"scroll-snap-align:\",\n    \";\"\n], function(_ref19) {\n    var scrollSnap = _ref19.scrollSnap;\n    return scrollSnap ? \"center\" : \"\";\n});\nvar CAROUSEL_ITEM = \"CAROUSEL_ITEM\";\nvar Carousel = function Carousel(_ref20) {\n    var _ref20$cols = _ref20.cols, colsProp = _ref20$cols === void 0 ? 1 : _ref20$cols, _ref20$rows = _ref20.rows, rowsProp = _ref20$rows === void 0 ? 1 : _ref20$rows, _ref20$gap = _ref20.gap, gapProp = _ref20$gap === void 0 ? 10 : _ref20$gap, _ref20$loop = _ref20.loop, loopProp = _ref20$loop === void 0 ? false : _ref20$loop, _ref20$scrollSnap = _ref20.scrollSnap, scrollSnap = _ref20$scrollSnap === void 0 ? true : _ref20$scrollSnap, _ref20$hideArrow = _ref20.hideArrow, hideArrow = _ref20$hideArrow === void 0 ? false : _ref20$hideArrow, _ref20$showDots = _ref20.showDots, showDots = _ref20$showDots === void 0 ? false : _ref20$showDots, autoplayProp = _ref20.autoplay, _ref20$dotColorActive = _ref20.dotColorActive, dotColorActive = _ref20$dotColorActive === void 0 ? \"#795548\" : _ref20$dotColorActive, _ref20$dotColorInacti = _ref20.dotColorInactive, dotColorInactive = _ref20$dotColorInacti === void 0 ? \"#ccc\" : _ref20$dotColorInacti, responsiveLayout = _ref20.responsiveLayout, _ref20$mobileBreakpoi = _ref20.mobileBreakpoint, mobileBreakpoint = _ref20$mobileBreakpoi === void 0 ? 767 : _ref20$mobileBreakpoi, arrowLeft = _ref20.arrowLeft, arrowRight = _ref20.arrowRight, dot = _ref20.dot, _ref20$containerClass = _ref20.containerClassName, containerClassName = _ref20$containerClass === void 0 ? \"\" : _ref20$containerClass, _ref20$containerStyle = _ref20.containerStyle, containerStyle = _ref20$containerStyle === void 0 ? {} : _ref20$containerStyle, children = _ref20.children;\n    var _useState = React.useState(0), _useState2 = _slicedToArray(_useState, 2), currentPage = _useState2[0], setCurrentPage = _useState2[1];\n    var _useState3 = React.useState(false), _useState4 = _slicedToArray(_useState3, 2), isHover = _useState4[0], setIsHover = _useState4[1];\n    var _useState5 = React.useState(false), _useState6 = _slicedToArray(_useState5, 2), isTouch = _useState6[0], setIsTouch = _useState6[1];\n    var _useState7 = React.useState(colsProp), _useState8 = _slicedToArray(_useState7, 2), cols = _useState8[0], setCols = _useState8[1];\n    var _useState9 = React.useState(rowsProp), _useState10 = _slicedToArray(_useState9, 2), rows = _useState10[0], setRows = _useState10[1];\n    var _useState11 = React.useState(0), _useState12 = _slicedToArray(_useState11, 2), gap = _useState12[0], setGap = _useState12[1];\n    var _useState13 = React.useState(loopProp), _useState14 = _slicedToArray(_useState13, 2), loop = _useState14[0], setLoop = _useState14[1];\n    var _useState15 = React.useState(autoplayProp), _useState16 = _slicedToArray(_useState15, 2), autoplay = _useState16[0], setAutoplay = _useState16[1];\n    var _useState17 = React.useState(0), _useState18 = _slicedToArray(_useState17, 2), railWrapperWidth = _useState18[0], setRailWrapperWidth = _useState18[1];\n    var _useState19 = React.useState(false), _useState20 = _slicedToArray(_useState19, 2), hasSetResizeHandler = _useState20[0], setHasSetResizeHandler = _useState20[1];\n    var railWrapperRef = React.useRef(null);\n    var autoplayIntervalRef = React.useRef(null);\n    var breakpointSetting = useResponsiveLayout(responsiveLayout);\n    var randomKey = React.useMemo(function() {\n        return \"\".concat(Math.random(), \"-\").concat(Math.random());\n    }, []);\n    React.useEffect(function() {\n        smoothscroll.polyfill();\n    }, []);\n    React.useEffect(function() {\n        var _ref21 = breakpointSetting || {}, cols = _ref21.cols, rows = _ref21.rows, gap = _ref21.gap, loop = _ref21.loop, autoplay = _ref21.autoplay;\n        setCols(cols || colsProp);\n        setRows(rows || rowsProp);\n        setGap(parseGap(gap || gapProp));\n        setLoop(loop || loopProp);\n        setAutoplay(autoplay || autoplayProp);\n        setCurrentPage(0);\n    }, [\n        breakpointSetting,\n        colsProp,\n        rowsProp,\n        gapProp,\n        loopProp,\n        autoplayProp,\n        parseGap\n    ]);\n    var handleRailWrapperResize = React.useCallback(function() {\n        railWrapperRef.current && setRailWrapperWidth(railWrapperRef.current.offsetWidth);\n    }, [\n        railWrapperRef\n    ]);\n    var setResizeHandler = React.useCallback(function() {\n        addResizeHandler(\"gapCalculator-\".concat(randomKey), handleRailWrapperResize);\n        setHasSetResizeHandler(true);\n    }, [\n        randomKey,\n        handleRailWrapperResize\n    ]);\n    var rmResizeHandler = React.useCallback(function() {\n        removeResizeHandler(\"gapCalculator-\".concat(randomKey));\n        setHasSetResizeHandler(false);\n    }, [\n        randomKey\n    ]);\n    var parseGap = React.useCallback(function(gap) {\n        var parsed = gap;\n        var shouldSetResizeHandler = false;\n        if (typeof gap !== \"number\") {\n            switch(/\\D*$/.exec(gap)[0]){\n                case \"px\":\n                    {\n                        parsed = +gap.replace(\"px\", \"\");\n                        break;\n                    }\n                case \"%\":\n                    {\n                        var wrapperWidth = railWrapperWidth || railWrapperRef.current ? railWrapperRef.current.offsetWidth : 0;\n                        parsed = wrapperWidth * gap.replace(\"%\", \"\") / 100;\n                        shouldSetResizeHandler = true;\n                        break;\n                    }\n                default:\n                    {\n                        parsed = 0;\n                        console.error(\"Doesn't support the provided measurement unit: \".concat(gap));\n                    }\n            }\n        }\n        shouldSetResizeHandler && !hasSetResizeHandler && setResizeHandler();\n        !shouldSetResizeHandler && hasSetResizeHandler && rmResizeHandler();\n        return parsed;\n    }, [\n        railWrapperWidth,\n        railWrapperRef,\n        hasSetResizeHandler,\n        setResizeHandler,\n        rmResizeHandler\n    ]);\n    var itemList = React.useMemo(function() {\n        return React__default.Children.toArray(children).filter(function(child) {\n            return child.type.displayName === CAROUSEL_ITEM;\n        });\n    }, [\n        children\n    ]);\n    var itemAmountPerSet = cols * rows;\n    var itemSetList = React.useMemo(function() {\n        return itemList.reduce(function(result, item, i) {\n            var itemComponent = /*#__PURE__*/ React__default.createElement(Item, {\n                key: i,\n                scrollSnap: scrollSnap\n            }, item);\n            if (i % itemAmountPerSet === 0) {\n                result.push([\n                    itemComponent\n                ]);\n            } else {\n                result[result.length - 1].push(itemComponent);\n            }\n            return result;\n        }, []);\n    }, [\n        itemList,\n        itemAmountPerSet,\n        scrollSnap\n    ]);\n    var page = Math.ceil(itemList.length / itemAmountPerSet);\n    var handlePrev = React.useCallback(function() {\n        setCurrentPage(function(p) {\n            var prevPage = p - 1;\n            if (loop && prevPage < 0) {\n                return page - 1;\n            }\n            return prevPage;\n        });\n    }, [\n        loop,\n        page\n    ]);\n    var handleNext = React.useCallback(function() {\n        var isMobile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var railWrapper = railWrapperRef.current;\n        if (isMobile && railWrapper) {\n            if (!scrollSnap) {\n                return;\n            }\n            var scrollLeft = railWrapper.scrollLeft, offsetWidth = railWrapper.offsetWidth, scrollWidth = railWrapper.scrollWidth;\n            railWrapper.scrollBy({\n                top: 0,\n                left: loop && scrollLeft + offsetWidth >= scrollWidth ? -scrollLeft : scrollLeft === 0 ? gap + (offsetWidth - gap) * 0.9 - (offsetWidth * 0.1 - gap * 1.1) / 2 : (offsetWidth - gap) * 0.9 + gap,\n                behavior: \"smooth\"\n            });\n        } else {\n            setCurrentPage(function(p) {\n                var nextPage = p + 1;\n                if (nextPage >= page) {\n                    return loop ? 0 : p;\n                }\n                return nextPage;\n            });\n        }\n    }, [\n        loop,\n        page,\n        gap,\n        railWrapperRef,\n        scrollSnap\n    ]);\n    var startAutoplayInterval = React.useCallback(function() {\n        if (autoplayIntervalRef.current === null && typeof autoplay === \"number\") {\n            autoplayIntervalRef.current = setInterval(function() {\n                handleNext(window.innerWidth <= mobileBreakpoint);\n            }, autoplay);\n        }\n    }, [\n        autoplay,\n        autoplayIntervalRef,\n        handleNext,\n        mobileBreakpoint\n    ]);\n    React.useEffect(function() {\n        startAutoplayInterval();\n        return function() {\n            if (autoplayIntervalRef.current !== null) {\n                clearInterval(autoplayIntervalRef.current);\n                autoplayIntervalRef.current = null;\n            }\n        };\n    }, [\n        startAutoplayInterval,\n        autoplayIntervalRef\n    ]);\n    React.useEffect(function() {\n        if (isHover || isTouch) {\n            clearInterval(autoplayIntervalRef.current);\n            autoplayIntervalRef.current = null;\n        } else {\n            startAutoplayInterval();\n        }\n    }, [\n        isHover,\n        isTouch,\n        autoplayIntervalRef,\n        startAutoplayInterval\n    ]);\n    var turnToPage = React.useCallback(function(page) {\n        setCurrentPage(page);\n    }, []);\n    var handleHover = React.useCallback(function() {\n        setIsHover(function(hover) {\n            return !hover;\n        });\n    }, []);\n    var handleTouch = React.useCallback(function() {\n        setIsTouch(function(touch) {\n            return !touch;\n        });\n    }, []);\n    return /*#__PURE__*/ React__default.createElement(Container, {\n        onMouseEnter: handleHover,\n        onMouseLeave: handleHover,\n        onTouchStart: handleTouch,\n        onTouchEnd: handleTouch,\n        className: containerClassName,\n        style: containerStyle\n    }, /*#__PURE__*/ React__default.createElement(ArrowButton, {\n        type: \"prev\",\n        mobileBreakpoint: mobileBreakpoint,\n        hidden: hideArrow || !loop && currentPage <= 0,\n        CustomBtn: arrowLeft,\n        onClick: handlePrev\n    }), /*#__PURE__*/ React__default.createElement(RailWrapper, {\n        mobileBreakpoint: mobileBreakpoint,\n        scrollSnap: scrollSnap,\n        showDots: showDots,\n        ref: railWrapperRef\n    }, /*#__PURE__*/ React__default.createElement(Rail, {\n        cols: cols,\n        rows: rows,\n        page: page,\n        gap: gap,\n        currentPage: currentPage,\n        mobileBreakpoint: mobileBreakpoint\n    }, itemSetList.map(function(set, i) {\n        return /*#__PURE__*/ React__default.createElement(ItemSet, {\n            key: i,\n            cols: cols,\n            rows: rows,\n            gap: gap,\n            mobileBreakpoint: mobileBreakpoint\n        }, set);\n    }))), showDots && /*#__PURE__*/ React__default.createElement(Dots, {\n        mobileBreakpoint: mobileBreakpoint\n    }, _toConsumableArray(Array(page)).map(function(_, i) {\n        return /*#__PURE__*/ React__default.createElement(Dot, {\n            key: i,\n            index: i,\n            isActive: i === currentPage,\n            dotColorInactive: dotColorInactive,\n            dotColorActive: dotColorActive,\n            dot: dot,\n            onClick: turnToPage\n        });\n    })), /*#__PURE__*/ React__default.createElement(ArrowButton, {\n        type: \"next\",\n        mobileBreakpoint: mobileBreakpoint,\n        hidden: hideArrow || !loop && currentPage === page - 1,\n        CustomBtn: arrowRight,\n        onClick: handleNext.bind(null, false)\n    }));\n};\nCarousel.Item = function(_ref22) {\n    var children = _ref22.children;\n    return children;\n};\nCarousel.Item.displayName = CAROUSEL_ITEM;\nmodule.exports = Carousel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL2Rpc3QvYnVuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0EsZ0JBQWlCQyxFQUFFO0lBQUksT0FBTyxNQUFRLE9BQU9BLE9BQU8sWUFBYSxhQUFhQSxLQUFNQSxFQUFFLENBQUMsVUFBVSxHQUFHQTtBQUFJO0FBRWpILElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLGlCQUFpQkosZ0JBQWdCRTtBQUNyQyxJQUFJRyxTQUFTTCxnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBQ3JDLElBQUlHLFlBQVlOLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDeEMsSUFBSUksZUFBZVAsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUMzQyxJQUFJSyxXQUFXUixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBRXZDLFNBQVNNLFFBQVFDLEdBQUc7SUFDbEI7SUFFQSxPQUFPRCxVQUFVLGNBQWMsT0FBT0UsVUFBVSxZQUFZLE9BQU9BLE9BQU9DLFFBQVEsR0FBRyxTQUFVRixHQUFHO1FBQ2hHLE9BQU8sT0FBT0E7SUFDaEIsSUFBSSxTQUFVQSxHQUFHO1FBQ2YsT0FBT0EsT0FBTyxjQUFjLE9BQU9DLFVBQVVELElBQUlHLFdBQVcsS0FBS0YsVUFBVUQsUUFBUUMsT0FBT0csU0FBUyxHQUFHLFdBQVcsT0FBT0o7SUFDMUgsR0FBR0QsUUFBUUM7QUFDYjtBQUVBLFNBQVNLLGVBQWVDLEdBQUcsRUFBRUMsQ0FBQztJQUM1QixPQUFPQyxnQkFBZ0JGLFFBQVFHLHNCQUFzQkgsS0FBS0MsTUFBTUcsNEJBQTRCSixLQUFLQyxNQUFNSTtBQUN6RztBQUVBLFNBQVNDLG1CQUFtQk4sR0FBRztJQUM3QixPQUFPTyxtQkFBbUJQLFFBQVFRLGlCQUFpQlIsUUFBUUksNEJBQTRCSixRQUFRUztBQUNqRztBQUVBLFNBQVNGLG1CQUFtQlAsR0FBRztJQUM3QixJQUFJVSxNQUFNQyxPQUFPLENBQUNYLE1BQU0sT0FB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V0FBVzRCLElBQUksQ0FBQyxNQUFNO0lBQ2pDO0FBQ0Y7QUFFQTNILFNBQVNQLElBQUksR0FBRyxTQUFVbUksTUFBTTtJQUM5QixJQUFJakcsV0FBV2lHLE9BQU9qRyxRQUFRO0lBQzlCLE9BQU9BO0FBQ1Q7QUFFQTNCLFNBQVNQLElBQUksQ0FBQ3RHLFdBQVcsR0FBRzRHO0FBRTVCOEgsT0FBT0MsT0FBTyxHQUFHOUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2RlX2N1YmljbGVfMy8uL25vZGVfbW9kdWxlcy9iZXR0ZXItcmVhY3QtY2Fyb3VzZWwvZGlzdC9idW5kbGUuanM/NTIzZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIFJlYWN0X19kZWZhdWx0ID0gX2ludGVyb3BEZWZhdWx0KFJlYWN0KTtcbnZhciBzdHlsZWQgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnc3R5bGVkLWNvbXBvbmVudHMnKSk7XG52YXIgUHJvcFR5cGVzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3Byb3AtdHlwZXMnKSk7XG52YXIgc21vb3Roc2Nyb2xsID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3Ntb290aHNjcm9sbC1wb2x5ZmlsbCcpKTtcbnZhciBkZWJvdW5jZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdsb2Rhc2guZGVib3VuY2UnKSk7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcblxuICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcblxuICB2YXIgX3MsIF9lO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgQnV0dG9uV3JhcHBlciA9IHN0eWxlZC5kaXYud2l0aENvbmZpZyh7XG4gIGRpc3BsYXlOYW1lOiBcIkFycm93QnV0dG9uX19CdXR0b25XcmFwcGVyXCIsXG4gIGNvbXBvbmVudElkOiBcInNjLTFpa2IwaGotMFwiXG59KShbXCJAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOlwiLCBcInB4KXtkaXNwbGF5Om5vbmU7fVwiXSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIG1vYmlsZUJyZWFrcG9pbnQgPSBfcmVmLm1vYmlsZUJyZWFrcG9pbnQ7XG4gIHJldHVybiBtb2JpbGVCcmVha3BvaW50O1xufSk7XG52YXIgQnV0dG9uID0gc3R5bGVkLnNwYW4ud2l0aENvbmZpZyh7XG4gIGRpc3BsYXlOYW1lOiBcIkFycm93QnV0dG9uX19CdXR0b25cIixcbiAgY29tcG9uZW50SWQ6IFwic2MtMWlrYjBoai0xXCJcbn0pKFtcInBvc2l0aW9uOmFic29sdXRlO3RvcDpjYWxjKDUwJSAtIDE3LjVweCk7aGVpZ2h0OjM1cHg7d2lkdGg6MzVweDtiYWNrZ3JvdW5kOiNmZmY7Ym9yZGVyLXJhZGl1czo1MCU7Ym94LXNoYWRvdzowIDAgNXB4IDAgIzAwMDk7ei1pbmRleDoxMDtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MTBweDtvcGFjaXR5OjAuNjt0cmFuc2l0aW9uOm9wYWNpdHkgMC4yNXM7bGVmdDpcIiwgXCI7cmlnaHQ6XCIsIFwiOyY6aG92ZXJ7b3BhY2l0eToxO30mOjpiZWZvcmV7Y29udGVudDonJztoZWlnaHQ6MTBweDt3aWR0aDoxMHB4O2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcDoycHggc29saWQgIzAwMDtib3JkZXItcmlnaHQ6MnB4IHNvbGlkICMwMDA7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTt0cmFuc2Zvcm06XCIsIFwiO31cIl0sIGZ1bmN0aW9uIChfcmVmMikge1xuICB2YXIgdHlwZSA9IF9yZWYyLnR5cGU7XG4gIHJldHVybiB0eXBlID09PSAncHJldicgPyAnNXB4JyA6ICdpbml0aWFsJztcbn0sIGZ1bmN0aW9uIChfcmVmMykge1xuICB2YXIgdHlwZSA9IF9yZWYzLnR5cGU7XG4gIHJldHVybiB0eXBlID09PSAnbmV4dCcgPyAnNXB4JyA6ICdpbml0aWFsJztcbn0sIGZ1bmN0aW9uIChfcmVmNCkge1xuICB2YXIgdHlwZSA9IF9yZWY0LnR5cGU7XG4gIHJldHVybiB0eXBlID09PSAncHJldicgPyAndHJhbnNsYXRlKC0yNSUsIC01MCUpIHJvdGF0ZSgtMTM1ZGVnKScgOiAndHJhbnNsYXRlKC03NSUsIC01MCUpIHJvdGF0ZSg0NWRlZyknO1xufSk7XG5cbnZhciBBcnJvd0J1dHRvbiA9IGZ1bmN0aW9uIEFycm93QnV0dG9uKF9yZWY1KSB7XG4gIHZhciB0eXBlID0gX3JlZjUudHlwZSxcbiAgICAgIF9yZWY1JG1vYmlsZUJyZWFrcG9pbiA9IF9yZWY1Lm1vYmlsZUJyZWFrcG9pbnQsXG4gICAgICBtb2JpbGVCcmVha3BvaW50ID0gX3JlZjUkbW9iaWxlQnJlYWtwb2luID09PSB2b2lkIDAgPyAxIDogX3JlZjUkbW9iaWxlQnJlYWtwb2luLFxuICAgICAgX3JlZjUkaGlkZGVuID0gX3JlZjUuaGlkZGVuLFxuICAgICAgaGlkZGVuID0gX3JlZjUkaGlkZGVuID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY1JGhpZGRlbixcbiAgICAgIEN1c3RvbUJ0biA9IF9yZWY1LkN1c3RvbUJ0bixcbiAgICAgIG9uQ2xpY2sgPSBfcmVmNS5vbkNsaWNrO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uV3JhcHBlciwge1xuICAgIG1vYmlsZUJyZWFrcG9pbnQ6IG1vYmlsZUJyZWFrcG9pbnQsXG4gICAgaGlkZGVuOiBoaWRkZW4sXG4gICAgb25DbGljazogb25DbGlja1xuICB9LCBDdXN0b21CdG4gPyB0eXBlb2YgQ3VzdG9tQnRuID09PSAnZnVuY3Rpb24nID8gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ3VzdG9tQnRuLCBudWxsKSA6IEN1c3RvbUJ0biA6IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEJ1dHRvbiwge1xuICAgIHR5cGU6IHR5cGVcbiAgfSkpO1xufTtcblxuQXJyb3dCdXR0b24ucHJvcFR5cGVzID0ge1xuICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydwcmV2JywgJ25leHQnXSkuaXNSZXF1aXJlZCxcbiAgbW9iaWxlQnJlYWtwb2ludDogUHJvcFR5cGVzLm51bWJlcixcbiAgaGlkZGVuOiBQcm9wVHlwZXMuYm9vbCxcbiAgQ3VzdG9tQnRuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5lbGVtZW50VHlwZV0pLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59O1xuXG52YXIgRG90V3JhcHBlciA9IHN0eWxlZC5kaXYud2l0aENvbmZpZyh7XG4gIGRpc3BsYXlOYW1lOiBcIkRvdF9fRG90V3JhcHBlclwiLFxuICBjb21wb25lbnRJZDogXCJzYy0xNzZ0YzU2LTBcIlxufSkoW1wiZGlzcGxheTpmbGV4O21hcmdpbjowIDVweDtjdXJzb3I6cG9pbnRlcjtcIl0pO1xudmFyIERvdERlZmF1bHQgPSBzdHlsZWQuZGl2LndpdGhDb25maWcoe1xuICBkaXNwbGF5TmFtZTogXCJEb3RfX0RvdERlZmF1bHRcIixcbiAgY29tcG9uZW50SWQ6IFwic2MtMTc2dGM1Ni0xXCJcbn0pKFtcIndpZHRoOjhweDtoZWlnaHQ6OHB4O2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQ6XCIsIFwiO1wiXSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGNvbG9yID0gX3JlZi5jb2xvcjtcbiAgcmV0dXJuIGNvbG9yO1xufSk7XG5cbnZhciBEb3QgPSBmdW5jdGlvbiBEb3QoX3JlZjIpIHtcbiAgdmFyIGluZGV4ID0gX3JlZjIuaW5kZXgsXG4gICAgICBfcmVmMiRpc0FjdGl2ZSA9IF9yZWYyLmlzQWN0aXZlLFxuICAgICAgaXNBY3RpdmUgPSBfcmVmMiRpc0FjdGl2ZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRpc0FjdGl2ZSxcbiAgICAgIGRvdENvbG9ySW5hY3RpdmUgPSBfcmVmMi5kb3RDb2xvckluYWN0aXZlLFxuICAgICAgZG90Q29sb3JBY3RpdmUgPSBfcmVmMi5kb3RDb2xvckFjdGl2ZSxcbiAgICAgIERvdEN1c3RvbSA9IF9yZWYyLmRvdCxcbiAgICAgIG9uQ2xpY2sgPSBfcmVmMi5vbkNsaWNrO1xuICB2YXIgaGFuZGxlQ2xpY2sgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgb25DbGljayhpbmRleCk7XG4gIH0sIFtpbmRleCwgb25DbGlja10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoRG90V3JhcHBlciwge1xuICAgIG9uQ2xpY2s6IGhhbmRsZUNsaWNrXG4gIH0sIERvdEN1c3RvbSA/IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERvdEN1c3RvbSwge1xuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZVxuICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERvdERlZmF1bHQsIHtcbiAgICBjb2xvcjogaXNBY3RpdmUgPyBkb3RDb2xvckFjdGl2ZSA6IGRvdENvbG9ySW5hY3RpdmVcbiAgfSkpO1xufTtcblxuRG90LnByb3BUeXBlcyA9IHtcbiAgaW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgaXNBY3RpdmU6IFByb3BUeXBlcy5ib29sLFxuICBkb3RDb2xvckluYWN0aXZlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBkb3RDb2xvckFjdGl2ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZG90OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubm9kZSwgUHJvcFR5cGVzLmVsZW1lbnQsIFByb3BUeXBlcy5lbGVtZW50VHlwZV0pLFxuICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG59O1xuXG52YXIgSEFORExFUl9OQU1FX1NQQUNFID0gJ19fcmVhY3QtZ3JpZC1jYXJvdXNsZS1yZXNpemUtaGFuZGxlcic7XG52YXIgaGFuZGxlUmVzaXplID0gZGVib3VuY2UoZnVuY3Rpb24gKGUpIHtcbiAgT2JqZWN0LnZhbHVlcyh3aW5kb3dbSEFORExFUl9OQU1FX1NQQUNFXSkuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaGFuZGxlcihlKTtcbiAgICB9XG4gIH0pO1xufSwgMTYpO1xuXG52YXIgc2V0dXBMaXN0ZW5lciA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXIoKSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xufTtcblxudmFyIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xufTtcblxudmFyIGFkZFJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbiBhZGRSZXNpemVIYW5kbGVyKGtleSwgaGFuZGxlcikge1xuICBpZiAoX3R5cGVvZih3aW5kb3dbSEFORExFUl9OQU1FX1NQQUNFXSkgIT09ICdvYmplY3QnKSB7XG4gICAgd2luZG93W0hBTkRMRVJfTkFNRV9TUEFDRV0gPSB7fTtcbiAgICBzZXR1cExpc3RlbmVyKCk7XG4gIH1cblxuICB3aW5kb3dbSEFORExFUl9OQU1FX1NQQUNFXVtrZXldID0gaGFuZGxlcjtcbn07XG52YXIgcmVtb3ZlUmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uIHJlbW92ZVJlc2l6ZUhhbmRsZXIoa2V5KSB7XG4gIGRlbGV0ZSB3aW5kb3dbSEFORExFUl9OQU1FX1NQQUNFXVtrZXldO1xuXG4gIGlmICghT2JqZWN0LmtleXMod2luZG93W0hBTkRMRVJfTkFNRV9TUEFDRV0pKSB7XG4gICAgZGVsZXRlIHdpbmRvd1tIQU5ETEVSX05BTUVfU1BBQ0VdO1xuICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gIH1cbn07XG5cbnZhciB1c2VSZXNwb25zaXZlTGF5b3V0ID0gZnVuY3Rpb24gdXNlUmVzcG9uc2l2ZUxheW91dCgpIHtcbiAgdmFyIGJyZWFrcG9pbnRMaXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBbXTtcblxuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoKSxcbiAgICAgIF91c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUsIDIpLFxuICAgICAgY3VycmVudEJyZWFrcG9pbnRTZXR0aW5nID0gX3VzZVN0YXRlMlswXSxcbiAgICAgIHNldEN1cnJlbnRCcmVha3BvaW50U2V0dGluZyA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIHJhbmRvbSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChNYXRoLnJhbmRvbSgpLCBcIi1cIikuY29uY2F0KE1hdGgucmFuZG9tKCkpO1xuICB9LCBbXSk7XG4gIHZhciBzb3J0ZWRCcmVha3BvaW50TGlzdCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9Db25zdW1hYmxlQXJyYXkoYnJlYWtwb2ludExpc3QpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiAoYi5icmVha3BvaW50IHx8IDApIC0gKGEuYnJlYWtwb2ludCB8fCAwKTtcbiAgICB9KTtcbiAgfSwgW2JyZWFrcG9pbnRMaXN0XSk7XG4gIHZhciBoYW5kbGVSZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgdmFyIG1hdGNoZWRTZXR0aW5nO1xuICAgIHNvcnRlZEJyZWFrcG9pbnRMaXN0LmZpbmQoZnVuY3Rpb24gKHNldHRpbmcpIHtcbiAgICAgIGlmICh3aW5kb3dXaWR0aCA8PSBzZXR0aW5nLmJyZWFrcG9pbnQpIHtcbiAgICAgICAgbWF0Y2hlZFNldHRpbmcgPSBzZXR0aW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0Q3VycmVudEJyZWFrcG9pbnRTZXR0aW5nKG1hdGNoZWRTZXR0aW5nKTtcbiAgfSwgW3NvcnRlZEJyZWFrcG9pbnRMaXN0XSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGJyZWFrcG9pbnRMaXN0Lmxlbmd0aCkge1xuICAgICAgaGFuZGxlUmVzaXplKCk7XG4gICAgICBhZGRSZXNpemVIYW5kbGVyKFwicmVzcG9uc2l2ZUxheW91dC1cIi5jb25jYXQocmFuZG9tKSwgaGFuZGxlUmVzaXplKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXIoXCJyZXNwb25zaXZlTGF5b3V0LVwiLmNvbmNhdChyYW5kb20pKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbYnJlYWtwb2ludExpc3QsIGhhbmRsZVJlc2l6ZSwgcmFuZG9tXSk7XG4gIHJldHVybiBjdXJyZW50QnJlYWtwb2ludFNldHRpbmc7XG59O1xuXG52YXIgQ29udGFpbmVyID0gc3R5bGVkLmRpdi53aXRoQ29uZmlnKHtcbiAgZGlzcGxheU5hbWU6IFwiQ2Fyb3VzZWxfX0NvbnRhaW5lclwiLFxuICBjb21wb25lbnRJZDogXCJzYy1oeWhlY3ctMFwiXG59KShbXCJwb3NpdGlvbjpyZWxhdGl2ZTtcIl0pO1xudmFyIFJhaWxXcmFwcGVyID0gc3R5bGVkLmRpdi53aXRoQ29uZmlnKHtcbiAgZGlzcGxheU5hbWU6IFwiQ2Fyb3VzZWxfX1JhaWxXcmFwcGVyXCIsXG4gIGNvbXBvbmVudElkOiBcInNjLWh5aGVjdy0xXCJcbn0pKFtcIm92ZXJmbG93OmhpZGRlbjttYXJnaW46XCIsIFwiO0BtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6XCIsIFwicHgpe292ZXJmbG93LXg6YXV0bzttYXJnaW46MDtzY3JvbGwtc25hcC10eXBlOlwiLCBcIjtzY3JvbGxiYXItd2lkdGg6bm9uZTsmOjotd2Via2l0LXNjcm9sbGJhcntkaXNwbGF5Om5vbmU7fX1cIl0sIGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBzaG93RG90cyA9IF9yZWYuc2hvd0RvdHM7XG4gIHJldHVybiBzaG93RG90cyA/ICcwIDIwcHggMTVweCAyMHB4JyA6ICcwIDIwcHgnO1xufSwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gIHZhciBtb2JpbGVCcmVha3BvaW50ID0gX3JlZjIubW9iaWxlQnJlYWtwb2ludDtcbiAgcmV0dXJuIG1vYmlsZUJyZWFrcG9pbnQ7XG59LCBmdW5jdGlvbiAoX3JlZjMpIHtcbiAgdmFyIHNjcm9sbFNuYXAgPSBfcmVmMy5zY3JvbGxTbmFwO1xuICByZXR1cm4gc2Nyb2xsU25hcCA/ICd4IG1hbmRhdG9yeScgOiAnJztcbn0pO1xudmFyIFJhaWwgPSBzdHlsZWQuZGl2LndpdGhDb25maWcoe1xuICBkaXNwbGF5TmFtZTogXCJDYXJvdXNlbF9fUmFpbFwiLFxuICBjb21wb25lbnRJZDogXCJzYy1oeWhlY3ctMlwiXG59KShbXCJkaXNwbGF5OmdyaWQ7Z3JpZC1jb2x1bW4tZ2FwOlwiLCBcIjtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjVzIGN1YmljLWJlemllcigwLjIsMSwwLjMsMSkgMHM7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOlwiLCBcIjt0cmFuc2Zvcm06XCIsIFwiO0BtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6XCIsIFwicHgpe3BhZGRpbmctbGVmdDpcIiwgXCI7Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOlwiLCBcIjtncmlkLWNvbHVtbi1nYXA6XCIsIFwiO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDApO31cIl0sIGZ1bmN0aW9uIChfcmVmNCkge1xuICB2YXIgZ2FwID0gX3JlZjQuZ2FwO1xuICByZXR1cm4gXCJcIi5jb25jYXQoZ2FwLCBcInB4XCIpO1xufSwgZnVuY3Rpb24gKF9yZWY1KSB7XG4gIHZhciBwYWdlID0gX3JlZjUucGFnZTtcbiAgcmV0dXJuIFwicmVwZWF0KFwiLmNvbmNhdChwYWdlLCBcIiwgMTAwJSlcIik7XG59LCBmdW5jdGlvbiAoX3JlZjYpIHtcbiAgdmFyIGN1cnJlbnRQYWdlID0gX3JlZjYuY3VycmVudFBhZ2UsXG4gICAgICBnYXAgPSBfcmVmNi5nYXA7XG4gIHJldHVybiBcInRyYW5zbGF0ZVgoY2FsYyhcIi5jb25jYXQoLTEwMCAqIGN1cnJlbnRQYWdlLCBcIiUgLSBcIikuY29uY2F0KGdhcCAqIGN1cnJlbnRQYWdlLCBcInB4KSlcIik7XG59LCBmdW5jdGlvbiAoX3JlZjcpIHtcbiAgdmFyIG1vYmlsZUJyZWFrcG9pbnQgPSBfcmVmNy5tb2JpbGVCcmVha3BvaW50O1xuICByZXR1cm4gbW9iaWxlQnJlYWtwb2ludDtcbn0sIGZ1bmN0aW9uIChfcmVmOCkge1xuICB2YXIgZ2FwID0gX3JlZjguZ2FwO1xuICByZXR1cm4gXCJcIi5jb25jYXQoZ2FwLCBcInB4XCIpO1xufSwgZnVuY3Rpb24gKF9yZWY5KSB7XG4gIHZhciBwYWdlID0gX3JlZjkucGFnZTtcbiAgcmV0dXJuIFwicmVwZWF0KFwiLmNvbmNhdChwYWdlLCBcIiwgOTAlKVwiKTtcbn0sIGZ1bmN0aW9uIChfcmVmMTApIHtcbiAgdmFyIGNvbHMgPSBfcmVmMTAuY29scyxcbiAgICAgIHJvd3MgPSBfcmVmMTAucm93cyxcbiAgICAgIGdhcCA9IF9yZWYxMC5nYXA7XG4gIHJldHVybiBcImNhbGMoXCIuY29uY2F0KChjb2xzICogcm93cyAtIDEpICogOTAsIFwiJSArIFwiKS5jb25jYXQoY29scyAqIHJvd3MgKiBnYXAsIFwicHgpXCIpO1xufSk7XG52YXIgSXRlbVNldCA9IHN0eWxlZC5kaXYud2l0aENvbmZpZyh7XG4gIGRpc3BsYXlOYW1lOiBcIkNhcm91c2VsX19JdGVtU2V0XCIsXG4gIGNvbXBvbmVudElkOiBcInNjLWh5aGVjdy0zXCJcbn0pKFtcImRpc3BsYXk6Z3JpZDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6XCIsIFwiO2dyaWQtdGVtcGxhdGUtcm93czpcIiwgXCI7Z3JpZC1nYXA6XCIsIFwiO0BtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6XCIsIFwicHgpe2dyaWQtdGVtcGxhdGUtY29sdW1uczpcIiwgXCI7Z3JpZC10ZW1wbGF0ZS1yb3dzOjFmcjsmOmxhc3Qtb2YtdHlwZSA+IFwiLCBcIjpsYXN0LW9mLXR5cGV7cGFkZGluZy1yaWdodDpcIiwgXCI7bWFyZ2luLXJpZ2h0OlwiLCBcIjt9fVwiXSwgZnVuY3Rpb24gKF9yZWYxMSkge1xuICB2YXIgY29scyA9IF9yZWYxMS5jb2xzO1xuICByZXR1cm4gXCJyZXBlYXQoXCIuY29uY2F0KGNvbHMsIFwiLCAxZnIpXCIpO1xufSwgZnVuY3Rpb24gKF9yZWYxMikge1xuICB2YXIgcm93cyA9IF9yZWYxMi5yb3dzO1xuICByZXR1cm4gXCJyZXBlYXQoXCIuY29uY2F0KHJvd3MsIFwiLCAxZnIpXCIpO1xufSwgZnVuY3Rpb24gKF9yZWYxMykge1xuICB2YXIgZ2FwID0gX3JlZjEzLmdhcDtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KGdhcCwgXCJweFwiKTtcbn0sIGZ1bmN0aW9uIChfcmVmMTQpIHtcbiAgdmFyIG1vYmlsZUJyZWFrcG9pbnQgPSBfcmVmMTQubW9iaWxlQnJlYWtwb2ludDtcbiAgcmV0dXJuIG1vYmlsZUJyZWFrcG9pbnQ7XG59LCBmdW5jdGlvbiAoX3JlZjE1KSB7XG4gIHZhciBjb2xzID0gX3JlZjE1LmNvbHMsXG4gICAgICByb3dzID0gX3JlZjE1LnJvd3M7XG4gIHJldHVybiBcInJlcGVhdChcIi5jb25jYXQoY29scyAqIHJvd3MsIFwiLCAxMDAlKVwiKTtcbn0sXG4vKiBzYy1zZWwgKi9cbkl0ZW0sIGZ1bmN0aW9uIChfcmVmMTYpIHtcbiAgdmFyIGdhcCA9IF9yZWYxNi5nYXA7XG4gIHJldHVybiBcIlwiLmNvbmNhdChnYXAsIFwicHhcIik7XG59LCBmdW5jdGlvbiAoX3JlZjE3KSB7XG4gIHZhciBnYXAgPSBfcmVmMTcuZ2FwO1xuICByZXR1cm4gXCItXCIuY29uY2F0KGdhcCwgXCJweFwiKTtcbn0pO1xudmFyIERvdHMgPSBzdHlsZWQuZGl2LndpdGhDb25maWcoe1xuICBkaXNwbGF5TmFtZTogXCJDYXJvdXNlbF9fRG90c1wiLFxuICBjb21wb25lbnRJZDogXCJzYy1oeWhlY3ctNFwiXG59KShbXCJwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7Ym90dG9tOi0xMnB4O2hlaWdodDoxMHB4O3dpZHRoOjEwMCU7bGluZS1oZWlnaHQ6MTBweDt0ZXh0LWFsaWduOmNlbnRlcjtAbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOlwiLCBcInB4KXtkaXNwbGF5Om5vbmU7fVwiXSwgZnVuY3Rpb24gKF9yZWYxOCkge1xuICB2YXIgbW9iaWxlQnJlYWtwb2ludCA9IF9yZWYxOC5tb2JpbGVCcmVha3BvaW50O1xuICByZXR1cm4gbW9iaWxlQnJlYWtwb2ludDtcbn0pO1xudmFyIEl0ZW0gPSBzdHlsZWQuZGl2LndpdGhDb25maWcoe1xuICBkaXNwbGF5TmFtZTogXCJDYXJvdXNlbF9fSXRlbVwiLFxuICBjb21wb25lbnRJZDogXCJzYy1oeWhlY3ctNVwiXG59KShbXCJzY3JvbGwtc25hcC1hbGlnbjpcIiwgXCI7XCJdLCBmdW5jdGlvbiAoX3JlZjE5KSB7XG4gIHZhciBzY3JvbGxTbmFwID0gX3JlZjE5LnNjcm9sbFNuYXA7XG4gIHJldHVybiBzY3JvbGxTbmFwID8gJ2NlbnRlcicgOiAnJztcbn0pO1xudmFyIENBUk9VU0VMX0lURU0gPSAnQ0FST1VTRUxfSVRFTSc7XG5cbnZhciBDYXJvdXNlbCA9IGZ1bmN0aW9uIENhcm91c2VsKF9yZWYyMCkge1xuICB2YXIgX3JlZjIwJGNvbHMgPSBfcmVmMjAuY29scyxcbiAgICAgIGNvbHNQcm9wID0gX3JlZjIwJGNvbHMgPT09IHZvaWQgMCA/IDEgOiBfcmVmMjAkY29scyxcbiAgICAgIF9yZWYyMCRyb3dzID0gX3JlZjIwLnJvd3MsXG4gICAgICByb3dzUHJvcCA9IF9yZWYyMCRyb3dzID09PSB2b2lkIDAgPyAxIDogX3JlZjIwJHJvd3MsXG4gICAgICBfcmVmMjAkZ2FwID0gX3JlZjIwLmdhcCxcbiAgICAgIGdhcFByb3AgPSBfcmVmMjAkZ2FwID09PSB2b2lkIDAgPyAxMCA6IF9yZWYyMCRnYXAsXG4gICAgICBfcmVmMjAkbG9vcCA9IF9yZWYyMC5sb29wLFxuICAgICAgbG9vcFByb3AgPSBfcmVmMjAkbG9vcCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMjAkbG9vcCxcbiAgICAgIF9yZWYyMCRzY3JvbGxTbmFwID0gX3JlZjIwLnNjcm9sbFNuYXAsXG4gICAgICBzY3JvbGxTbmFwID0gX3JlZjIwJHNjcm9sbFNuYXAgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMjAkc2Nyb2xsU25hcCxcbiAgICAgIF9yZWYyMCRoaWRlQXJyb3cgPSBfcmVmMjAuaGlkZUFycm93LFxuICAgICAgaGlkZUFycm93ID0gX3JlZjIwJGhpZGVBcnJvdyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMjAkaGlkZUFycm93LFxuICAgICAgX3JlZjIwJHNob3dEb3RzID0gX3JlZjIwLnNob3dEb3RzLFxuICAgICAgc2hvd0RvdHMgPSBfcmVmMjAkc2hvd0RvdHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIwJHNob3dEb3RzLFxuICAgICAgYXV0b3BsYXlQcm9wID0gX3JlZjIwLmF1dG9wbGF5LFxuICAgICAgX3JlZjIwJGRvdENvbG9yQWN0aXZlID0gX3JlZjIwLmRvdENvbG9yQWN0aXZlLFxuICAgICAgZG90Q29sb3JBY3RpdmUgPSBfcmVmMjAkZG90Q29sb3JBY3RpdmUgPT09IHZvaWQgMCA/ICcjNzk1NTQ4JyA6IF9yZWYyMCRkb3RDb2xvckFjdGl2ZSxcbiAgICAgIF9yZWYyMCRkb3RDb2xvckluYWN0aSA9IF9yZWYyMC5kb3RDb2xvckluYWN0aXZlLFxuICAgICAgZG90Q29sb3JJbmFjdGl2ZSA9IF9yZWYyMCRkb3RDb2xvckluYWN0aSA9PT0gdm9pZCAwID8gJyNjY2MnIDogX3JlZjIwJGRvdENvbG9ySW5hY3RpLFxuICAgICAgcmVzcG9uc2l2ZUxheW91dCA9IF9yZWYyMC5yZXNwb25zaXZlTGF5b3V0LFxuICAgICAgX3JlZjIwJG1vYmlsZUJyZWFrcG9pID0gX3JlZjIwLm1vYmlsZUJyZWFrcG9pbnQsXG4gICAgICBtb2JpbGVCcmVha3BvaW50ID0gX3JlZjIwJG1vYmlsZUJyZWFrcG9pID09PSB2b2lkIDAgPyA3NjcgOiBfcmVmMjAkbW9iaWxlQnJlYWtwb2ksXG4gICAgICBhcnJvd0xlZnQgPSBfcmVmMjAuYXJyb3dMZWZ0LFxuICAgICAgYXJyb3dSaWdodCA9IF9yZWYyMC5hcnJvd1JpZ2h0LFxuICAgICAgZG90ID0gX3JlZjIwLmRvdCxcbiAgICAgIF9yZWYyMCRjb250YWluZXJDbGFzcyA9IF9yZWYyMC5jb250YWluZXJDbGFzc05hbWUsXG4gICAgICBjb250YWluZXJDbGFzc05hbWUgPSBfcmVmMjAkY29udGFpbmVyQ2xhc3MgPT09IHZvaWQgMCA/ICcnIDogX3JlZjIwJGNvbnRhaW5lckNsYXNzLFxuICAgICAgX3JlZjIwJGNvbnRhaW5lclN0eWxlID0gX3JlZjIwLmNvbnRhaW5lclN0eWxlLFxuICAgICAgY29udGFpbmVyU3R5bGUgPSBfcmVmMjAkY29udGFpbmVyU3R5bGUgPT09IHZvaWQgMCA/IHt9IDogX3JlZjIwJGNvbnRhaW5lclN0eWxlLFxuICAgICAgY2hpbGRyZW4gPSBfcmVmMjAuY2hpbGRyZW47XG5cbiAgdmFyIF91c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKDApLFxuICAgICAgX3VzZVN0YXRlMiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZSwgMiksXG4gICAgICBjdXJyZW50UGFnZSA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRDdXJyZW50UGFnZSA9IF91c2VTdGF0ZTJbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTMgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMiksXG4gICAgICBpc0hvdmVyID0gX3VzZVN0YXRlNFswXSxcbiAgICAgIHNldElzSG92ZXIgPSBfdXNlU3RhdGU0WzFdO1xuXG4gIHZhciBfdXNlU3RhdGU1ID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX3VzZVN0YXRlNiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTUsIDIpLFxuICAgICAgaXNUb3VjaCA9IF91c2VTdGF0ZTZbMF0sXG4gICAgICBzZXRJc1RvdWNoID0gX3VzZVN0YXRlNlsxXTtcblxuICB2YXIgX3VzZVN0YXRlNyA9IFJlYWN0LnVzZVN0YXRlKGNvbHNQcm9wKSxcbiAgICAgIF91c2VTdGF0ZTggPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGU3LCAyKSxcbiAgICAgIGNvbHMgPSBfdXNlU3RhdGU4WzBdLFxuICAgICAgc2V0Q29scyA9IF91c2VTdGF0ZThbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTkgPSBSZWFjdC51c2VTdGF0ZShyb3dzUHJvcCksXG4gICAgICBfdXNlU3RhdGUxMCA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTksIDIpLFxuICAgICAgcm93cyA9IF91c2VTdGF0ZTEwWzBdLFxuICAgICAgc2V0Um93cyA9IF91c2VTdGF0ZTEwWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUxMSA9IFJlYWN0LnVzZVN0YXRlKDApLFxuICAgICAgX3VzZVN0YXRlMTIgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUxMSwgMiksXG4gICAgICBnYXAgPSBfdXNlU3RhdGUxMlswXSxcbiAgICAgIHNldEdhcCA9IF91c2VTdGF0ZTEyWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUxMyA9IFJlYWN0LnVzZVN0YXRlKGxvb3BQcm9wKSxcbiAgICAgIF91c2VTdGF0ZTE0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMTMsIDIpLFxuICAgICAgbG9vcCA9IF91c2VTdGF0ZTE0WzBdLFxuICAgICAgc2V0TG9vcCA9IF91c2VTdGF0ZTE0WzFdO1xuXG4gIHZhciBfdXNlU3RhdGUxNSA9IFJlYWN0LnVzZVN0YXRlKGF1dG9wbGF5UHJvcCksXG4gICAgICBfdXNlU3RhdGUxNiA9IF9zbGljZWRUb0FycmF5KF91c2VTdGF0ZTE1LCAyKSxcbiAgICAgIGF1dG9wbGF5ID0gX3VzZVN0YXRlMTZbMF0sXG4gICAgICBzZXRBdXRvcGxheSA9IF91c2VTdGF0ZTE2WzFdO1xuXG4gIHZhciBfdXNlU3RhdGUxNyA9IFJlYWN0LnVzZVN0YXRlKDApLFxuICAgICAgX3VzZVN0YXRlMTggPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUxNywgMiksXG4gICAgICByYWlsV3JhcHBlcldpZHRoID0gX3VzZVN0YXRlMThbMF0sXG4gICAgICBzZXRSYWlsV3JhcHBlcldpZHRoID0gX3VzZVN0YXRlMThbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTE5ID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgX3VzZVN0YXRlMjAgPSBfc2xpY2VkVG9BcnJheShfdXNlU3RhdGUxOSwgMiksXG4gICAgICBoYXNTZXRSZXNpemVIYW5kbGVyID0gX3VzZVN0YXRlMjBbMF0sXG4gICAgICBzZXRIYXNTZXRSZXNpemVIYW5kbGVyID0gX3VzZVN0YXRlMjBbMV07XG5cbiAgdmFyIHJhaWxXcmFwcGVyUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB2YXIgYXV0b3BsYXlJbnRlcnZhbFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdmFyIGJyZWFrcG9pbnRTZXR0aW5nID0gdXNlUmVzcG9uc2l2ZUxheW91dChyZXNwb25zaXZlTGF5b3V0KTtcbiAgdmFyIHJhbmRvbUtleSA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChNYXRoLnJhbmRvbSgpLCBcIi1cIikuY29uY2F0KE1hdGgucmFuZG9tKCkpO1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc21vb3Roc2Nyb2xsLnBvbHlmaWxsKCk7XG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIxID0gYnJlYWtwb2ludFNldHRpbmcgfHwge30sXG4gICAgICAgIGNvbHMgPSBfcmVmMjEuY29scyxcbiAgICAgICAgcm93cyA9IF9yZWYyMS5yb3dzLFxuICAgICAgICBnYXAgPSBfcmVmMjEuZ2FwLFxuICAgICAgICBsb29wID0gX3JlZjIxLmxvb3AsXG4gICAgICAgIGF1dG9wbGF5ID0gX3JlZjIxLmF1dG9wbGF5O1xuXG4gICAgc2V0Q29scyhjb2xzIHx8IGNvbHNQcm9wKTtcbiAgICBzZXRSb3dzKHJvd3MgfHwgcm93c1Byb3ApO1xuICAgIHNldEdhcChwYXJzZUdhcChnYXAgfHwgZ2FwUHJvcCkpO1xuICAgIHNldExvb3AobG9vcCB8fCBsb29wUHJvcCk7XG4gICAgc2V0QXV0b3BsYXkoYXV0b3BsYXkgfHwgYXV0b3BsYXlQcm9wKTtcbiAgICBzZXRDdXJyZW50UGFnZSgwKTtcbiAgfSwgW2JyZWFrcG9pbnRTZXR0aW5nLCBjb2xzUHJvcCwgcm93c1Byb3AsIGdhcFByb3AsIGxvb3BQcm9wLCBhdXRvcGxheVByb3AsIHBhcnNlR2FwXSk7XG4gIHZhciBoYW5kbGVSYWlsV3JhcHBlclJlc2l6ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICByYWlsV3JhcHBlclJlZi5jdXJyZW50ICYmIHNldFJhaWxXcmFwcGVyV2lkdGgocmFpbFdyYXBwZXJSZWYuY3VycmVudC5vZmZzZXRXaWR0aCk7XG4gIH0sIFtyYWlsV3JhcHBlclJlZl0pO1xuICB2YXIgc2V0UmVzaXplSGFuZGxlciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBhZGRSZXNpemVIYW5kbGVyKFwiZ2FwQ2FsY3VsYXRvci1cIi5jb25jYXQocmFuZG9tS2V5KSwgaGFuZGxlUmFpbFdyYXBwZXJSZXNpemUpO1xuICAgIHNldEhhc1NldFJlc2l6ZUhhbmRsZXIodHJ1ZSk7XG4gIH0sIFtyYW5kb21LZXksIGhhbmRsZVJhaWxXcmFwcGVyUmVzaXplXSk7XG4gIHZhciBybVJlc2l6ZUhhbmRsZXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmVtb3ZlUmVzaXplSGFuZGxlcihcImdhcENhbGN1bGF0b3ItXCIuY29uY2F0KHJhbmRvbUtleSkpO1xuICAgIHNldEhhc1NldFJlc2l6ZUhhbmRsZXIoZmFsc2UpO1xuICB9LCBbcmFuZG9tS2V5XSk7XG4gIHZhciBwYXJzZUdhcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChnYXApIHtcbiAgICB2YXIgcGFyc2VkID0gZ2FwO1xuICAgIHZhciBzaG91bGRTZXRSZXNpemVIYW5kbGVyID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIGdhcCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHN3aXRjaCAoL1xcRCokLy5leGVjKGdhcClbMF0pIHtcbiAgICAgICAgY2FzZSAncHgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhcnNlZCA9ICtnYXAucmVwbGFjZSgncHgnLCAnJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXJXaWR0aCA9IHJhaWxXcmFwcGVyV2lkdGggfHwgcmFpbFdyYXBwZXJSZWYuY3VycmVudCA/IHJhaWxXcmFwcGVyUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGggOiAwO1xuICAgICAgICAgICAgcGFyc2VkID0gd3JhcHBlcldpZHRoICogZ2FwLnJlcGxhY2UoJyUnLCAnJykgLyAxMDA7XG4gICAgICAgICAgICBzaG91bGRTZXRSZXNpemVIYW5kbGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHBhcnNlZCA9IDA7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRG9lc24ndCBzdXBwb3J0IHRoZSBwcm92aWRlZCBtZWFzdXJlbWVudCB1bml0OiBcIi5jb25jYXQoZ2FwKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNob3VsZFNldFJlc2l6ZUhhbmRsZXIgJiYgIWhhc1NldFJlc2l6ZUhhbmRsZXIgJiYgc2V0UmVzaXplSGFuZGxlcigpO1xuICAgICFzaG91bGRTZXRSZXNpemVIYW5kbGVyICYmIGhhc1NldFJlc2l6ZUhhbmRsZXIgJiYgcm1SZXNpemVIYW5kbGVyKCk7XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfSwgW3JhaWxXcmFwcGVyV2lkdGgsIHJhaWxXcmFwcGVyUmVmLCBoYXNTZXRSZXNpemVIYW5kbGVyLCBzZXRSZXNpemVIYW5kbGVyLCBybVJlc2l6ZUhhbmRsZXJdKTtcbiAgdmFyIGl0ZW1MaXN0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZC50eXBlLmRpc3BsYXlOYW1lID09PSBDQVJPVVNFTF9JVEVNO1xuICAgIH0pO1xuICB9LCBbY2hpbGRyZW5dKTtcbiAgdmFyIGl0ZW1BbW91bnRQZXJTZXQgPSBjb2xzICogcm93cztcbiAgdmFyIGl0ZW1TZXRMaXN0ID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGl0ZW1MaXN0LnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBpdGVtLCBpKSB7XG4gICAgICB2YXIgaXRlbUNvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEl0ZW0sIHtcbiAgICAgICAga2V5OiBpLFxuICAgICAgICBzY3JvbGxTbmFwOiBzY3JvbGxTbmFwXG4gICAgICB9LCBpdGVtKTtcblxuICAgICAgaWYgKGkgJSBpdGVtQW1vdW50UGVyU2V0ID09PSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtpdGVtQ29tcG9uZW50XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnB1c2goaXRlbUNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9LCBbaXRlbUxpc3QsIGl0ZW1BbW91bnRQZXJTZXQsIHNjcm9sbFNuYXBdKTtcbiAgdmFyIHBhZ2UgPSBNYXRoLmNlaWwoaXRlbUxpc3QubGVuZ3RoIC8gaXRlbUFtb3VudFBlclNldCk7XG4gIHZhciBoYW5kbGVQcmV2ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHNldEN1cnJlbnRQYWdlKGZ1bmN0aW9uIChwKSB7XG4gICAgICB2YXIgcHJldlBhZ2UgPSBwIC0gMTtcblxuICAgICAgaWYgKGxvb3AgJiYgcHJldlBhZ2UgPCAwKSB7XG4gICAgICAgIHJldHVybiBwYWdlIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZQYWdlO1xuICAgIH0pO1xuICB9LCBbbG9vcCwgcGFnZV0pO1xuICB2YXIgaGFuZGxlTmV4dCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNNb2JpbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHZhciByYWlsV3JhcHBlciA9IHJhaWxXcmFwcGVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoaXNNb2JpbGUgJiYgcmFpbFdyYXBwZXIpIHtcbiAgICAgIGlmICghc2Nyb2xsU25hcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gcmFpbFdyYXBwZXIuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBvZmZzZXRXaWR0aCA9IHJhaWxXcmFwcGVyLm9mZnNldFdpZHRoLFxuICAgICAgICAgIHNjcm9sbFdpZHRoID0gcmFpbFdyYXBwZXIuc2Nyb2xsV2lkdGg7XG4gICAgICByYWlsV3JhcHBlci5zY3JvbGxCeSh7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogbG9vcCAmJiBzY3JvbGxMZWZ0ICsgb2Zmc2V0V2lkdGggPj0gc2Nyb2xsV2lkdGggPyAtc2Nyb2xsTGVmdCA6IHNjcm9sbExlZnQgPT09IDAgPyBnYXAgKyAob2Zmc2V0V2lkdGggLSBnYXApICogMC45IC0gKG9mZnNldFdpZHRoICogMC4xIC0gZ2FwICogMS4xKSAvIDIgOiAob2Zmc2V0V2lkdGggLSBnYXApICogMC45ICsgZ2FwLFxuICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRDdXJyZW50UGFnZShmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgbmV4dFBhZ2UgPSBwICsgMTtcblxuICAgICAgICBpZiAobmV4dFBhZ2UgPj0gcGFnZSkge1xuICAgICAgICAgIHJldHVybiBsb29wID8gMCA6IHA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dFBhZ2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtsb29wLCBwYWdlLCBnYXAsIHJhaWxXcmFwcGVyUmVmLCBzY3JvbGxTbmFwXSk7XG4gIHZhciBzdGFydEF1dG9wbGF5SW50ZXJ2YWwgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGF1dG9wbGF5SW50ZXJ2YWxSZWYuY3VycmVudCA9PT0gbnVsbCAmJiB0eXBlb2YgYXV0b3BsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBhdXRvcGxheUludGVydmFsUmVmLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhbmRsZU5leHQod2luZG93LmlubmVyV2lkdGggPD0gbW9iaWxlQnJlYWtwb2ludCk7XG4gICAgICB9LCBhdXRvcGxheSk7XG4gICAgfVxuICB9LCBbYXV0b3BsYXksIGF1dG9wbGF5SW50ZXJ2YWxSZWYsIGhhbmRsZU5leHQsIG1vYmlsZUJyZWFrcG9pbnRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzdGFydEF1dG9wbGF5SW50ZXJ2YWwoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGF1dG9wbGF5SW50ZXJ2YWxSZWYuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGF1dG9wbGF5SW50ZXJ2YWxSZWYuY3VycmVudCk7XG4gICAgICAgIGF1dG9wbGF5SW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW3N0YXJ0QXV0b3BsYXlJbnRlcnZhbCwgYXV0b3BsYXlJbnRlcnZhbFJlZl0pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0hvdmVyIHx8IGlzVG91Y2gpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b3BsYXlJbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgIGF1dG9wbGF5SW50ZXJ2YWxSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0QXV0b3BsYXlJbnRlcnZhbCgpO1xuICAgIH1cbiAgfSwgW2lzSG92ZXIsIGlzVG91Y2gsIGF1dG9wbGF5SW50ZXJ2YWxSZWYsIHN0YXJ0QXV0b3BsYXlJbnRlcnZhbF0pO1xuICB2YXIgdHVyblRvUGFnZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChwYWdlKSB7XG4gICAgc2V0Q3VycmVudFBhZ2UocGFnZSk7XG4gIH0sIFtdKTtcbiAgdmFyIGhhbmRsZUhvdmVyID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHNldElzSG92ZXIoZnVuY3Rpb24gKGhvdmVyKSB7XG4gICAgICByZXR1cm4gIWhvdmVyO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHZhciBoYW5kbGVUb3VjaCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICBzZXRJc1RvdWNoKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuICF0b3VjaDtcbiAgICB9KTtcbiAgfSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLCB7XG4gICAgb25Nb3VzZUVudGVyOiBoYW5kbGVIb3ZlcixcbiAgICBvbk1vdXNlTGVhdmU6IGhhbmRsZUhvdmVyLFxuICAgIG9uVG91Y2hTdGFydDogaGFuZGxlVG91Y2gsXG4gICAgb25Ub3VjaEVuZDogaGFuZGxlVG91Y2gsXG4gICAgY2xhc3NOYW1lOiBjb250YWluZXJDbGFzc05hbWUsXG4gICAgc3R5bGU6IGNvbnRhaW5lclN0eWxlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFycm93QnV0dG9uLCB7XG4gICAgdHlwZTogXCJwcmV2XCIsXG4gICAgbW9iaWxlQnJlYWtwb2ludDogbW9iaWxlQnJlYWtwb2ludCxcbiAgICBoaWRkZW46IGhpZGVBcnJvdyB8fCAhbG9vcCAmJiBjdXJyZW50UGFnZSA8PSAwLFxuICAgIEN1c3RvbUJ0bjogYXJyb3dMZWZ0LFxuICAgIG9uQ2xpY2s6IGhhbmRsZVByZXZcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJhaWxXcmFwcGVyLCB7XG4gICAgbW9iaWxlQnJlYWtwb2ludDogbW9iaWxlQnJlYWtwb2ludCxcbiAgICBzY3JvbGxTbmFwOiBzY3JvbGxTbmFwLFxuICAgIHNob3dEb3RzOiBzaG93RG90cyxcbiAgICByZWY6IHJhaWxXcmFwcGVyUmVmXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJhaWwsIHtcbiAgICBjb2xzOiBjb2xzLFxuICAgIHJvd3M6IHJvd3MsXG4gICAgcGFnZTogcGFnZSxcbiAgICBnYXA6IGdhcCxcbiAgICBjdXJyZW50UGFnZTogY3VycmVudFBhZ2UsXG4gICAgbW9iaWxlQnJlYWtwb2ludDogbW9iaWxlQnJlYWtwb2ludFxuICB9LCBpdGVtU2V0TGlzdC5tYXAoZnVuY3Rpb24gKHNldCwgaSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChJdGVtU2V0LCB7XG4gICAgICBrZXk6IGksXG4gICAgICBjb2xzOiBjb2xzLFxuICAgICAgcm93czogcm93cyxcbiAgICAgIGdhcDogZ2FwLFxuICAgICAgbW9iaWxlQnJlYWtwb2ludDogbW9iaWxlQnJlYWtwb2ludFxuICAgIH0sIHNldCk7XG4gIH0pKSksIHNob3dEb3RzICYmIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERvdHMsIHtcbiAgICBtb2JpbGVCcmVha3BvaW50OiBtb2JpbGVCcmVha3BvaW50XG4gIH0sIF90b0NvbnN1bWFibGVBcnJheShBcnJheShwYWdlKSkubWFwKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KERvdCwge1xuICAgICAga2V5OiBpLFxuICAgICAgaW5kZXg6IGksXG4gICAgICBpc0FjdGl2ZTogaSA9PT0gY3VycmVudFBhZ2UsXG4gICAgICBkb3RDb2xvckluYWN0aXZlOiBkb3RDb2xvckluYWN0aXZlLFxuICAgICAgZG90Q29sb3JBY3RpdmU6IGRvdENvbG9yQWN0aXZlLFxuICAgICAgZG90OiBkb3QsXG4gICAgICBvbkNsaWNrOiB0dXJuVG9QYWdlXG4gICAgfSk7XG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQXJyb3dCdXR0b24sIHtcbiAgICB0eXBlOiBcIm5leHRcIixcbiAgICBtb2JpbGVCcmVha3BvaW50OiBtb2JpbGVCcmVha3BvaW50LFxuICAgIGhpZGRlbjogaGlkZUFycm93IHx8ICFsb29wICYmIGN1cnJlbnRQYWdlID09PSBwYWdlIC0gMSxcbiAgICBDdXN0b21CdG46IGFycm93UmlnaHQsXG4gICAgb25DbGljazogaGFuZGxlTmV4dC5iaW5kKG51bGwsIGZhbHNlKVxuICB9KSk7XG59O1xuXG5DYXJvdXNlbC5JdGVtID0gZnVuY3Rpb24gKF9yZWYyMikge1xuICB2YXIgY2hpbGRyZW4gPSBfcmVmMjIuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbjtcbn07XG5cbkNhcm91c2VsLkl0ZW0uZGlzcGxheU5hbWUgPSBDQVJPVVNFTF9JVEVNO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhcm91c2VsO1xuIl0sIm5hbWVzIjpbIl9pbnRlcm9wRGVmYXVsdCIsImV4IiwiUmVhY3QiLCJyZXF1aXJlIiwiUmVhY3RfX2RlZmF1bHQiLCJzdHlsZWQiLCJQcm9wVHlwZXMiLCJzbW9vdGhzY3JvbGwiLCJkZWJvdW5jZSIsIl90eXBlb2YiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJpIiwiX2FycmF5V2l0aEhvbGVzIiwiX2l0ZXJhYmxlVG9BcnJheUxpbWl0IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlUmVzdCIsIl90b0NvbnN1bWFibGVBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9pdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVTcHJlYWQiLCJBcnJheSIsImlzQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIml0ZXIiLCJmcm9tIiwiX2kiLCJfYXJyIiwiX24iLCJfZCIsIl9zIiwiX2UiLCJjYWxsIiwibmV4dCIsImRvbmUiLCJwdXNoIiwidmFsdWUiLCJsZW5ndGgiLCJlcnIiLCJvIiwibWluTGVuIiwibiIsIk9iamVjdCIsInRvU3RyaW5nIiwic2xpY2UiLCJuYW1lIiwidGVzdCIsImxlbiIsImFycjIiLCJUeXBlRXJyb3IiLCJCdXR0b25XcmFwcGVyIiwiZGl2Iiwid2l0aENvbmZpZyIsImRpc3BsYXlOYW1lIiwiY29tcG9uZW50SWQiLCJfcmVmIiwibW9iaWxlQnJlYWtwb2ludCIsIkJ1dHRvbiIsInNwYW4iLCJfcmVmMiIsInR5cGUiLCJfcmVmMyIsIl9yZWY0IiwiQXJyb3dCdXR0b24iLCJfcmVmNSIsIl9yZWY1JG1vYmlsZUJyZWFrcG9pbiIsIl9yZWY1JGhpZGRlbiIsImhpZGRlbiIsIkN1c3RvbUJ0biIsIm9uQ2xpY2siLCJjcmVhdGVFbGVtZW50IiwicHJvcFR5cGVzIiwib25lT2YiLCJpc1JlcXVpcmVkIiwibnVtYmVyIiwiYm9vbCIsIm9uZU9mVHlwZSIsIm5vZGUiLCJlbGVtZW50IiwiZWxlbWVudFR5cGUiLCJmdW5jIiwiRG90V3JhcHBlciIsIkRvdERlZmF1bHQiLCJjb2xvciIsIkRvdCIsImluZGV4IiwiX3JlZjIkaXNBY3RpdmUiLCJpc0FjdGl2ZSIsImRvdENvbG9ySW5hY3RpdmUiLCJkb3RDb2xvckFjdGl2ZSIsIkRvdEN1c3RvbSIsImRvdCIsImhhbmRsZUNsaWNrIiwidXNlQ2FsbGJhY2siLCJzdHJpbmciLCJIQU5ETEVSX05BTUVfU1BBQ0UiLCJoYW5kbGVSZXNpemUiLCJlIiwidmFsdWVzIiwid2luZG93IiwiZm9yRWFjaCIsImhhbmRsZXIiLCJzZXR1cExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZFJlc2l6ZUhhbmRsZXIiLCJrZXkiLCJyZW1vdmVSZXNpemVIYW5kbGVyIiwia2V5cyIsInVzZVJlc3BvbnNpdmVMYXlvdXQiLCJicmVha3BvaW50TGlzdCIsImFyZ3VtZW50cyIsInVuZGVmaW5lZCIsIl91c2VTdGF0ZSIsInVzZVN0YXRlIiwiX3VzZVN0YXRlMiIsImN1cnJlbnRCcmVha3BvaW50U2V0dGluZyIsInNldEN1cnJlbnRCcmVha3BvaW50U2V0dGluZyIsInJhbmRvbSIsInVzZU1lbW8iLCJjb25jYXQiLCJNYXRoIiwic29ydGVkQnJlYWtwb2ludExpc3QiLCJzb3J0IiwiYSIsImIiLCJicmVha3BvaW50Iiwid2luZG93V2lkdGgiLCJpbm5lcldpZHRoIiwibWF0Y2hlZFNldHRpbmciLCJmaW5kIiwic2V0dGluZyIsInVzZUVmZmVjdCIsIkNvbnRhaW5lciIsIlJhaWxXcmFwcGVyIiwic2hvd0RvdHMiLCJzY3JvbGxTbmFwIiwiUmFpbCIsImdhcCIsInBhZ2UiLCJfcmVmNiIsImN1cnJlbnRQYWdlIiwiX3JlZjciLCJfcmVmOCIsIl9yZWY5IiwiX3JlZjEwIiwiY29scyIsInJvd3MiLCJJdGVtU2V0IiwiX3JlZjExIiwiX3JlZjEyIiwiX3JlZjEzIiwiX3JlZjE0IiwiX3JlZjE1IiwiSXRlbSIsIl9yZWYxNiIsIl9yZWYxNyIsIkRvdHMiLCJfcmVmMTgiLCJfcmVmMTkiLCJDQVJPVVNFTF9JVEVNIiwiQ2Fyb3VzZWwiLCJfcmVmMjAiLCJfcmVmMjAkY29scyIsImNvbHNQcm9wIiwiX3JlZjIwJHJvd3MiLCJyb3dzUHJvcCIsIl9yZWYyMCRnYXAiLCJnYXBQcm9wIiwiX3JlZjIwJGxvb3AiLCJsb29wIiwibG9vcFByb3AiLCJfcmVmMjAkc2Nyb2xsU25hcCIsIl9yZWYyMCRoaWRlQXJyb3ciLCJoaWRlQXJyb3ciLCJfcmVmMjAkc2hvd0RvdHMiLCJhdXRvcGxheVByb3AiLCJhdXRvcGxheSIsIl9yZWYyMCRkb3RDb2xvckFjdGl2ZSIsIl9yZWYyMCRkb3RDb2xvckluYWN0aSIsInJlc3BvbnNpdmVMYXlvdXQiLCJfcmVmMjAkbW9iaWxlQnJlYWtwb2kiLCJhcnJvd0xlZnQiLCJhcnJvd1JpZ2h0IiwiX3JlZjIwJGNvbnRhaW5lckNsYXNzIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwiX3JlZjIwJGNvbnRhaW5lclN0eWxlIiwiY29udGFpbmVyU3R5bGUiLCJjaGlsZHJlbiIsInNldEN1cnJlbnRQYWdlIiwiX3VzZVN0YXRlMyIsIl91c2VTdGF0ZTQiLCJpc0hvdmVyIiwic2V0SXNIb3ZlciIsIl91c2VTdGF0ZTUiLCJfdXNlU3RhdGU2IiwiaXNUb3VjaCIsInNldElzVG91Y2giLCJfdXNlU3RhdGU3IiwiX3VzZVN0YXRlOCIsInNldENvbHMiLCJfdXNlU3RhdGU5IiwiX3VzZVN0YXRlMTAiLCJzZXRSb3dzIiwiX3VzZVN0YXRlMTEiLCJfdXNlU3RhdGUxMiIsInNldEdhcCIsIl91c2VTdGF0ZTEzIiwiX3VzZVN0YXRlMTQiLCJzZXRMb29wIiwiX3VzZVN0YXRlMTUiLCJfdXNlU3RhdGUxNiIsInNldEF1dG9wbGF5IiwiX3VzZVN0YXRlMTciLCJfdXNlU3RhdGUxOCIsInJhaWxXcmFwcGVyV2lkdGgiLCJzZXRSYWlsV3JhcHBlcldpZHRoIiwiX3VzZVN0YXRlMTkiLCJfdXNlU3RhdGUyMCIsImhhc1NldFJlc2l6ZUhhbmRsZXIiLCJzZXRIYXNTZXRSZXNpemVIYW5kbGVyIiwicmFpbFdyYXBwZXJSZWYiLCJ1c2VSZWYiLCJhdXRvcGxheUludGVydmFsUmVmIiwiYnJlYWtwb2ludFNldHRpbmciLCJyYW5kb21LZXkiLCJwb2x5ZmlsbCIsIl9yZWYyMSIsInBhcnNlR2FwIiwiaGFuZGxlUmFpbFdyYXBwZXJSZXNpemUiLCJjdXJyZW50Iiwib2Zmc2V0V2lkdGgiLCJzZXRSZXNpemVIYW5kbGVyIiwicm1SZXNpemVIYW5kbGVyIiwicGFyc2VkIiwic2hvdWxkU2V0UmVzaXplSGFuZGxlciIsImV4ZWMiLCJyZXBsYWNlIiwid3JhcHBlcldpZHRoIiwiY29uc29sZSIsImVycm9yIiwiaXRlbUxpc3QiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJmaWx0ZXIiLCJjaGlsZCIsIml0ZW1BbW91bnRQZXJTZXQiLCJpdGVtU2V0TGlzdCIsInJlZHVjZSIsInJlc3VsdCIsIml0ZW0iLCJpdGVtQ29tcG9uZW50IiwiY2VpbCIsImhhbmRsZVByZXYiLCJwIiwicHJldlBhZ2UiLCJoYW5kbGVOZXh0IiwiaXNNb2JpbGUiLCJyYWlsV3JhcHBlciIsInNjcm9sbExlZnQiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEJ5IiwidG9wIiwibGVmdCIsImJlaGF2aW9yIiwibmV4dFBhZ2UiLCJzdGFydEF1dG9wbGF5SW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ0dXJuVG9QYWdlIiwiaGFuZGxlSG92ZXIiLCJob3ZlciIsImhhbmRsZVRvdWNoIiwidG91Y2giLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJvblRvdWNoU3RhcnQiLCJvblRvdWNoRW5kIiwiY2xhc3NOYW1lIiwic3R5bGUiLCJyZWYiLCJtYXAiLCJzZXQiLCJfIiwiYmluZCIsIl9yZWYyMiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/dist/bundle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/better-react-carousel/node_modules/@emotion/unitless/dist/unitless.esm.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/better-react-carousel/node_modules/@emotion/unitless/dist/unitless.esm.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar unitlessKeys = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unitlessKeys);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9AZW1vdGlvbi91bml0bGVzcy9kaXN0L3VuaXRsZXNzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsZUFBZTtJQUNqQkMseUJBQXlCO0lBQ3pCQyxtQkFBbUI7SUFDbkJDLGtCQUFrQjtJQUNsQkMsa0JBQWtCO0lBQ2xCQyxTQUFTO0lBQ1RDLGNBQWM7SUFDZEMsaUJBQWlCO0lBQ2pCQyxhQUFhO0lBQ2JDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZDLGNBQWM7SUFDZEMsWUFBWTtJQUNaQyxjQUFjO0lBQ2RDLFdBQVc7SUFDWEMsU0FBUztJQUNUQyxZQUFZO0lBQ1pDLGFBQWE7SUFDYkMsY0FBYztJQUNkQyxZQUFZO0lBQ1pDLGVBQWU7SUFDZkMsZ0JBQWdCO0lBQ2hCQyxpQkFBaUI7SUFDakJDLFdBQVc7SUFDWEMsZUFBZTtJQUNmQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsWUFBWTtJQUNaQyxZQUFZO0lBQ1pDLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxTQUFTO0lBQ1RDLFNBQVM7SUFDVEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsaUJBQWlCO0lBQ2pCLHlCQUF5QjtJQUN6QkMsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLGFBQWE7SUFDYkMsaUJBQWlCO0lBQ2pCQyxrQkFBa0I7SUFDbEJDLGtCQUFrQjtJQUNsQkMsZUFBZTtJQUNmQyxhQUFhO0FBQ2Y7QUFFQSxpRUFBZTdDLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2RlX2N1YmljbGVfMy8uL25vZGVfbW9kdWxlcy9iZXR0ZXItcmVhY3QtY2Fyb3VzZWwvbm9kZV9tb2R1bGVzL0BlbW90aW9uL3VuaXRsZXNzL2Rpc3QvdW5pdGxlc3MuZXNtLmpzPzg0NDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHVuaXRsZXNzS2V5cyA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IDEsXG4gIGJvcmRlckltYWdlT3V0c2V0OiAxLFxuICBib3JkZXJJbWFnZVNsaWNlOiAxLFxuICBib3JkZXJJbWFnZVdpZHRoOiAxLFxuICBib3hGbGV4OiAxLFxuICBib3hGbGV4R3JvdXA6IDEsXG4gIGJveE9yZGluYWxHcm91cDogMSxcbiAgY29sdW1uQ291bnQ6IDEsXG4gIGNvbHVtbnM6IDEsXG4gIGZsZXg6IDEsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4UG9zaXRpdmU6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIGZsZXhOZWdhdGl2ZTogMSxcbiAgZmxleE9yZGVyOiAxLFxuICBncmlkUm93OiAxLFxuICBncmlkUm93RW5kOiAxLFxuICBncmlkUm93U3BhbjogMSxcbiAgZ3JpZFJvd1N0YXJ0OiAxLFxuICBncmlkQ29sdW1uOiAxLFxuICBncmlkQ29sdW1uRW5kOiAxLFxuICBncmlkQ29sdW1uU3BhbjogMSxcbiAgZ3JpZENvbHVtblN0YXJ0OiAxLFxuICBtc0dyaWRSb3c6IDEsXG4gIG1zR3JpZFJvd1NwYW46IDEsXG4gIG1zR3JpZENvbHVtbjogMSxcbiAgbXNHcmlkQ29sdW1uU3BhbjogMSxcbiAgZm9udFdlaWdodDogMSxcbiAgbGluZUhlaWdodDogMSxcbiAgb3BhY2l0eTogMSxcbiAgb3JkZXI6IDEsXG4gIG9ycGhhbnM6IDEsXG4gIHRhYlNpemU6IDEsXG4gIHdpZG93czogMSxcbiAgekluZGV4OiAxLFxuICB6b29tOiAxLFxuICBXZWJraXRMaW5lQ2xhbXA6IDEsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIGZsb29kT3BhY2l0eTogMSxcbiAgc3RvcE9wYWNpdHk6IDEsXG4gIHN0cm9rZURhc2hhcnJheTogMSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogMSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMSxcbiAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVuaXRsZXNzS2V5cztcbiJdLCJuYW1lcyI6WyJ1bml0bGVzc0tleXMiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJjb2x1bW5zIiwiZmxleCIsImZsZXhHcm93IiwiZmxleFBvc2l0aXZlIiwiZmxleFNocmluayIsImZsZXhOZWdhdGl2ZSIsImZsZXhPcmRlciIsImdyaWRSb3ciLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uIiwiZ3JpZENvbHVtbkVuZCIsImdyaWRDb2x1bW5TcGFuIiwiZ3JpZENvbHVtblN0YXJ0IiwibXNHcmlkUm93IiwibXNHcmlkUm93U3BhbiIsIm1zR3JpZENvbHVtbiIsIm1zR3JpZENvbHVtblNwYW4iLCJmb250V2VpZ2h0IiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsIldlYmtpdExpbmVDbGFtcCIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/node_modules/@emotion/unitless/dist/unitless.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/better-react-carousel/node_modules/styled-components/dist/styled-components.esm.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/better-react-carousel/node_modules/styled-components/dist/styled-components.esm.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServerStyleSheet: () => (/* binding */ ServerStyleSheet),\n/* harmony export */   StyleSheetConsumer: () => (/* binding */ StyleSheetConsumer),\n/* harmony export */   StyleSheetContext: () => (/* binding */ StyleSheetContext),\n/* harmony export */   StyleSheetManager: () => (/* binding */ StyleSheetManager),\n/* harmony export */   ThemeConsumer: () => (/* binding */ ThemeConsumer),\n/* harmony export */   ThemeContext: () => (/* binding */ ThemeContext),\n/* harmony export */   ThemeProvider: () => (/* binding */ ThemeProvider),\n/* harmony export */   __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS: () => (/* binding */ __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS),\n/* harmony export */   createGlobalStyle: () => (/* binding */ createGlobalStyle),\n/* harmony export */   css: () => (/* binding */ css),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   isStyledComponent: () => (/* binding */ isStyledComponent),\n/* harmony export */   keyframes: () => (/* binding */ keyframes),\n/* harmony export */   withTheme: () => (/* binding */ withTheme)\n/* harmony export */ });\n/* harmony import */ var stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stylis/stylis.min */ \"(ssr)/./node_modules/better-react-carousel/node_modules/stylis/stylis.min.js\");\n/* harmony import */ var stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stylis-rule-sheet */ \"(ssr)/./node_modules/better-react-carousel/node_modules/stylis-rule-sheet/index.js\");\n/* harmony import */ var stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @emotion/unitless */ \"(ssr)/./node_modules/better-react-carousel/node_modules/@emotion/unitless/dist/unitless.esm.js\");\n/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-is */ \"(ssr)/./node_modules/react-is/index.js\");\n/* harmony import */ var memoize_one__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! memoize-one */ \"(ssr)/./node_modules/memoize-one/dist/memoize-one.esm.js\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @emotion/is-prop-valid */ \"(ssr)/./node_modules/@emotion/is-prop-valid/dist/is-prop-valid.esm.js\");\n/* harmony import */ var merge_anything__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! merge-anything */ \"(ssr)/./node_modules/merge-anything/dist/index.esm.js\");\n\n\n\n\n\n\n\n\n\n\n// \nvar interleave = function(strings, interpolations) {\n    var result = [\n        strings[0]\n    ];\n    for(var i = 0, len = interpolations.length; i < len; i += 1){\n        result.push(interpolations[i], strings[i + 1]);\n    }\n    return result;\n};\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n    return typeof obj;\n} : function(obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar classCallCheck = function(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n};\nvar createClass = function() {\n    function defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n        }\n    }\n    return function(Constructor, protoProps, staticProps) {\n        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) defineProperties(Constructor, staticProps);\n        return Constructor;\n    };\n}();\nvar _extends = Object.assign || function(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i];\n        for(var key in source){\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n};\nvar inherits = function(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\nvar objectWithoutProperties = function(obj, keys) {\n    var target = {};\n    for(var i in obj){\n        if (keys.indexOf(i) >= 0) continue;\n        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n        target[i] = obj[i];\n    }\n    return target;\n};\nvar possibleConstructorReturn = function(self, call) {\n    if (!self) {\n        throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n// \nvar isPlainObject = function(x) {\n    return (typeof x === \"undefined\" ? \"undefined\" : _typeof(x)) === \"object\" && x.constructor === Object;\n};\n// \nvar EMPTY_ARRAY = Object.freeze([]);\nvar EMPTY_OBJECT = Object.freeze({});\n// \nfunction isFunction(test) {\n    return typeof test === \"function\";\n}\n// \nfunction getComponentName(target) {\n    return ( true ? typeof target === \"string\" && target : 0) || target.displayName || target.name || \"Component\";\n}\n// \nfunction isStatelessFunction(test) {\n    return typeof test === \"function\" && !(test.prototype && test.prototype.isReactComponent);\n}\n// \nfunction isStyledComponent(target) {\n    return target && typeof target.styledComponentId === \"string\";\n}\n// \nvar SC_ATTR = typeof process !== \"undefined\" && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || \"data-styled\";\nvar SC_VERSION_ATTR = \"data-styled-version\";\nvar SC_STREAM_ATTR = \"data-styled-streamed\";\nvar IS_BROWSER =  false && 0;\nvar DISABLE_SPEEDY = typeof SC_DISABLE_SPEEDY === \"boolean\" && SC_DISABLE_SPEEDY || typeof process !== \"undefined\" && (process.env.REACT_APP_SC_DISABLE_SPEEDY || process.env.SC_DISABLE_SPEEDY) || \"development\" !== \"production\";\n// Shared empty execution context when generating static styles\nvar STATIC_EXECUTION_CONTEXT = {};\n// \n/**\n * Parse errors.md and turn it into a simple hash of code: message\n */ var ERRORS =  true ? {\n    \"1\": \"Cannot create styled-component for component: %s.\\n\\n\",\n    \"2\": \"Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\\n\\n- Are you trying to reuse it across renders?\\n- Are you accidentally calling collectStyles twice?\\n\\n\",\n    \"3\": \"Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\\n\\n\",\n    \"4\": \"The `StyleSheetManager` expects a valid target or sheet prop!\\n\\n- Does this error occur on the client and is your target falsy?\\n- Does this error occur on the server and is the sheet falsy?\\n\\n\",\n    \"5\": \"The clone method cannot be used on the client!\\n\\n- Are you running in a client-like environment on the server?\\n- Are you trying to run SSR on the client?\\n\\n\",\n    \"6\": \"Trying to insert a new style tag, but the given Node is unmounted!\\n\\n- Are you using a custom target that isn't mounted?\\n- Does your document not have a valid head element?\\n- Have you accidentally removed a style tag manually?\\n\\n\",\n    \"7\": 'ThemeProvider: Please return an object from your \"theme\" prop function, e.g.\\n\\n```js\\ntheme={() => ({})}\\n```\\n\\n',\n    \"8\": 'ThemeProvider: Please make your \"theme\" prop an object.\\n\\n',\n    \"9\": \"Missing document `<head>`\\n\\n\",\n    \"10\": \"Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\\n\\n\",\n    \"11\": \"_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\\n\\n\",\n    \"12\": \"It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\\\`\\\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\\n\\n\",\n    \"13\": \"%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\\n\"\n} : 0;\n/**\n * super basic version of sprintf\n */ function format() {\n    var a = arguments.length <= 0 ? undefined : arguments[0];\n    var b = [];\n    for(var c = 1, len = arguments.length; c < len; c += 1){\n        b.push(arguments.length <= c ? undefined : arguments[c]);\n    }\n    b.forEach(function(d) {\n        a = a.replace(/%[a-z]/, d);\n    });\n    return a;\n}\n/**\n * Create an error file out of errors.md for development and a simple web link to the full errors\n * in production mode.\n */ var StyledComponentsError = function(_Error) {\n    inherits(StyledComponentsError, _Error);\n    function StyledComponentsError(code) {\n        classCallCheck(this, StyledComponentsError);\n        for(var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            interpolations[_key - 1] = arguments[_key];\n        }\n        if (false) { var _this; } else {\n            var _this = possibleConstructorReturn(this, _Error.call(this, format.apply(undefined, [\n                ERRORS[code]\n            ].concat(interpolations)).trim()));\n        }\n        return possibleConstructorReturn(_this);\n    }\n    return StyledComponentsError;\n}(Error);\n// \nvar SC_COMPONENT_ID = /^[^\\S\\n]*?\\/\\* sc-component-id:\\s*(\\S+)\\s+\\*\\//gm;\nvar extractComps = function(maybeCSS) {\n    var css = \"\" + (maybeCSS || \"\"); // Definitely a string, and a clone\n    var existingComponents = [];\n    css.replace(SC_COMPONENT_ID, function(match, componentId, matchIndex) {\n        existingComponents.push({\n            componentId: componentId,\n            matchIndex: matchIndex\n        });\n        return match;\n    });\n    return existingComponents.map(function(_ref, i) {\n        var componentId = _ref.componentId, matchIndex = _ref.matchIndex;\n        var nextComp = existingComponents[i + 1];\n        var cssFromDOM = nextComp ? css.slice(matchIndex, nextComp.matchIndex) : css.slice(matchIndex);\n        return {\n            componentId: componentId,\n            cssFromDOM: cssFromDOM\n        };\n    });\n};\n// \nvar COMMENT_REGEX = /^\\s*\\/\\/.*$/gm;\n// NOTE: This stylis instance is only used to split rules from SSR'd style tags\nvar stylisSplitter = new (stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default())({\n    global: false,\n    cascade: true,\n    keyframe: false,\n    prefix: false,\n    compress: false,\n    semicolon: true\n});\nvar stylis = new (stylis_stylis_min__WEBPACK_IMPORTED_MODULE_0___default())({\n    global: false,\n    cascade: true,\n    keyframe: false,\n    prefix: true,\n    compress: false,\n    semicolon: false // NOTE: This means \"autocomplete missing semicolons\"\n});\n// Wrap `insertRulePlugin to build a list of rules,\n// and then make our own plugin to return the rules. This\n// makes it easier to hook into the existing SSR architecture\nvar parsingRules = [];\n// eslint-disable-next-line consistent-return\nvar returnRulesPlugin = function returnRulesPlugin(context) {\n    if (context === -2) {\n        var parsedRules = parsingRules;\n        parsingRules = [];\n        return parsedRules;\n    }\n};\nvar parseRulesPlugin = stylis_rule_sheet__WEBPACK_IMPORTED_MODULE_1___default()(function(rule) {\n    parsingRules.push(rule);\n});\nvar _componentId = void 0;\nvar _selector = void 0;\nvar _selectorRegexp = void 0;\nvar selfReferenceReplacer = function selfReferenceReplacer(match, offset, string) {\n    if (// the first self-ref is always untouched\n    offset > 0 && // there should be at least two self-refs to do a replacement (.b > .b)\n    string.slice(0, offset).indexOf(_selector) !== -1 && // no consecutive self refs (.b.b); that is a precedence boost and treated differently\n    string.slice(offset - _selector.length, offset) !== _selector) {\n        return \".\" + _componentId;\n    }\n    return match;\n};\n/**\n * When writing a style like\n *\n * & + & {\n *   color: red;\n * }\n *\n * The second ampersand should be a reference to the static component class. stylis\n * has no knowledge of static class so we have to intelligently replace the base selector.\n */ var selfReferenceReplacementPlugin = function selfReferenceReplacementPlugin(context, _, selectors) {\n    if (context === 2 && selectors.length && selectors[0].lastIndexOf(_selector) > 0) {\n        // eslint-disable-next-line no-param-reassign\n        selectors[0] = selectors[0].replace(_selectorRegexp, selfReferenceReplacer);\n    }\n};\nstylis.use([\n    selfReferenceReplacementPlugin,\n    parseRulesPlugin,\n    returnRulesPlugin\n]);\nstylisSplitter.use([\n    parseRulesPlugin,\n    returnRulesPlugin\n]);\nvar splitByRules = function splitByRules(css) {\n    return stylisSplitter(\"\", css);\n};\nfunction stringifyRules(rules, selector, prefix) {\n    var componentId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"&\";\n    var flatCSS = rules.join(\"\").replace(COMMENT_REGEX, \"\"); // replace JS comments\n    var cssStr = selector && prefix ? prefix + \" \" + selector + \" { \" + flatCSS + \" }\" : flatCSS;\n    // stylis has no concept of state to be passed to plugins\n    // but since JS is single=threaded, we can rely on that to ensure\n    // these properties stay in sync with the current stylis run\n    _componentId = componentId;\n    _selector = selector;\n    _selectorRegexp = new RegExp(\"\\\\\" + _selector + \"\\\\b\", \"g\");\n    return stylis(prefix || !selector ? \"\" : selector, cssStr);\n}\n// \n/* eslint-disable camelcase, no-undef */ var getNonce = function() {\n    return  true ? __webpack_require__.nc : 0;\n};\n// \n/* These are helpers for the StyleTags to keep track of the injected\n * rule names for each (component) ID that they're keeping track of.\n * They're crucial for detecting whether a name has already been\n * injected.\n * (This excludes rehydrated names) */ /* adds a new ID:name pairing to a names dictionary */ var addNameForId = function addNameForId(names, id, name) {\n    if (name) {\n        // eslint-disable-next-line no-param-reassign\n        var namesForId = names[id] || (names[id] = Object.create(null));\n        namesForId[name] = true;\n    }\n};\n/* resets an ID entirely by overwriting it in the dictionary */ var resetIdNames = function resetIdNames(names, id) {\n    // eslint-disable-next-line no-param-reassign\n    names[id] = Object.create(null);\n};\n/* factory for a names dictionary checking the existance of an ID:name pairing */ var hasNameForId = function hasNameForId(names) {\n    return function(id, name) {\n        return names[id] !== undefined && names[id][name];\n    };\n};\n/* stringifies names for the html/element output */ var stringifyNames = function stringifyNames(names) {\n    var str = \"\";\n    // eslint-disable-next-line guard-for-in\n    for(var id in names){\n        str += Object.keys(names[id]).join(\" \") + \" \";\n    }\n    return str.trim();\n};\n/* clones the nested names dictionary */ var cloneNames = function cloneNames(names) {\n    var clone = Object.create(null);\n    // eslint-disable-next-line guard-for-in\n    for(var id in names){\n        clone[id] = _extends({}, names[id]);\n    }\n    return clone;\n};\n// \n/* These are helpers that deal with the insertRule (aka speedy) API\n * They are used in the StyleTags and specifically the speedy tag\n */ /* retrieve a sheet for a given style tag */ var sheetForTag = function sheetForTag(tag) {\n    // $FlowFixMe\n    if (tag.sheet) return tag.sheet;\n    /* Firefox quirk requires us to step through all stylesheets to find one owned by the given tag */ var size = tag.ownerDocument.styleSheets.length;\n    for(var i = 0; i < size; i += 1){\n        var sheet = tag.ownerDocument.styleSheets[i];\n        // $FlowFixMe\n        if (sheet.ownerNode === tag) return sheet;\n    }\n    /* we should always be able to find a tag */ throw new StyledComponentsError(10);\n};\n/* insert a rule safely and return whether it was actually injected */ var safeInsertRule = function safeInsertRule(sheet, cssRule, index) {\n    /* abort early if cssRule string is falsy */ if (!cssRule) return false;\n    var maxIndex = sheet.cssRules.length;\n    try {\n        /* use insertRule and cap passed index with maxIndex (no of cssRules) */ sheet.insertRule(cssRule, index <= maxIndex ? index : maxIndex);\n    } catch (err) {\n        /* any error indicates an invalid rule */ return false;\n    }\n    return true;\n};\n/* deletes `size` rules starting from `removalIndex` */ var deleteRules = function deleteRules(sheet, removalIndex, size) {\n    var lowerBound = removalIndex - size;\n    for(var i = removalIndex; i > lowerBound; i -= 1){\n        sheet.deleteRule(i);\n    }\n};\n// \n/* this marker separates component styles and is important for rehydration */ var makeTextMarker = function makeTextMarker(id) {\n    return \"\\n/* sc-component-id: \" + id + \" */\\n\";\n};\n/* add up all numbers in array up until and including the index */ var addUpUntilIndex = function addUpUntilIndex(sizes, index) {\n    var totalUpToIndex = 0;\n    for(var i = 0; i <= index; i += 1){\n        totalUpToIndex += sizes[i];\n    }\n    return totalUpToIndex;\n};\n/* create a new style tag after lastEl */ var makeStyleTag = function makeStyleTag(target, tagEl, insertBefore) {\n    var targetDocument = document;\n    if (target) targetDocument = target.ownerDocument;\n    else if (tagEl) targetDocument = tagEl.ownerDocument;\n    var el = targetDocument.createElement(\"style\");\n    el.setAttribute(SC_ATTR, \"\");\n    el.setAttribute(SC_VERSION_ATTR, \"4.4.1\");\n    var nonce = getNonce();\n    if (nonce) {\n        el.setAttribute(\"nonce\", nonce);\n    }\n    /* Work around insertRule quirk in EdgeHTML */ el.appendChild(targetDocument.createTextNode(\"\"));\n    if (target && !tagEl) {\n        /* Append to target when no previous element was passed */ target.appendChild(el);\n    } else {\n        if (!tagEl || !target || !tagEl.parentNode) {\n            throw new StyledComponentsError(6);\n        }\n        /* Insert new style tag after the previous one */ tagEl.parentNode.insertBefore(el, insertBefore ? tagEl : tagEl.nextSibling);\n    }\n    return el;\n};\n/* takes a css factory function and outputs an html styled tag factory */ var wrapAsHtmlTag = function wrapAsHtmlTag(css, names) {\n    return function(additionalAttrs) {\n        var nonce = getNonce();\n        var attrs = [\n            nonce && 'nonce=\"' + nonce + '\"',\n            SC_ATTR + '=\"' + stringifyNames(names) + '\"',\n            SC_VERSION_ATTR + '=\"' + \"4.4.1\" + '\"',\n            additionalAttrs\n        ];\n        var htmlAttr = attrs.filter(Boolean).join(\" \");\n        return \"<style \" + htmlAttr + \">\" + css() + \"</style>\";\n    };\n};\n/* takes a css factory function and outputs an element factory */ var wrapAsElement = function wrapAsElement(css, names) {\n    return function() {\n        var _props;\n        var props = (_props = {}, _props[SC_ATTR] = stringifyNames(names), _props[SC_VERSION_ATTR] = \"4.4.1\", _props);\n        var nonce = getNonce();\n        if (nonce) {\n            // $FlowFixMe\n            props.nonce = nonce;\n        }\n        // eslint-disable-next-line react/no-danger\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(\"style\", _extends({}, props, {\n            dangerouslySetInnerHTML: {\n                __html: css()\n            }\n        }));\n    };\n};\nvar getIdsFromMarkersFactory = function getIdsFromMarkersFactory(markers) {\n    return function() {\n        return Object.keys(markers);\n    };\n};\n/* speedy tags utilise insertRule */ var makeSpeedyTag = function makeSpeedyTag(el, getImportRuleTag) {\n    var names = Object.create(null);\n    var markers = Object.create(null);\n    var sizes = [];\n    var extractImport = getImportRuleTag !== undefined;\n    /* indicates whether getImportRuleTag was called */ var usedImportRuleTag = false;\n    var insertMarker = function insertMarker(id) {\n        var prev = markers[id];\n        if (prev !== undefined) {\n            return prev;\n        }\n        markers[id] = sizes.length;\n        sizes.push(0);\n        resetIdNames(names, id);\n        return markers[id];\n    };\n    var insertRules = function insertRules(id, cssRules, name) {\n        var marker = insertMarker(id);\n        var sheet = sheetForTag(el);\n        var insertIndex = addUpUntilIndex(sizes, marker);\n        var injectedRules = 0;\n        var importRules = [];\n        var cssRulesSize = cssRules.length;\n        for(var i = 0; i < cssRulesSize; i += 1){\n            var cssRule = cssRules[i];\n            var mayHaveImport = extractImport; /* @import rules are reordered to appear first */ \n            if (mayHaveImport && cssRule.indexOf(\"@import\") !== -1) {\n                importRules.push(cssRule);\n            } else if (safeInsertRule(sheet, cssRule, insertIndex + injectedRules)) {\n                mayHaveImport = false;\n                injectedRules += 1;\n            }\n        }\n        if (extractImport && importRules.length > 0) {\n            usedImportRuleTag = true;\n            // $FlowFixMe\n            getImportRuleTag().insertRules(id + \"-import\", importRules);\n        }\n        sizes[marker] += injectedRules; /* add up no of injected rules */ \n        addNameForId(names, id, name);\n    };\n    var removeRules = function removeRules(id) {\n        var marker = markers[id];\n        if (marker === undefined) return;\n        // $FlowFixMe\n        if (el.isConnected === false) return;\n        var size = sizes[marker];\n        var sheet = sheetForTag(el);\n        var removalIndex = addUpUntilIndex(sizes, marker) - 1;\n        deleteRules(sheet, removalIndex, size);\n        sizes[marker] = 0;\n        resetIdNames(names, id);\n        if (extractImport && usedImportRuleTag) {\n            // $FlowFixMe\n            getImportRuleTag().removeRules(id + \"-import\");\n        }\n    };\n    var css = function css() {\n        var _sheetForTag = sheetForTag(el), cssRules = _sheetForTag.cssRules;\n        var str = \"\";\n        // eslint-disable-next-line guard-for-in\n        for(var id in markers){\n            str += makeTextMarker(id);\n            var marker = markers[id];\n            var end = addUpUntilIndex(sizes, marker);\n            var size = sizes[marker];\n            for(var i = end - size; i < end; i += 1){\n                var rule = cssRules[i];\n                if (rule !== undefined) {\n                    str += rule.cssText;\n                }\n            }\n        }\n        return str;\n    };\n    return {\n        clone: function clone() {\n            throw new StyledComponentsError(5);\n        },\n        css: css,\n        getIds: getIdsFromMarkersFactory(markers),\n        hasNameForId: hasNameForId(names),\n        insertMarker: insertMarker,\n        insertRules: insertRules,\n        removeRules: removeRules,\n        sealed: false,\n        styleTag: el,\n        toElement: wrapAsElement(css, names),\n        toHTML: wrapAsHtmlTag(css, names)\n    };\n};\nvar makeTextNode = function makeTextNode(targetDocument, id) {\n    return targetDocument.createTextNode(makeTextMarker(id));\n};\nvar makeBrowserTag = function makeBrowserTag(el, getImportRuleTag) {\n    var names = Object.create(null);\n    var markers = Object.create(null);\n    var extractImport = getImportRuleTag !== undefined;\n    /* indicates whether getImportRuleTag was called */ var usedImportRuleTag = false;\n    var insertMarker = function insertMarker(id) {\n        var prev = markers[id];\n        if (prev !== undefined) {\n            return prev;\n        }\n        markers[id] = makeTextNode(el.ownerDocument, id);\n        el.appendChild(markers[id]);\n        names[id] = Object.create(null);\n        return markers[id];\n    };\n    var insertRules = function insertRules(id, cssRules, name) {\n        var marker = insertMarker(id);\n        var importRules = [];\n        var cssRulesSize = cssRules.length;\n        for(var i = 0; i < cssRulesSize; i += 1){\n            var rule = cssRules[i];\n            var mayHaveImport = extractImport;\n            if (mayHaveImport && rule.indexOf(\"@import\") !== -1) {\n                importRules.push(rule);\n            } else {\n                mayHaveImport = false;\n                var separator = i === cssRulesSize - 1 ? \"\" : \" \";\n                marker.appendData(\"\" + rule + separator);\n            }\n        }\n        addNameForId(names, id, name);\n        if (extractImport && importRules.length > 0) {\n            usedImportRuleTag = true;\n            // $FlowFixMe\n            getImportRuleTag().insertRules(id + \"-import\", importRules);\n        }\n    };\n    var removeRules = function removeRules(id) {\n        var marker = markers[id];\n        if (marker === undefined) return;\n        /* create new empty text node and replace the current one */ var newMarker = makeTextNode(el.ownerDocument, id);\n        el.replaceChild(newMarker, marker);\n        markers[id] = newMarker;\n        resetIdNames(names, id);\n        if (extractImport && usedImportRuleTag) {\n            // $FlowFixMe\n            getImportRuleTag().removeRules(id + \"-import\");\n        }\n    };\n    var css = function css() {\n        var str = \"\";\n        // eslint-disable-next-line guard-for-in\n        for(var id in markers){\n            str += markers[id].data;\n        }\n        return str;\n    };\n    return {\n        clone: function clone() {\n            throw new StyledComponentsError(5);\n        },\n        css: css,\n        getIds: getIdsFromMarkersFactory(markers),\n        hasNameForId: hasNameForId(names),\n        insertMarker: insertMarker,\n        insertRules: insertRules,\n        removeRules: removeRules,\n        sealed: false,\n        styleTag: el,\n        toElement: wrapAsElement(css, names),\n        toHTML: wrapAsHtmlTag(css, names)\n    };\n};\nvar makeServerTag = function makeServerTag(namesArg, markersArg) {\n    var names = namesArg === undefined ? Object.create(null) : namesArg;\n    var markers = markersArg === undefined ? Object.create(null) : markersArg;\n    var insertMarker = function insertMarker(id) {\n        var prev = markers[id];\n        if (prev !== undefined) {\n            return prev;\n        }\n        return markers[id] = [\n            \"\"\n        ];\n    };\n    var insertRules = function insertRules(id, cssRules, name) {\n        var marker = insertMarker(id);\n        marker[0] += cssRules.join(\" \");\n        addNameForId(names, id, name);\n    };\n    var removeRules = function removeRules(id) {\n        var marker = markers[id];\n        if (marker === undefined) return;\n        marker[0] = \"\";\n        resetIdNames(names, id);\n    };\n    var css = function css() {\n        var str = \"\";\n        // eslint-disable-next-line guard-for-in\n        for(var id in markers){\n            var cssForId = markers[id][0];\n            if (cssForId) {\n                str += makeTextMarker(id) + cssForId;\n            }\n        }\n        return str;\n    };\n    var clone = function clone() {\n        var namesClone = cloneNames(names);\n        var markersClone = Object.create(null);\n        // eslint-disable-next-line guard-for-in\n        for(var id in markers){\n            markersClone[id] = [\n                markers[id][0]\n            ];\n        }\n        return makeServerTag(namesClone, markersClone);\n    };\n    var tag = {\n        clone: clone,\n        css: css,\n        getIds: getIdsFromMarkersFactory(markers),\n        hasNameForId: hasNameForId(names),\n        insertMarker: insertMarker,\n        insertRules: insertRules,\n        removeRules: removeRules,\n        sealed: false,\n        styleTag: null,\n        toElement: wrapAsElement(css, names),\n        toHTML: wrapAsHtmlTag(css, names)\n    };\n    return tag;\n};\nvar makeTag = function makeTag(target, tagEl, forceServer, insertBefore, getImportRuleTag) {\n    if (IS_BROWSER && !forceServer) {\n        var el = makeStyleTag(target, tagEl, insertBefore);\n        if (DISABLE_SPEEDY) {\n            return makeBrowserTag(el, getImportRuleTag);\n        } else {\n            return makeSpeedyTag(el, getImportRuleTag);\n        }\n    }\n    return makeServerTag();\n};\nvar rehydrate = function rehydrate(tag, els, extracted) {\n    /* add all extracted components to the new tag */ for(var i = 0, len = extracted.length; i < len; i += 1){\n        var _extracted$i = extracted[i], componentId = _extracted$i.componentId, cssFromDOM = _extracted$i.cssFromDOM;\n        var cssRules = splitByRules(cssFromDOM);\n        tag.insertRules(componentId, cssRules);\n    }\n    /* remove old HTMLStyleElements, since they have been rehydrated */ for(var _i = 0, _len = els.length; _i < _len; _i += 1){\n        var el = els[_i];\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n    }\n};\n// \nvar SPLIT_REGEX = /\\s+/;\n/* determine the maximum number of components before tags are sharded */ var MAX_SIZE = void 0;\nif (IS_BROWSER) {\n    /* in speedy mode we can keep a lot more rules in a sheet before a slowdown can be expected */ MAX_SIZE = DISABLE_SPEEDY ? 40 : 1000;\n} else {\n    /* for servers we do not need to shard at all */ MAX_SIZE = -1;\n}\nvar sheetRunningId = 0;\nvar master = void 0;\nvar StyleSheet = function() {\n    /* a map from ids to tags */ /* deferred rules for a given id */ /* this is used for not reinjecting rules via hasNameForId() */ /* when rules for an id are removed using remove() we have to ignore rehydratedNames for it */ /* a list of tags belonging to this StyleSheet */ /* a tag for import rules */ /* current capacity until a new tag must be created */ /* children (aka clones) of this StyleSheet inheriting all and future injections */ function StyleSheet() {\n        var _this = this;\n        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : IS_BROWSER ? document.head : null;\n        var forceServer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        classCallCheck(this, StyleSheet);\n        this.getImportRuleTag = function() {\n            var importRuleTag = _this.importRuleTag;\n            if (importRuleTag !== undefined) {\n                return importRuleTag;\n            }\n            var firstTag = _this.tags[0];\n            var insertBefore = true;\n            return _this.importRuleTag = makeTag(_this.target, firstTag ? firstTag.styleTag : null, _this.forceServer, insertBefore);\n        };\n        sheetRunningId += 1;\n        this.id = sheetRunningId;\n        this.forceServer = forceServer;\n        this.target = forceServer ? null : target;\n        this.tagMap = {};\n        this.deferred = {};\n        this.rehydratedNames = {};\n        this.ignoreRehydratedNames = {};\n        this.tags = [];\n        this.capacity = 1;\n        this.clones = [];\n    }\n    /* rehydrate all SSR'd style tags */ StyleSheet.prototype.rehydrate = function rehydrate$$1() {\n        if (!IS_BROWSER || this.forceServer) return this;\n        var els = [];\n        var extracted = [];\n        var isStreamed = false;\n        /* retrieve all of our SSR style elements from the DOM */ var nodes = document.querySelectorAll(\"style[\" + SC_ATTR + \"][\" + SC_VERSION_ATTR + '=\"' + \"4.4.1\" + '\"]');\n        var nodesSize = nodes.length;\n        /* abort rehydration if no previous style tags were found */ if (!nodesSize) return this;\n        for(var i = 0; i < nodesSize; i += 1){\n            var el = nodes[i];\n            /* check if style tag is a streamed tag */ if (!isStreamed) isStreamed = !!el.getAttribute(SC_STREAM_ATTR);\n            /* retrieve all component names */ var elNames = (el.getAttribute(SC_ATTR) || \"\").trim().split(SPLIT_REGEX);\n            var elNamesSize = elNames.length;\n            for(var j = 0, name; j < elNamesSize; j += 1){\n                name = elNames[j];\n                /* add rehydrated name to sheet to avoid re-adding styles */ this.rehydratedNames[name] = true;\n            }\n            /* extract all components and their CSS */ extracted.push.apply(extracted, extractComps(el.textContent));\n            /* store original HTMLStyleElement */ els.push(el);\n        }\n        /* abort rehydration if nothing was extracted */ var extractedSize = extracted.length;\n        if (!extractedSize) return this;\n        /* create a tag to be used for rehydration */ var tag = this.makeTag(null);\n        rehydrate(tag, els, extracted);\n        /* reset capacity and adjust MAX_SIZE by the initial size of the rehydration */ this.capacity = Math.max(1, MAX_SIZE - extractedSize);\n        this.tags.push(tag);\n        /* retrieve all component ids */ for(var _j = 0; _j < extractedSize; _j += 1){\n            this.tagMap[extracted[_j].componentId] = tag;\n        }\n        return this;\n    };\n    /* retrieve a \"master\" instance of StyleSheet which is typically used when no other is available\n   * The master StyleSheet is targeted by createGlobalStyle, keyframes, and components outside of any\n    * StyleSheetManager's context */ /* reset the internal \"master\" instance */ StyleSheet.reset = function reset() {\n        var forceServer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        master = new StyleSheet(undefined, forceServer).rehydrate();\n    };\n    /* adds \"children\" to the StyleSheet that inherit all of the parents' rules\n   * while their own rules do not affect the parent */ StyleSheet.prototype.clone = function clone() {\n        var sheet = new StyleSheet(this.target, this.forceServer);\n        /* add to clone array */ this.clones.push(sheet);\n        /* clone all tags */ sheet.tags = this.tags.map(function(tag) {\n            var ids = tag.getIds();\n            var newTag = tag.clone();\n            /* reconstruct tagMap */ for(var i = 0; i < ids.length; i += 1){\n                sheet.tagMap[ids[i]] = newTag;\n            }\n            return newTag;\n        });\n        /* clone other maps */ sheet.rehydratedNames = _extends({}, this.rehydratedNames);\n        sheet.deferred = _extends({}, this.deferred);\n        return sheet;\n    };\n    /* force StyleSheet to create a new tag on the next injection */ StyleSheet.prototype.sealAllTags = function sealAllTags() {\n        this.capacity = 1;\n        this.tags.forEach(function(tag) {\n            // eslint-disable-next-line no-param-reassign\n            tag.sealed = true;\n        });\n    };\n    StyleSheet.prototype.makeTag = function makeTag$$1(tag) {\n        var lastEl = tag ? tag.styleTag : null;\n        var insertBefore = false;\n        return makeTag(this.target, lastEl, this.forceServer, insertBefore, this.getImportRuleTag);\n    };\n    /* get a tag for a given componentId, assign the componentId to one, or shard */ StyleSheet.prototype.getTagForId = function getTagForId(id) {\n        /* simply return a tag, when the componentId was already assigned one */ var prev = this.tagMap[id];\n        if (prev !== undefined && !prev.sealed) {\n            return prev;\n        }\n        var tag = this.tags[this.tags.length - 1];\n        /* shard (create a new tag) if the tag is exhausted (See MAX_SIZE) */ this.capacity -= 1;\n        if (this.capacity === 0) {\n            this.capacity = MAX_SIZE;\n            tag = this.makeTag(tag);\n            this.tags.push(tag);\n        }\n        return this.tagMap[id] = tag;\n    };\n    /* mainly for createGlobalStyle to check for its id */ StyleSheet.prototype.hasId = function hasId(id) {\n        return this.tagMap[id] !== undefined;\n    };\n    /* caching layer checking id+name to already have a corresponding tag and injected rules */ StyleSheet.prototype.hasNameForId = function hasNameForId(id, name) {\n        /* exception for rehydrated names which are checked separately */ if (this.ignoreRehydratedNames[id] === undefined && this.rehydratedNames[name]) {\n            return true;\n        }\n        var tag = this.tagMap[id];\n        return tag !== undefined && tag.hasNameForId(id, name);\n    };\n    /* registers a componentId and registers it on its tag */ StyleSheet.prototype.deferredInject = function deferredInject(id, cssRules) {\n        /* don't inject when the id is already registered */ if (this.tagMap[id] !== undefined) return;\n        var clones = this.clones;\n        for(var i = 0; i < clones.length; i += 1){\n            clones[i].deferredInject(id, cssRules);\n        }\n        this.getTagForId(id).insertMarker(id);\n        this.deferred[id] = cssRules;\n    };\n    /* injects rules for a given id with a name that will need to be cached */ StyleSheet.prototype.inject = function inject(id, cssRules, name) {\n        var clones = this.clones;\n        for(var i = 0; i < clones.length; i += 1){\n            clones[i].inject(id, cssRules, name);\n        }\n        var tag = this.getTagForId(id);\n        /* add deferred rules for component */ if (this.deferred[id] !== undefined) {\n            // Combine passed cssRules with previously deferred CSS rules\n            // NOTE: We cannot mutate the deferred array itself as all clones\n            // do the same (see clones[i].inject)\n            var rules = this.deferred[id].concat(cssRules);\n            tag.insertRules(id, rules, name);\n            this.deferred[id] = undefined;\n        } else {\n            tag.insertRules(id, cssRules, name);\n        }\n    };\n    /* removes all rules for a given id, which doesn't remove its marker but resets it */ StyleSheet.prototype.remove = function remove(id) {\n        var tag = this.tagMap[id];\n        if (tag === undefined) return;\n        var clones = this.clones;\n        for(var i = 0; i < clones.length; i += 1){\n            clones[i].remove(id);\n        }\n        /* remove all rules from the tag */ tag.removeRules(id);\n        /* ignore possible rehydrated names */ this.ignoreRehydratedNames[id] = true;\n        /* delete possible deferred rules */ this.deferred[id] = undefined;\n    };\n    StyleSheet.prototype.toHTML = function toHTML() {\n        return this.tags.map(function(tag) {\n            return tag.toHTML();\n        }).join(\"\");\n    };\n    StyleSheet.prototype.toReactElements = function toReactElements() {\n        var id = this.id;\n        return this.tags.map(function(tag, i) {\n            var key = \"sc-\" + id + \"-\" + i;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.cloneElement)(tag.toElement(), {\n                key: key\n            });\n        });\n    };\n    createClass(StyleSheet, null, [\n        {\n            key: \"master\",\n            get: function get$$1() {\n                return master || (master = new StyleSheet().rehydrate());\n            }\n        },\n        {\n            key: \"instance\",\n            get: function get$$1() {\n                return StyleSheet.master;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\n// \nvar Keyframes = function() {\n    function Keyframes(name, rules) {\n        var _this = this;\n        classCallCheck(this, Keyframes);\n        this.inject = function(styleSheet) {\n            if (!styleSheet.hasNameForId(_this.id, _this.name)) {\n                styleSheet.inject(_this.id, _this.rules, _this.name);\n            }\n        };\n        this.toString = function() {\n            throw new StyledComponentsError(12, String(_this.name));\n        };\n        this.name = name;\n        this.rules = rules;\n        this.id = \"sc-keyframes-\" + name;\n    }\n    Keyframes.prototype.getName = function getName() {\n        return this.name;\n    };\n    return Keyframes;\n}();\n// \n/**\n * inlined version of\n * https://github.com/facebook/fbjs/blob/master/packages/fbjs/src/core/hyphenateStyleName.js\n */ var uppercasePattern = /([A-Z])/g;\nvar msPattern = /^ms-/;\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n *\n * @param {string} string\n * @return {string}\n */ function hyphenateStyleName(string) {\n    return string.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n}\n// \n// Taken from https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-dom/src/shared/dangerousStyleValue.js\nfunction addUnitIfNeeded(name, value) {\n    // https://github.com/amilajack/eslint-plugin-flowtype-errors/issues/133\n    // $FlowFixMe\n    if (value == null || typeof value === \"boolean\" || value === \"\") {\n        return \"\";\n    }\n    if (typeof value === \"number\" && value !== 0 && !(name in _emotion_unitless__WEBPACK_IMPORTED_MODULE_3__[\"default\"])) {\n        return value + \"px\"; // Presumes implicit 'px' suffix for unitless numbers\n    }\n    return String(value).trim();\n}\n// \n/**\n * It's falsish not falsy because 0 is allowed.\n */ var isFalsish = function isFalsish(chunk) {\n    return chunk === undefined || chunk === null || chunk === false || chunk === \"\";\n};\nvar objToCssArray = function objToCssArray(obj, prevKey) {\n    var rules = [];\n    var keys = Object.keys(obj);\n    keys.forEach(function(key) {\n        if (!isFalsish(obj[key])) {\n            if (isPlainObject(obj[key])) {\n                rules.push.apply(rules, objToCssArray(obj[key], key));\n                return rules;\n            } else if (isFunction(obj[key])) {\n                rules.push(hyphenateStyleName(key) + \":\", obj[key], \";\");\n                return rules;\n            }\n            rules.push(hyphenateStyleName(key) + \": \" + addUnitIfNeeded(key, obj[key]) + \";\");\n        }\n        return rules;\n    });\n    return prevKey ? [\n        prevKey + \" {\"\n    ].concat(rules, [\n        \"}\"\n    ]) : rules;\n};\nfunction flatten(chunk, executionContext, styleSheet) {\n    if (Array.isArray(chunk)) {\n        var ruleSet = [];\n        for(var i = 0, len = chunk.length, result; i < len; i += 1){\n            result = flatten(chunk[i], executionContext, styleSheet);\n            if (result === null) continue;\n            else if (Array.isArray(result)) ruleSet.push.apply(ruleSet, result);\n            else ruleSet.push(result);\n        }\n        return ruleSet;\n    }\n    if (isFalsish(chunk)) {\n        return null;\n    }\n    /* Handle other components */ if (isStyledComponent(chunk)) {\n        return \".\" + chunk.styledComponentId;\n    }\n    /* Either execute or defer the function */ if (isFunction(chunk)) {\n        if (isStatelessFunction(chunk) && executionContext) {\n            var _result = chunk(executionContext);\n            if ( true && (0,react_is__WEBPACK_IMPORTED_MODULE_4__.isElement)(_result)) {\n                // eslint-disable-next-line no-console\n                console.warn(getComponentName(chunk) + \" is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\");\n            }\n            return flatten(_result, executionContext, styleSheet);\n        } else return chunk;\n    }\n    if (chunk instanceof Keyframes) {\n        if (styleSheet) {\n            chunk.inject(styleSheet);\n            return chunk.getName();\n        } else return chunk;\n    }\n    /* Handle objects */ return isPlainObject(chunk) ? objToCssArray(chunk) : chunk.toString();\n}\n// \nfunction css(styles) {\n    for(var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        interpolations[_key - 1] = arguments[_key];\n    }\n    if (isFunction(styles) || isPlainObject(styles)) {\n        // $FlowFixMe\n        return flatten(interleave(EMPTY_ARRAY, [\n            styles\n        ].concat(interpolations)));\n    }\n    // $FlowFixMe\n    return flatten(interleave(styles, interpolations));\n}\n// \nfunction constructWithOptions(componentConstructor, tag) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;\n    if (!(0,react_is__WEBPACK_IMPORTED_MODULE_4__.isValidElementType)(tag)) {\n        throw new StyledComponentsError(1, String(tag));\n    }\n    /* This is callable directly as a template function */ // $FlowFixMe: Not typed to avoid destructuring arguments\n    var templateFunction = function templateFunction() {\n        return componentConstructor(tag, options, css.apply(undefined, arguments));\n    };\n    /* If config methods are called, wrap up a new template function and merge options */ templateFunction.withConfig = function(config) {\n        return constructWithOptions(componentConstructor, tag, _extends({}, options, config));\n    };\n    /* Modify/inject new props at runtime */ templateFunction.attrs = function(attrs) {\n        return constructWithOptions(componentConstructor, tag, _extends({}, options, {\n            attrs: Array.prototype.concat(options.attrs, attrs).filter(Boolean)\n        }));\n    };\n    return templateFunction;\n}\n// \n// Source: https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js\nfunction murmurhash(c) {\n    for(var e = c.length | 0, a = e | 0, d = 0, b; e >= 4;){\n        b = c.charCodeAt(d) & 255 | (c.charCodeAt(++d) & 255) << 8 | (c.charCodeAt(++d) & 255) << 16 | (c.charCodeAt(++d) & 255) << 24, b = 1540483477 * (b & 65535) + ((1540483477 * (b >>> 16) & 65535) << 16), b ^= b >>> 24, b = 1540483477 * (b & 65535) + ((1540483477 * (b >>> 16) & 65535) << 16), a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16) ^ b, e -= 4, ++d;\n    }\n    switch(e){\n        case 3:\n            a ^= (c.charCodeAt(d + 2) & 255) << 16;\n        case 2:\n            a ^= (c.charCodeAt(d + 1) & 255) << 8;\n        case 1:\n            a ^= c.charCodeAt(d) & 255, a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);\n    }\n    a ^= a >>> 13;\n    a = 1540483477 * (a & 65535) + ((1540483477 * (a >>> 16) & 65535) << 16);\n    return (a ^ a >>> 15) >>> 0;\n}\n// \n/* eslint-disable no-bitwise */ /* This is the \"capacity\" of our alphabet i.e. 2x26 for all letters plus their capitalised\n * counterparts */ var charsLength = 52;\n/* start at 75 for 'a' until 'z' (25) and then start at 65 for capitalised letters */ var getAlphabeticChar = function getAlphabeticChar(code) {\n    return String.fromCharCode(code + (code > 25 ? 39 : 97));\n};\n/* input a number, usually a hash and convert it to base-52 */ function generateAlphabeticName(code) {\n    var name = \"\";\n    var x = void 0;\n    /* get a char and divide by alphabet-length */ for(x = code; x > charsLength; x = Math.floor(x / charsLength)){\n        name = getAlphabeticChar(x % charsLength) + name;\n    }\n    return getAlphabeticChar(x % charsLength) + name;\n}\n// \nfunction hasFunctionObjectKey(obj) {\n    // eslint-disable-next-line guard-for-in, no-restricted-syntax\n    for(var key in obj){\n        if (isFunction(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction isStaticRules(rules, attrs) {\n    for(var i = 0; i < rules.length; i += 1){\n        var rule = rules[i];\n        // recursive case\n        if (Array.isArray(rule) && !isStaticRules(rule, attrs)) {\n            return false;\n        } else if (isFunction(rule) && !isStyledComponent(rule)) {\n            // functions are allowed to be static if they're just being\n            // used to get the classname of a nested styled component\n            return false;\n        }\n    }\n    if (attrs.some(function(x) {\n        return isFunction(x) || hasFunctionObjectKey(x);\n    })) return false;\n    return true;\n}\n// \n/* combines hashStr (murmurhash) and nameGenerator for convenience */ var hasher = function hasher(str) {\n    return generateAlphabeticName(murmurhash(str));\n};\n/*\n ComponentStyle is all the CSS-specific stuff, not\n the React-specific stuff.\n */ var ComponentStyle = function() {\n    function ComponentStyle(rules, attrs, componentId) {\n        classCallCheck(this, ComponentStyle);\n        this.rules = rules;\n        this.isStatic =  false && 0;\n        this.componentId = componentId;\n        if (!StyleSheet.master.hasId(componentId)) {\n            StyleSheet.master.deferredInject(componentId, []);\n        }\n    }\n    /*\n   * Flattens a rule set into valid CSS\n   * Hashes it, wraps the whole chunk in a .hash1234 {}\n   * Returns the hash to be injected on render()\n   * */ ComponentStyle.prototype.generateAndInjectStyles = function generateAndInjectStyles(executionContext, styleSheet) {\n        var isStatic = this.isStatic, componentId = this.componentId, lastClassName = this.lastClassName;\n        if (IS_BROWSER && isStatic && typeof lastClassName === \"string\" && styleSheet.hasNameForId(componentId, lastClassName)) {\n            return lastClassName;\n        }\n        var flatCSS = flatten(this.rules, executionContext, styleSheet);\n        var name = hasher(this.componentId + flatCSS.join(\"\"));\n        if (!styleSheet.hasNameForId(componentId, name)) {\n            styleSheet.inject(this.componentId, stringifyRules(flatCSS, \".\" + name, undefined, componentId), name);\n        }\n        this.lastClassName = name;\n        return name;\n    };\n    ComponentStyle.generateName = function generateName(str) {\n        return hasher(str);\n    };\n    return ComponentStyle;\n}();\n// \nvar LIMIT = 200;\nvar createWarnTooManyClasses = function(displayName) {\n    var generatedClasses = {};\n    var warningSeen = false;\n    return function(className) {\n        if (!warningSeen) {\n            generatedClasses[className] = true;\n            if (Object.keys(generatedClasses).length >= LIMIT) {\n                // Unable to find latestRule in test environment.\n                /* eslint-disable no-console, prefer-template */ console.warn(\"Over \" + LIMIT + \" classes were generated for component \" + displayName + \". \\n\" + \"Consider using the attrs method, together with a style object for frequently changed styles.\\n\" + \"Example:\\n\" + \"  const Component = styled.div.attrs(props => ({\\n\" + \"    style: {\\n\" + \"      background: props.background,\\n\" + \"    },\\n\" + \"  }))`width: 100%;`\\n\\n\" + \"  <Component />\");\n                warningSeen = true;\n                generatedClasses = {};\n            }\n        }\n    };\n};\n// \nvar determineTheme = function(props, fallbackTheme) {\n    var defaultProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EMPTY_OBJECT;\n    // Props should take precedence over ThemeProvider, which should take precedence over\n    // defaultProps, but React automatically puts defaultProps on props.\n    /* eslint-disable react/prop-types, flowtype-errors/show-errors */ var isDefaultTheme = defaultProps ? props.theme === defaultProps.theme : false;\n    var theme = props.theme && !isDefaultTheme ? props.theme : fallbackTheme || defaultProps.theme;\n    /* eslint-enable */ return theme;\n};\n// \nvar escapeRegex = /[[\\].#*$><+~=|^:(),\"'`-]+/g;\nvar dashesAtEnds = /(^-|-$)/g;\n/**\n * TODO: Explore using CSS.escape when it becomes more available\n * in evergreen browsers.\n */ function escape(str) {\n    return str// Replace all possible CSS selectors\n    .replace(escapeRegex, \"-\")// Remove extraneous hyphens at the start and end\n    .replace(dashesAtEnds, \"\");\n}\n// \nfunction isTag(target) {\n    return typeof target === \"string\" && ( true ? target.charAt(0) === target.charAt(0).toLowerCase() : 0);\n}\n// \nfunction generateDisplayName(target) {\n    // $FlowFixMe\n    return isTag(target) ? \"styled.\" + target : \"Styled(\" + getComponentName(target) + \")\";\n}\nvar _TYPE_STATICS;\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDerivedStateFromProps: true,\n    propTypes: true,\n    type: true\n};\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\nvar TYPE_STATICS = (_TYPE_STATICS = {}, _TYPE_STATICS[react_is__WEBPACK_IMPORTED_MODULE_4__.ForwardRef] = {\n    $$typeof: true,\n    render: true\n}, _TYPE_STATICS);\nvar defineProperty$1 = Object.defineProperty, getOwnPropertyNames = Object.getOwnPropertyNames, _Object$getOwnPropert = Object.getOwnPropertySymbols, getOwnPropertySymbols = _Object$getOwnPropert === undefined ? function() {\n    return [];\n} : _Object$getOwnPropert, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, objectPrototype = Object.prototype;\nvar arrayPrototype = Array.prototype;\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== \"string\") {\n        // don't hoist over string (html) components\n        var inheritedComponent = getPrototypeOf(sourceComponent);\n        if (inheritedComponent && inheritedComponent !== objectPrototype) {\n            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n        }\n        var keys = arrayPrototype.concat(getOwnPropertyNames(sourceComponent), // $FlowFixMe\n        getOwnPropertySymbols(sourceComponent));\n        var targetStatics = TYPE_STATICS[targetComponent.$$typeof] || REACT_STATICS;\n        var sourceStatics = TYPE_STATICS[sourceComponent.$$typeof] || REACT_STATICS;\n        var i = keys.length;\n        var descriptor = void 0;\n        var key = void 0;\n        // eslint-disable-next-line no-plusplus\n        while(i--){\n            key = keys[i];\n            if (// $FlowFixMe\n            !KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && // $FlowFixMe\n            !(targetStatics && targetStatics[key])) {\n                descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                if (descriptor) {\n                    try {\n                        // Avoid failures from read-only properties\n                        defineProperty$1(targetComponent, key, descriptor);\n                    } catch (e) {\n                    /* fail silently */ }\n                }\n            }\n        }\n        return targetComponent;\n    }\n    return targetComponent;\n}\n// \nfunction isDerivedReactComponent(fn) {\n    return !!(fn && fn.prototype && fn.prototype.isReactComponent);\n}\n// \n// Helper to call a given function, only once\nvar once = function(cb) {\n    var called = false;\n    return function() {\n        if (!called) {\n            called = true;\n            cb.apply(undefined, arguments);\n        }\n    };\n};\n// \nvar ThemeContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)();\nvar ThemeConsumer = ThemeContext.Consumer;\n/**\n * Provide a theme to an entire react component tree via context\n */ var ThemeProvider = function(_Component) {\n    inherits(ThemeProvider, _Component);\n    function ThemeProvider(props) {\n        classCallCheck(this, ThemeProvider);\n        var _this = possibleConstructorReturn(this, _Component.call(this, props));\n        _this.getContext = (0,memoize_one__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(_this.getContext.bind(_this));\n        _this.renderInner = _this.renderInner.bind(_this);\n        return _this;\n    }\n    ThemeProvider.prototype.render = function render() {\n        if (!this.props.children) return null;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeContext.Consumer, null, this.renderInner);\n    };\n    ThemeProvider.prototype.renderInner = function renderInner(outerTheme) {\n        var context = this.getContext(this.props.theme, outerTheme);\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeContext.Provider, {\n            value: context\n        }, this.props.children);\n    };\n    /**\n   * Get the theme from the props, supporting both (outerTheme) => {}\n   * as well as object notation\n   */ ThemeProvider.prototype.getTheme = function getTheme(theme, outerTheme) {\n        if (isFunction(theme)) {\n            var mergedTheme = theme(outerTheme);\n            if ( true && (mergedTheme === null || Array.isArray(mergedTheme) || (typeof mergedTheme === \"undefined\" ? \"undefined\" : _typeof(mergedTheme)) !== \"object\")) {\n                throw new StyledComponentsError(7);\n            }\n            return mergedTheme;\n        }\n        if (theme === null || Array.isArray(theme) || (typeof theme === \"undefined\" ? \"undefined\" : _typeof(theme)) !== \"object\") {\n            throw new StyledComponentsError(8);\n        }\n        return _extends({}, outerTheme, theme);\n    };\n    ThemeProvider.prototype.getContext = function getContext(theme, outerTheme) {\n        return this.getTheme(theme, outerTheme);\n    };\n    return ThemeProvider;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\n// \nvar CLOSING_TAG_R = /^\\s*<\\/[a-z]/i;\nvar ServerStyleSheet = function() {\n    function ServerStyleSheet() {\n        classCallCheck(this, ServerStyleSheet);\n        /* The master sheet might be reset, so keep a reference here */ this.masterSheet = StyleSheet.master;\n        this.instance = this.masterSheet.clone();\n        this.sealed = false;\n    }\n    /**\n   * Mark the ServerStyleSheet as being fully emitted and manually GC it from the\n   * StyleSheet singleton.\n   */ ServerStyleSheet.prototype.seal = function seal() {\n        if (!this.sealed) {\n            /* Remove sealed StyleSheets from the master sheet */ var index = this.masterSheet.clones.indexOf(this.instance);\n            this.masterSheet.clones.splice(index, 1);\n            this.sealed = true;\n        }\n    };\n    ServerStyleSheet.prototype.collectStyles = function collectStyles(children) {\n        if (this.sealed) {\n            throw new StyledComponentsError(2);\n        }\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(StyleSheetManager, {\n            sheet: this.instance\n        }, children);\n    };\n    ServerStyleSheet.prototype.getStyleTags = function getStyleTags() {\n        this.seal();\n        return this.instance.toHTML();\n    };\n    ServerStyleSheet.prototype.getStyleElement = function getStyleElement() {\n        this.seal();\n        return this.instance.toReactElements();\n    };\n    ServerStyleSheet.prototype.interleaveWithNodeStream = function interleaveWithNodeStream(readableStream) {\n        var _this = this;\n        if (IS_BROWSER) {\n            throw new StyledComponentsError(3);\n        }\n        /* the tag index keeps track of which tags have already been emitted */ var instance = this.instance;\n        var instanceTagIndex = 0;\n        var streamAttr = SC_STREAM_ATTR + '=\"true\"';\n        var transformer = new (stream__WEBPACK_IMPORTED_MODULE_5___default().Transform)({\n            transform: function appendStyleChunks(chunk, /* encoding */ _, callback) {\n                var tags = instance.tags;\n                var html = \"\";\n                /* retrieve html for each new style tag */ for(; instanceTagIndex < tags.length; instanceTagIndex += 1){\n                    var tag = tags[instanceTagIndex];\n                    html += tag.toHTML(streamAttr);\n                }\n                /* force our StyleSheets to emit entirely new tags */ instance.sealAllTags();\n                var renderedHtml = chunk.toString();\n                /* prepend style html to chunk, unless the start of the chunk is a closing tag in which case append right after that */ if (CLOSING_TAG_R.test(renderedHtml)) {\n                    var endOfClosingTag = renderedHtml.indexOf(\">\");\n                    this.push(renderedHtml.slice(0, endOfClosingTag + 1) + html + renderedHtml.slice(endOfClosingTag + 1));\n                } else this.push(html + renderedHtml);\n                callback();\n            }\n        });\n        readableStream.on(\"end\", function() {\n            return _this.seal();\n        });\n        readableStream.on(\"error\", function(err) {\n            _this.seal();\n            // forward the error to the transform stream\n            transformer.emit(\"error\", err);\n        });\n        return readableStream.pipe(transformer);\n    };\n    return ServerStyleSheet;\n}();\n// \nvar StyleSheetContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createContext)();\nvar StyleSheetConsumer = StyleSheetContext.Consumer;\nvar StyleSheetManager = function(_Component) {\n    inherits(StyleSheetManager, _Component);\n    function StyleSheetManager(props) {\n        classCallCheck(this, StyleSheetManager);\n        var _this = possibleConstructorReturn(this, _Component.call(this, props));\n        _this.getContext = (0,memoize_one__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(_this.getContext);\n        return _this;\n    }\n    StyleSheetManager.prototype.getContext = function getContext(sheet, target) {\n        if (sheet) {\n            return sheet;\n        } else if (target) {\n            return new StyleSheet(target);\n        } else {\n            throw new StyledComponentsError(4);\n        }\n    };\n    StyleSheetManager.prototype.render = function render() {\n        var _props = this.props, children = _props.children, sheet = _props.sheet, target = _props.target;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(StyleSheetContext.Provider, {\n            value: this.getContext(sheet, target)\n        },  true ? react__WEBPACK_IMPORTED_MODULE_2___default().Children.only(children) : 0);\n    };\n    return StyleSheetManager;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\n true ? StyleSheetManager.propTypes = {\n    sheet: prop_types__WEBPACK_IMPORTED_MODULE_9___default().oneOfType([\n        prop_types__WEBPACK_IMPORTED_MODULE_9___default().instanceOf(StyleSheet),\n        prop_types__WEBPACK_IMPORTED_MODULE_9___default().instanceOf(ServerStyleSheet)\n    ]),\n    target: prop_types__WEBPACK_IMPORTED_MODULE_9___default().shape({\n        appendChild: (prop_types__WEBPACK_IMPORTED_MODULE_9___default().func).isRequired\n    })\n} : 0;\n// \nvar identifiers = {};\n/* We depend on components having unique IDs */ function generateId(_ComponentStyle, _displayName, parentComponentId) {\n    var displayName = typeof _displayName !== \"string\" ? \"sc\" : escape(_displayName);\n    /**\n   * This ensures uniqueness if two components happen to share\n   * the same displayName.\n   */ var nr = (identifiers[displayName] || 0) + 1;\n    identifiers[displayName] = nr;\n    var componentId = displayName + \"-\" + _ComponentStyle.generateName(displayName + nr);\n    return parentComponentId ? parentComponentId + \"-\" + componentId : componentId;\n}\n// $FlowFixMe\nvar StyledComponent = function(_Component) {\n    inherits(StyledComponent, _Component);\n    function StyledComponent() {\n        classCallCheck(this, StyledComponent);\n        var _this = possibleConstructorReturn(this, _Component.call(this));\n        _this.attrs = {};\n        _this.renderOuter = _this.renderOuter.bind(_this);\n        _this.renderInner = _this.renderInner.bind(_this);\n        if (true) {\n            _this.warnInnerRef = once(function(displayName) {\n                return(// eslint-disable-next-line no-console\n                console.warn('The \"innerRef\" API has been removed in styled-components v4 in favor of React 16 ref forwarding, use \"ref\" instead like a typical component. \"innerRef\" was detected on component \"' + displayName + '\".'));\n            });\n            _this.warnAttrsFnObjectKeyDeprecated = once(function(key, displayName) {\n                return(// eslint-disable-next-line no-console\n                console.warn('Functions as object-form attrs({}) keys are now deprecated and will be removed in a future version of styled-components. Switch to the new attrs(props => ({})) syntax instead for easier and more powerful composition. The attrs key in question is \"' + key + '\" on component \"' + displayName + '\".', \"\\n \" + new Error().stack));\n            });\n            _this.warnNonStyledComponentAttrsObjectKey = once(function(key, displayName) {\n                return(// eslint-disable-next-line no-console\n                console.warn(\"It looks like you've used a non styled-component as the value for the \\\"\" + key + '\" prop in an object-form attrs constructor of \"' + displayName + '\".\\n' + \"You should use the new function-form attrs constructor which avoids this issue: attrs(props => ({ yourStuff }))\\n\" + \"To continue using the deprecated object syntax, you'll need to wrap your component prop in a function to make it available inside the styled component (you'll still get the deprecation warning though.)\\n\" + (\"For example, { \" + key + \": () => InnerComponent } instead of { \" + key + \": InnerComponent }\")));\n            });\n        }\n        return _this;\n    }\n    StyledComponent.prototype.render = function render() {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(StyleSheetConsumer, null, this.renderOuter);\n    };\n    StyledComponent.prototype.renderOuter = function renderOuter() {\n        var styleSheet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : StyleSheet.master;\n        this.styleSheet = styleSheet;\n        // No need to subscribe a static component to theme changes, it won't change anything\n        if (this.props.forwardedComponent.componentStyle.isStatic) return this.renderInner();\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeConsumer, null, this.renderInner);\n    };\n    StyledComponent.prototype.renderInner = function renderInner(theme) {\n        var _props$forwardedCompo = this.props.forwardedComponent, componentStyle = _props$forwardedCompo.componentStyle, defaultProps = _props$forwardedCompo.defaultProps, displayName = _props$forwardedCompo.displayName, foldedComponentIds = _props$forwardedCompo.foldedComponentIds, styledComponentId = _props$forwardedCompo.styledComponentId, target = _props$forwardedCompo.target;\n        var generatedClassName = void 0;\n        if (componentStyle.isStatic) {\n            generatedClassName = this.generateAndInjectStyles(EMPTY_OBJECT, this.props);\n        } else {\n            generatedClassName = this.generateAndInjectStyles(determineTheme(this.props, theme, defaultProps) || EMPTY_OBJECT, this.props);\n        }\n        var elementToBeCreated = this.props.as || this.attrs.as || target;\n        var isTargetTag = isTag(elementToBeCreated);\n        var propsForElement = {};\n        var computedProps = _extends({}, this.props, this.attrs);\n        var key = void 0;\n        // eslint-disable-next-line guard-for-in\n        for(key in computedProps){\n            if ( true && key === \"innerRef\" && isTargetTag) {\n                this.warnInnerRef(displayName);\n            }\n            if (key === \"forwardedComponent\" || key === \"as\") {\n                continue;\n            } else if (key === \"forwardedRef\") propsForElement.ref = computedProps[key];\n            else if (key === \"forwardedAs\") propsForElement.as = computedProps[key];\n            else if (!isTargetTag || (0,_emotion_is_prop_valid__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(key)) {\n                // Don't pass through non HTML tags through to HTML elements\n                propsForElement[key] = computedProps[key];\n            }\n        }\n        if (this.props.style && this.attrs.style) {\n            propsForElement.style = _extends({}, this.attrs.style, this.props.style);\n        }\n        propsForElement.className = Array.prototype.concat(foldedComponentIds, styledComponentId, generatedClassName !== styledComponentId ? generatedClassName : null, this.props.className, this.attrs.className).filter(Boolean).join(\" \");\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_2__.createElement)(elementToBeCreated, propsForElement);\n    };\n    StyledComponent.prototype.buildExecutionContext = function buildExecutionContext(theme, props, attrs) {\n        var _this2 = this;\n        var context = _extends({}, props, {\n            theme: theme\n        });\n        if (!attrs.length) return context;\n        this.attrs = {};\n        attrs.forEach(function(attrDef) {\n            var resolvedAttrDef = attrDef;\n            var attrDefWasFn = false;\n            var attr = void 0;\n            var key = void 0;\n            if (isFunction(resolvedAttrDef)) {\n                // $FlowFixMe\n                resolvedAttrDef = resolvedAttrDef(context);\n                attrDefWasFn = true;\n            }\n            /* eslint-disable guard-for-in */ // $FlowFixMe\n            for(key in resolvedAttrDef){\n                attr = resolvedAttrDef[key];\n                if (!attrDefWasFn) {\n                    if (isFunction(attr) && !isDerivedReactComponent(attr) && !isStyledComponent(attr)) {\n                        if (true) {\n                            _this2.warnAttrsFnObjectKeyDeprecated(key, props.forwardedComponent.displayName);\n                        }\n                        attr = attr(context);\n                        if ( true && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().isValidElement(attr)) {\n                            _this2.warnNonStyledComponentAttrsObjectKey(key, props.forwardedComponent.displayName);\n                        }\n                    }\n                }\n                _this2.attrs[key] = attr;\n                context[key] = attr;\n            }\n        /* eslint-enable */ });\n        return context;\n    };\n    StyledComponent.prototype.generateAndInjectStyles = function generateAndInjectStyles(theme, props) {\n        var _props$forwardedCompo2 = props.forwardedComponent, attrs = _props$forwardedCompo2.attrs, componentStyle = _props$forwardedCompo2.componentStyle, warnTooManyClasses = _props$forwardedCompo2.warnTooManyClasses;\n        // statically styled-components don't need to build an execution context object,\n        // and shouldn't be increasing the number of class names\n        if (componentStyle.isStatic && !attrs.length) {\n            return componentStyle.generateAndInjectStyles(EMPTY_OBJECT, this.styleSheet);\n        }\n        var className = componentStyle.generateAndInjectStyles(this.buildExecutionContext(theme, props, attrs), this.styleSheet);\n        if ( true && warnTooManyClasses) warnTooManyClasses(className);\n        return className;\n    };\n    return StyledComponent;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\nfunction createStyledComponent(target, options, rules) {\n    var isTargetStyledComp = isStyledComponent(target);\n    var isClass = !isTag(target);\n    var _options$displayName = options.displayName, displayName = _options$displayName === undefined ? generateDisplayName(target) : _options$displayName, _options$componentId = options.componentId, componentId = _options$componentId === undefined ? generateId(ComponentStyle, options.displayName, options.parentComponentId) : _options$componentId, _options$ParentCompon = options.ParentComponent, ParentComponent = _options$ParentCompon === undefined ? StyledComponent : _options$ParentCompon, _options$attrs = options.attrs, attrs = _options$attrs === undefined ? EMPTY_ARRAY : _options$attrs;\n    var styledComponentId = options.displayName && options.componentId ? escape(options.displayName) + \"-\" + options.componentId : options.componentId || componentId;\n    // fold the underlying StyledComponent attrs up (implicit extend)\n    var finalAttrs = // $FlowFixMe\n    isTargetStyledComp && target.attrs ? Array.prototype.concat(target.attrs, attrs).filter(Boolean) : attrs;\n    var componentStyle = new ComponentStyle(isTargetStyledComp ? // $FlowFixMe\n    target.componentStyle.rules.concat(rules) : rules, finalAttrs, styledComponentId);\n    /**\n   * forwardRef creates a new interim component, which we'll take advantage of\n   * instead of extending ParentComponent to create _another_ interim class\n   */ var WrappedStyledComponent = void 0;\n    var forwardRef = function forwardRef(props, ref) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ParentComponent, _extends({}, props, {\n            forwardedComponent: WrappedStyledComponent,\n            forwardedRef: ref\n        }));\n    };\n    forwardRef.displayName = displayName;\n    WrappedStyledComponent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().forwardRef(forwardRef);\n    WrappedStyledComponent.displayName = displayName;\n    // $FlowFixMe\n    WrappedStyledComponent.attrs = finalAttrs;\n    // $FlowFixMe\n    WrappedStyledComponent.componentStyle = componentStyle;\n    // $FlowFixMe\n    WrappedStyledComponent.foldedComponentIds = isTargetStyledComp ? Array.prototype.concat(target.foldedComponentIds, target.styledComponentId) : EMPTY_ARRAY;\n    // $FlowFixMe\n    WrappedStyledComponent.styledComponentId = styledComponentId;\n    // fold the underlying StyledComponent target up since we folded the styles\n    // $FlowFixMe\n    WrappedStyledComponent.target = isTargetStyledComp ? target.target : target;\n    // $FlowFixMe\n    WrappedStyledComponent.withComponent = function withComponent(tag) {\n        var previousComponentId = options.componentId, optionsToCopy = objectWithoutProperties(options, [\n            \"componentId\"\n        ]);\n        var newComponentId = previousComponentId && previousComponentId + \"-\" + (isTag(tag) ? tag : escape(getComponentName(tag)));\n        var newOptions = _extends({}, optionsToCopy, {\n            attrs: finalAttrs,\n            componentId: newComponentId,\n            ParentComponent: ParentComponent\n        });\n        return createStyledComponent(tag, newOptions, rules);\n    };\n    // $FlowFixMe\n    Object.defineProperty(WrappedStyledComponent, \"defaultProps\", {\n        get: function get$$1() {\n            return this._foldedDefaultProps;\n        },\n        set: function set$$1(obj) {\n            // $FlowFixMe\n            this._foldedDefaultProps = isTargetStyledComp ? (0,merge_anything__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(target.defaultProps, obj) : obj;\n        }\n    });\n    if (true) {\n        // $FlowFixMe\n        WrappedStyledComponent.warnTooManyClasses = createWarnTooManyClasses(displayName);\n    }\n    // $FlowFixMe\n    WrappedStyledComponent.toString = function() {\n        return \".\" + WrappedStyledComponent.styledComponentId;\n    };\n    if (isClass) {\n        hoistNonReactStatics(WrappedStyledComponent, target, {\n            // all SC-specific things should not be hoisted\n            attrs: true,\n            componentStyle: true,\n            displayName: true,\n            foldedComponentIds: true,\n            styledComponentId: true,\n            target: true,\n            withComponent: true\n        });\n    }\n    return WrappedStyledComponent;\n}\n// \n// Thanks to ReactDOMFactories for this handy list!\nvar domElements = [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"base\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"keygen\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meta\",\n    \"meter\",\n    \"nav\",\n    \"noscript\",\n    \"object\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"param\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"script\",\n    \"section\",\n    \"select\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"title\",\n    \"tr\",\n    \"track\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\",\n    // SVG\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"ellipse\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"marker\",\n    \"mask\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"text\",\n    \"tspan\"\n];\n// \nvar styled = function styled(tag) {\n    return constructWithOptions(createStyledComponent, tag);\n};\n// Shorthands for all valid HTML Elements\ndomElements.forEach(function(domElement) {\n    styled[domElement] = styled(domElement);\n});\n// \nvar GlobalStyle = function() {\n    function GlobalStyle(rules, componentId) {\n        classCallCheck(this, GlobalStyle);\n        this.rules = rules;\n        this.componentId = componentId;\n        this.isStatic = isStaticRules(rules, EMPTY_ARRAY);\n        if (!StyleSheet.master.hasId(componentId)) {\n            StyleSheet.master.deferredInject(componentId, []);\n        }\n    }\n    GlobalStyle.prototype.createStyles = function createStyles(executionContext, styleSheet) {\n        var flatCSS = flatten(this.rules, executionContext, styleSheet);\n        var css = stringifyRules(flatCSS, \"\");\n        styleSheet.inject(this.componentId, css);\n    };\n    GlobalStyle.prototype.removeStyles = function removeStyles(styleSheet) {\n        var componentId = this.componentId;\n        if (styleSheet.hasId(componentId)) {\n            styleSheet.remove(componentId);\n        }\n    };\n    // TODO: overwrite in-place instead of remove+create?\n    GlobalStyle.prototype.renderStyles = function renderStyles(executionContext, styleSheet) {\n        this.removeStyles(styleSheet);\n        this.createStyles(executionContext, styleSheet);\n    };\n    return GlobalStyle;\n}();\n// \n// place our cache into shared context so it'll persist between HMRs\nif (IS_BROWSER) {\n    window.scCGSHMRCache = {};\n}\nfunction createGlobalStyle(strings) {\n    for(var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        interpolations[_key - 1] = arguments[_key];\n    }\n    var rules = css.apply(undefined, [\n        strings\n    ].concat(interpolations));\n    var id = \"sc-global-\" + murmurhash(JSON.stringify(rules));\n    var style = new GlobalStyle(rules, id);\n    var GlobalStyleComponent = function(_React$Component) {\n        inherits(GlobalStyleComponent, _React$Component);\n        function GlobalStyleComponent(props) {\n            classCallCheck(this, GlobalStyleComponent);\n            var _this = possibleConstructorReturn(this, _React$Component.call(this, props));\n            var _this$constructor = _this.constructor, globalStyle = _this$constructor.globalStyle, styledComponentId = _this$constructor.styledComponentId;\n            if (IS_BROWSER) {\n                window.scCGSHMRCache[styledComponentId] = (window.scCGSHMRCache[styledComponentId] || 0) + 1;\n            }\n            /**\n       * This fixes HMR compatibility. Don't ask me why, but this combination of\n       * caching the closure variables via statics and then persisting the statics in\n       * state works across HMR where no other combination did. \\_()_/\n       */ _this.state = {\n                globalStyle: globalStyle,\n                styledComponentId: styledComponentId\n            };\n            return _this;\n        }\n        GlobalStyleComponent.prototype.componentWillUnmount = function componentWillUnmount() {\n            if (window.scCGSHMRCache[this.state.styledComponentId]) {\n                window.scCGSHMRCache[this.state.styledComponentId] -= 1;\n            }\n            /**\n       * Depending on the order \"render\" is called this can cause the styles to be lost\n       * until the next render pass of the remaining instance, which may\n       * not be immediate.\n       */ if (window.scCGSHMRCache[this.state.styledComponentId] === 0) {\n                this.state.globalStyle.removeStyles(this.styleSheet);\n            }\n        };\n        GlobalStyleComponent.prototype.render = function render() {\n            var _this2 = this;\n            if ( true && react__WEBPACK_IMPORTED_MODULE_2___default().Children.count(this.props.children)) {\n                // eslint-disable-next-line no-console\n                console.warn(\"The global style component \" + this.state.styledComponentId + \" was given child JSX. createGlobalStyle does not render children.\");\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(StyleSheetConsumer, null, function(styleSheet) {\n                _this2.styleSheet = styleSheet || StyleSheet.master;\n                var globalStyle = _this2.state.globalStyle;\n                if (globalStyle.isStatic) {\n                    globalStyle.renderStyles(STATIC_EXECUTION_CONTEXT, _this2.styleSheet);\n                    return null;\n                } else {\n                    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeConsumer, null, function(theme) {\n                        // $FlowFixMe\n                        var defaultProps = _this2.constructor.defaultProps;\n                        var context = _extends({}, _this2.props);\n                        if (typeof theme !== \"undefined\") {\n                            context.theme = determineTheme(_this2.props, theme, defaultProps);\n                        }\n                        globalStyle.renderStyles(context, _this2.styleSheet);\n                        return null;\n                    });\n                }\n            });\n        };\n        return GlobalStyleComponent;\n    }((react__WEBPACK_IMPORTED_MODULE_2___default().Component));\n    GlobalStyleComponent.globalStyle = style;\n    GlobalStyleComponent.styledComponentId = id;\n    return GlobalStyleComponent;\n}\n// \nvar replaceWhitespace = function replaceWhitespace(str) {\n    return str.replace(/\\s|\\\\n/g, \"\");\n};\nfunction keyframes(strings) {\n    /* Warning if you've used keyframes on React Native */ if ( true && typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n        // eslint-disable-next-line no-console\n        console.warn(\"`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.\");\n    }\n    for(var _len = arguments.length, interpolations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        interpolations[_key - 1] = arguments[_key];\n    }\n    var rules = css.apply(undefined, [\n        strings\n    ].concat(interpolations));\n    var name = generateAlphabeticName(murmurhash(replaceWhitespace(JSON.stringify(rules))));\n    return new Keyframes(name, stringifyRules(rules, name, \"@keyframes\"));\n}\n// \nvar withTheme = function(Component$$1) {\n    var WithTheme = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().forwardRef(function(props, ref) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(ThemeConsumer, null, function(theme) {\n            // $FlowFixMe\n            var defaultProps = Component$$1.defaultProps;\n            var themeProp = determineTheme(props, theme, defaultProps);\n            if ( true && themeProp === undefined) {\n                // eslint-disable-next-line no-console\n                console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class \"' + getComponentName(Component$$1) + '\"');\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createElement(Component$$1, _extends({}, props, {\n                theme: themeProp,\n                ref: ref\n            }));\n        });\n    });\n    hoistNonReactStatics(WithTheme, Component$$1);\n    WithTheme.displayName = \"WithTheme(\" + getComponentName(Component$$1) + \")\";\n    return WithTheme;\n};\n// \n/* eslint-disable */ var __DO_NOT_USE_OR_YOU_WILL_BE_HAUNTED_BY_SPOOKY_GHOSTS = {\n    StyleSheet: StyleSheet\n};\n// \n/* Warning if you've imported this file on React Native */ if ( true && typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    // eslint-disable-next-line no-console\n    console.warn(\"It looks like you've imported 'styled-components' on React Native.\\n\" + \"Perhaps you're looking to import 'styled-components/native'?\\n\" + \"Read more about this at https://www.styled-components.com/docs/basics#react-native\");\n}\n/* Warning if there are several instances of styled-components */ if (false) {}\n//\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (styled);\n //# sourceMappingURL=styled-components.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9kaXN0L3N0eWxlZC1jb21wb25lbnRzLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1QztBQUNXO0FBQ21DO0FBQzVDO0FBQzRCO0FBQ25DO0FBQ047QUFDTztBQUNZO0FBQ1o7QUFFbkMsR0FBRztBQUVILElBQUlnQixhQUFjLFNBQVVDLE9BQU8sRUFBRUMsY0FBYztJQUNqRCxJQUFJQyxTQUFTO1FBQUNGLE9BQU8sQ0FBQyxFQUFFO0tBQUM7SUFFekIsSUFBSyxJQUFJRyxJQUFJLEdBQUdDLE1BQU1ILGVBQWVJLE1BQU0sRUFBRUYsSUFBSUMsS0FBS0QsS0FBSyxFQUFHO1FBQzVERCxPQUFPSSxJQUFJLENBQUNMLGNBQWMsQ0FBQ0UsRUFBRSxFQUFFSCxPQUFPLENBQUNHLElBQUksRUFBRTtJQUMvQztJQUVBLE9BQU9EO0FBQ1Q7QUFFQSxJQUFJSyxVQUFVLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssV0FBVyxTQUFVQyxHQUFHO0lBQy9GLE9BQU8sT0FBT0E7QUFDaEIsSUFBSSxTQUFVQSxHQUFHO0lBQ2YsT0FBT0EsT0FBTyxPQUFPRixXQUFXLGNBQWNFLElBQUlDLFdBQVcsS0FBS0gsVUFBVUUsUUFBUUYsT0FBT0ksU0FBUyxHQUFHLFdBQVcsT0FBT0Y7QUFDM0g7QUFFQSxJQUFJRyxpQkFBaUIsU0FBVUMsUUFBUSxFQUFFQyxXQUFXO0lBQ2xELElBQUksQ0FBRUQsQ0FBQUEsb0JBQW9CQyxXQUFVLEdBQUk7UUFDdEMsTUFBTSxJQUFJQyxVQUFVO0lBQ3RCO0FBQ0Y7QUFFQSxJQUFJQyxjQUFjO0lBQ2hCLFNBQVNDLGlCQUFpQkMsTUFBTSxFQUFFQyxLQUFLO1FBQ3JDLElBQUssSUFBSWpCLElBQUksR0FBR0EsSUFBSWlCLE1BQU1mLE1BQU0sRUFB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SDVQLGlCQUFpQmljLGdCQUFnQjtZQUMzSztZQUVBLHFCQUFPeGdCLDBEQUFtQixDQUFDd2dCLGNBQWMzZCxTQUFTLENBQUMsR0FBR1YsT0FBTztnQkFBRWtVLE9BQU9xSztnQkFBV3hELEtBQUtBO1lBQUk7UUFDNUY7SUFFSjtJQUVBaEYscUJBQXFCdUksV0FBV0Q7SUFFaENDLFVBQVVoYyxXQUFXLEdBQUcsZUFBZUYsaUJBQWlCaWMsZ0JBQWdCO0lBRXhFLE9BQU9DO0FBQ1Q7QUFFQSxHQUFHO0FBRUgsa0JBQWtCLEdBQ2xCLElBQUlFLHVEQUF1RDtJQUN6RHBRLFlBQVlBO0FBQ2Q7QUFFQSxHQUFHO0FBRUgsd0RBQXdELEdBQ3hELElBQUkvTCxLQUF5QixJQUFnQixPQUFPNmIsY0FBYyxlQUFlQSxVQUFVQyxPQUFPLEtBQUssZUFBZTtJQUNwSCxzQ0FBc0M7SUFDdENwTSxRQUFRQyxJQUFJLENBQUMseUVBQXlFLG1FQUFtRTtBQUMzSjtBQUVBLCtEQUErRCxHQUMvRCxJQUFJM1AsS0FBd1IsRUFBRSxFQVM3UjtBQUVELEVBQUU7QUFFRixpRUFBZTBhLE1BQU1BLEVBQUM7QUFDbU8sQ0FDelAsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29kZV9jdWJpY2xlXzMvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9zdHlsZWQtY29tcG9uZW50cy9kaXN0L3N0eWxlZC1jb21wb25lbnRzLmVzbS5qcz84NTQwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdHlsaXMgZnJvbSAnc3R5bGlzL3N0eWxpcy5taW4nO1xuaW1wb3J0IF9pbnNlcnRSdWxlUGx1Z2luIGZyb20gJ3N0eWxpcy1ydWxlLXNoZWV0JztcbmltcG9ydCBSZWFjdCwgeyBjbG9uZUVsZW1lbnQsIGNyZWF0ZUNvbnRleHQsIENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1bml0bGVzcyBmcm9tICdAZW1vdGlvbi91bml0bGVzcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzVmFsaWRFbGVtZW50VHlwZSwgRm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCBtZW1vaXplIGZyb20gJ21lbW9pemUtb25lJztcbmltcG9ydCBzdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgdmFsaWRBdHRyIGZyb20gJ0BlbW90aW9uL2lzLXByb3AtdmFsaWQnO1xuaW1wb3J0IG1lcmdlIGZyb20gJ21lcmdlLWFueXRoaW5nJztcblxuLy8gXG5cbnZhciBpbnRlcmxlYXZlID0gKGZ1bmN0aW9uIChzdHJpbmdzLCBpbnRlcnBvbGF0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gW3N0cmluZ3NbMF1dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpbnRlcnBvbGF0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgIHJlc3VsdC5wdXNoKGludGVycG9sYXRpb25zW2ldLCBzdHJpbmdzW2kgKyAxXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGluaGVyaXRzID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTtcblxudmFyIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iaiwga2V5cykge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlO1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlO1xuICAgIHRhcmdldFtpXSA9IG9ialtpXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTtcblxuLy8gXG52YXIgaXNQbGFpbk9iamVjdCA9IChmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gKHR5cGVvZiB4ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih4KSkgPT09ICdvYmplY3QnICYmIHguY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn0pO1xuXG4vLyBcbnZhciBFTVBUWV9BUlJBWSA9IE9iamVjdC5mcmVlemUoW10pO1xudmFyIEVNUFRZX09CSkVDVCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG4vLyBcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odGVzdCkge1xuICByZXR1cm4gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbic7XG59XG5cbi8vIFxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHRhcmdldCkge1xuICByZXR1cm4gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyAmJiB0YXJnZXQgOiBmYWxzZSkgfHwgdGFyZ2V0LmRpc3BsYXlOYW1lIHx8IHRhcmdldC5uYW1lIHx8ICdDb21wb25lbnQnO1xufVxuXG4vLyBcbmZ1bmN0aW9uIGlzU3RhdGVsZXNzRnVuY3Rpb24odGVzdCkge1xuICByZXR1cm4gdHlwZW9mIHRlc3QgPT09ICdmdW5jdGlvbicgJiYgISh0ZXN0LnByb3RvdHlwZSAmJiB0ZXN0LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gXG5mdW5jdGlvbiBpc1N0eWxlZENvbXBvbmVudCh0YXJnZXQpIHtcbiAgcmV0dXJuIHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0LnN0eWxlZENvbXBvbmVudElkID09PSAnc3RyaW5nJztcbn1cblxuLy8gXG5cbnZhciBTQ19BVFRSID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIChwcm9jZXNzLmVudi5SRUFDVF9BUFBfU0NfQVRUUiB8fCBwcm9jZXNzLmVudi5TQ19BVFRSKSB8fCAnZGF0YS1zdHlsZWQnO1xuXG52YXIgU0NfVkVSU0lPTl9BVFRSID0gJ2RhdGEtc3R5bGVkLXZlcnNpb24nO1xuXG52YXIgU0NfU1RSRUFNX0FUVFIgPSAnZGF0YS1zdHlsZWQtc3RyZWFtZWQnO1xuXG52YXIgSVNfQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdIVE1MRWxlbWVudCcgaW4gd2luZG93O1xuXG52YXIgRElTQUJMRV9TUEVFRFkgPSB0eXBlb2YgU0NfRElTQUJMRV9TUEVFRFkgPT09ICdib29sZWFuJyAmJiBTQ19ESVNBQkxFX1NQRUVEWSB8fCB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHByb2Nlc3MuZW52LlJFQUNUX0FQUF9TQ19ESVNBQkxFX1NQRUVEWSB8fCBwcm9jZXNzLmVudi5TQ19ESVNBQkxFX1NQRUVEWSkgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcblxuLy8gU2hhcmVkIGVtcHR5IGV4ZWN1dGlvbiBjb250ZXh0IHdoZW4gZ2VuZXJhdGluZyBzdGF0aWMgc3R5bGVzXG52YXIgU1RBVElDX0VYRUNVVElPTl9DT05URVhUID0ge307XG5cbi8vIFxuXG5cbi8qKlxuICogUGFyc2UgZXJyb3JzLm1kIGFuZCB0dXJuIGl0IGludG8gYSBzaW1wbGUgaGFzaCBvZiBjb2RlOiBtZXNzYWdlXG4gKi9cbnZhciBFUlJPUlMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8ge1xuICBcIjFcIjogXCJDYW5ub3QgY3JlYXRlIHN0eWxlZC1jb21wb25lbnQgZm9yIGNvbXBvbmVudDogJXMuXFxuXFxuXCIsXG4gIFwiMlwiOiBcIkNhbid0IGNvbGxlY3Qgc3R5bGVzIG9uY2UgeW91J3ZlIGNvbnN1bWVkIGEgYFNlcnZlclN0eWxlU2hlZXRgJ3Mgc3R5bGVzISBgU2VydmVyU3R5bGVTaGVldGAgaXMgYSBvbmUgb2ZmIGluc3RhbmNlIGZvciBlYWNoIHNlcnZlci1zaWRlIHJlbmRlciBjeWNsZS5cXG5cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJldXNlIGl0IGFjcm9zcyByZW5kZXJzP1xcbi0gQXJlIHlvdSBhY2NpZGVudGFsbHkgY2FsbGluZyBjb2xsZWN0U3R5bGVzIHR3aWNlP1xcblxcblwiLFxuICBcIjNcIjogXCJTdHJlYW1pbmcgU1NSIGlzIG9ubHkgc3VwcG9ydGVkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudDsgUGxlYXNlIGRvIG5vdCB0cnkgdG8gY2FsbCB0aGlzIG1ldGhvZCBpbiB0aGUgYnJvd3Nlci5cXG5cXG5cIixcbiAgXCI0XCI6IFwiVGhlIGBTdHlsZVNoZWV0TWFuYWdlcmAgZXhwZWN0cyBhIHZhbGlkIHRhcmdldCBvciBzaGVldCBwcm9wIVxcblxcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBjbGllbnQgYW5kIGlzIHlvdXIgdGFyZ2V0IGZhbHN5P1xcbi0gRG9lcyB0aGlzIGVycm9yIG9jY3VyIG9uIHRoZSBzZXJ2ZXIgYW5kIGlzIHRoZSBzaGVldCBmYWxzeT9cXG5cXG5cIixcbiAgXCI1XCI6IFwiVGhlIGNsb25lIG1ldGhvZCBjYW5ub3QgYmUgdXNlZCBvbiB0aGUgY2xpZW50IVxcblxcbi0gQXJlIHlvdSBydW5uaW5nIGluIGEgY2xpZW50LWxpa2UgZW52aXJvbm1lbnQgb24gdGhlIHNlcnZlcj9cXG4tIEFyZSB5b3UgdHJ5aW5nIHRvIHJ1biBTU1Igb24gdGhlIGNsaWVudD9cXG5cXG5cIixcbiAgXCI2XCI6IFwiVHJ5aW5nIHRvIGluc2VydCBhIG5ldyBzdHlsZSB0YWcsIGJ1dCB0aGUgZ2l2ZW4gTm9kZSBpcyB1bm1vdW50ZWQhXFxuXFxuLSBBcmUgeW91IHVzaW5nIGEgY3VzdG9tIHRhcmdldCB0aGF0IGlzbid0IG1vdW50ZWQ/XFxuLSBEb2VzIHlvdXIgZG9jdW1lbnQgbm90IGhhdmUgYSB2YWxpZCBoZWFkIGVsZW1lbnQ/XFxuLSBIYXZlIHlvdSBhY2NpZGVudGFsbHkgcmVtb3ZlZCBhIHN0eWxlIHRhZyBtYW51YWxseT9cXG5cXG5cIixcbiAgXCI3XCI6IFwiVGhlbWVQcm92aWRlcjogUGxlYXNlIHJldHVybiBhbiBvYmplY3QgZnJvbSB5b3VyIFxcXCJ0aGVtZVxcXCIgcHJvcCBmdW5jdGlvbiwgZS5nLlxcblxcbmBgYGpzXFxudGhlbWU9eygpID0+ICh7fSl9XFxuYGBgXFxuXFxuXCIsXG4gIFwiOFwiOiBcIlRoZW1lUHJvdmlkZXI6IFBsZWFzZSBtYWtlIHlvdXIgXFxcInRoZW1lXFxcIiBwcm9wIGFuIG9iamVjdC5cXG5cXG5cIixcbiAgXCI5XCI6IFwiTWlzc2luZyBkb2N1bWVudCBgPGhlYWQ+YFxcblxcblwiLFxuICBcIjEwXCI6IFwiQ2Fubm90IGZpbmQgYSBTdHlsZVNoZWV0IGluc3RhbmNlLiBVc3VhbGx5IHRoaXMgaGFwcGVucyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgY29waWVzIG9mIHN0eWxlZC1jb21wb25lbnRzIGxvYWRlZCBhdCBvbmNlLiBDaGVjayBvdXQgdGhpcyBpc3N1ZSBmb3IgaG93IHRvIHRyb3VibGVzaG9vdCBhbmQgZml4IHRoZSBjb21tb24gY2FzZXMgd2hlcmUgdGhpcyBzaXR1YXRpb24gY2FuIGhhcHBlbjogaHR0cHM6Ly9naXRodWIuY29tL3N0eWxlZC1jb21wb25lbnRzL3N0eWxlZC1jb21wb25lbnRzL2lzc3Vlcy8xOTQxI2lzc3VlY29tbWVudC00MTc4NjIwMjFcXG5cXG5cIixcbiAgXCIxMVwiOiBcIl9UaGlzIGVycm9yIHdhcyByZXBsYWNlZCB3aXRoIGEgZGV2LXRpbWUgd2FybmluZywgaXQgd2lsbCBiZSBkZWxldGVkIGZvciB2NCBmaW5hbC5fIFtjcmVhdGVHbG9iYWxTdHlsZV0gcmVjZWl2ZWQgY2hpbGRyZW4gd2hpY2ggd2lsbCBub3QgYmUgcmVuZGVyZWQuIFBsZWFzZSB1c2UgdGhlIGNvbXBvbmVudCB3aXRob3V0IHBhc3NpbmcgY2hpbGRyZW4gZWxlbWVudHMuXFxuXFxuXCIsXG4gIFwiMTJcIjogXCJJdCBzZWVtcyB5b3UgYXJlIGludGVycG9sYXRpbmcgYSBrZXlmcmFtZSBkZWNsYXJhdGlvbiAoJXMpIGludG8gYW4gdW50YWdnZWQgc3RyaW5nLiBUaGlzIHdhcyBzdXBwb3J0ZWQgaW4gc3R5bGVkLWNvbXBvbmVudHMgdjMsIGJ1dCBpcyBub3QgbG9uZ2VyIHN1cHBvcnRlZCBpbiB2NCBhcyBrZXlmcmFtZXMgYXJlIG5vdyBpbmplY3RlZCBvbi1kZW1hbmQuIFBsZWFzZSB3cmFwIHlvdXIgc3RyaW5nIGluIHRoZSBjc3NcXFxcYFxcXFxgIGhlbHBlciB3aGljaCBlbnN1cmVzIHRoZSBzdHlsZXMgYXJlIGluamVjdGVkIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FwaSNjc3NcXG5cXG5cIixcbiAgXCIxM1wiOiBcIiVzIGlzIG5vdCBhIHN0eWxlZCBjb21wb25lbnQgYW5kIGNhbm5vdCBiZSByZWZlcnJlZCB0byB2aWEgY29tcG9uZW50IHNlbGVjdG9yLiBTZWUgaHR0cHM6Ly93d3cuc3R5bGVkLWNvbXBvbmVudHMuY29tL2RvY3MvYWR2YW5jZWQjcmVmZXJyaW5nLXRvLW90aGVyLWNvbXBvbmVudHMgZm9yIG1vcmUgZGV0YWlscy5cXG5cIlxufSA6IHt9O1xuXG4vKipcbiAqIHN1cGVyIGJhc2ljIHZlcnNpb24gb2Ygc3ByaW50ZlxuICovXG5mdW5jdGlvbiBmb3JtYXQoKSB7XG4gIHZhciBhID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdO1xuICB2YXIgYiA9IFtdO1xuXG4gIGZvciAodmFyIGMgPSAxLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoOyBjIDwgbGVuOyBjICs9IDEpIHtcbiAgICBiLnB1c2goYXJndW1lbnRzLmxlbmd0aCA8PSBjID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2NdKTtcbiAgfVxuXG4gIGIuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgIGEgPSBhLnJlcGxhY2UoLyVbYS16XS8sIGQpO1xuICB9KTtcblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXJyb3IgZmlsZSBvdXQgb2YgZXJyb3JzLm1kIGZvciBkZXZlbG9wbWVudCBhbmQgYSBzaW1wbGUgd2ViIGxpbmsgdG8gdGhlIGZ1bGwgZXJyb3JzXG4gKiBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gKi9cblxudmFyIFN0eWxlZENvbXBvbmVudHNFcnJvciA9IGZ1bmN0aW9uIChfRXJyb3IpIHtcbiAgaW5oZXJpdHMoU3R5bGVkQ29tcG9uZW50c0Vycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFN0eWxlZENvbXBvbmVudHNFcnJvcihjb2RlKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVkQ29tcG9uZW50c0Vycm9yKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnRlcnBvbGF0aW9ucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGludGVycG9sYXRpb25zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXJyb3IuY2FsbCh0aGlzLCAnQW4gZXJyb3Igb2NjdXJyZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3R5bGVkLWNvbXBvbmVudHMvc3R5bGVkLWNvbXBvbmVudHMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc3R5bGVkLWNvbXBvbmVudHMvc3JjL3V0aWxzL2Vycm9ycy5tZCMnICsgY29kZSArICcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyArIChpbnRlcnBvbGF0aW9ucy5sZW5ndGggPiAwID8gJyBBZGRpdGlvbmFsIGFyZ3VtZW50czogJyArIGludGVycG9sYXRpb25zLmpvaW4oJywgJykgOiAnJykpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfRXJyb3IuY2FsbCh0aGlzLCBmb3JtYXQuYXBwbHkodW5kZWZpbmVkLCBbRVJST1JTW2NvZGVdXS5jb25jYXQoaW50ZXJwb2xhdGlvbnMpKS50cmltKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMpO1xuICB9XG5cbiAgcmV0dXJuIFN0eWxlZENvbXBvbmVudHNFcnJvcjtcbn0oRXJyb3IpO1xuXG4vLyBcbnZhciBTQ19DT01QT05FTlRfSUQgPSAvXlteXFxTXFxuXSo/XFwvXFwqIHNjLWNvbXBvbmVudC1pZDpcXHMqKFxcUyspXFxzK1xcKlxcLy9nbTtcblxudmFyIGV4dHJhY3RDb21wcyA9IChmdW5jdGlvbiAobWF5YmVDU1MpIHtcbiAgdmFyIGNzcyA9ICcnICsgKG1heWJlQ1NTIHx8ICcnKTsgLy8gRGVmaW5pdGVseSBhIHN0cmluZywgYW5kIGEgY2xvbmVcbiAgdmFyIGV4aXN0aW5nQ29tcG9uZW50cyA9IFtdO1xuICBjc3MucmVwbGFjZShTQ19DT01QT05FTlRfSUQsIGZ1bmN0aW9uIChtYXRjaCwgY29tcG9uZW50SWQsIG1hdGNoSW5kZXgpIHtcbiAgICBleGlzdGluZ0NvbXBvbmVudHMucHVzaCh7IGNvbXBvbmVudElkOiBjb21wb25lbnRJZCwgbWF0Y2hJbmRleDogbWF0Y2hJbmRleCB9KTtcbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuICByZXR1cm4gZXhpc3RpbmdDb21wb25lbnRzLm1hcChmdW5jdGlvbiAoX3JlZiwgaSkge1xuICAgIHZhciBjb21wb25lbnRJZCA9IF9yZWYuY29tcG9uZW50SWQsXG4gICAgICAgIG1hdGNoSW5kZXggPSBfcmVmLm1hdGNoSW5kZXg7XG5cbiAgICB2YXIgbmV4dENvbXAgPSBleGlzdGluZ0NvbXBvbmVudHNbaSArIDFdO1xuICAgIHZhciBjc3NGcm9tRE9NID0gbmV4dENvbXAgPyBjc3Muc2xpY2UobWF0Y2hJbmRleCwgbmV4dENvbXAubWF0Y2hJbmRleCkgOiBjc3Muc2xpY2UobWF0Y2hJbmRleCk7XG4gICAgcmV0dXJuIHsgY29tcG9uZW50SWQ6IGNvbXBvbmVudElkLCBjc3NGcm9tRE9NOiBjc3NGcm9tRE9NIH07XG4gIH0pO1xufSk7XG5cbi8vIFxuXG52YXIgQ09NTUVOVF9SRUdFWCA9IC9eXFxzKlxcL1xcLy4qJC9nbTtcblxuLy8gTk9URTogVGhpcyBzdHlsaXMgaW5zdGFuY2UgaXMgb25seSB1c2VkIHRvIHNwbGl0IHJ1bGVzIGZyb20gU1NSJ2Qgc3R5bGUgdGFnc1xudmFyIHN0eWxpc1NwbGl0dGVyID0gbmV3IFN0eWxpcyh7XG4gIGdsb2JhbDogZmFsc2UsXG4gIGNhc2NhZGU6IHRydWUsXG4gIGtleWZyYW1lOiBmYWxzZSxcbiAgcHJlZml4OiBmYWxzZSxcbiAgY29tcHJlc3M6IGZhbHNlLFxuICBzZW1pY29sb246IHRydWVcbn0pO1xuXG52YXIgc3R5bGlzID0gbmV3IFN0eWxpcyh7XG4gIGdsb2JhbDogZmFsc2UsXG4gIGNhc2NhZGU6IHRydWUsXG4gIGtleWZyYW1lOiBmYWxzZSxcbiAgcHJlZml4OiB0cnVlLFxuICBjb21wcmVzczogZmFsc2UsXG4gIHNlbWljb2xvbjogZmFsc2UgLy8gTk9URTogVGhpcyBtZWFucyBcImF1dG9jb21wbGV0ZSBtaXNzaW5nIHNlbWljb2xvbnNcIlxufSk7XG5cbi8vIFdyYXAgYGluc2VydFJ1bGVQbHVnaW4gdG8gYnVpbGQgYSBsaXN0IG9mIHJ1bGVzLFxuLy8gYW5kIHRoZW4gbWFrZSBvdXIgb3duIHBsdWdpbiB0byByZXR1cm4gdGhlIHJ1bGVzLiBUaGlzXG4vLyBtYWtlcyBpdCBlYXNpZXIgdG8gaG9vayBpbnRvIHRoZSBleGlzdGluZyBTU1IgYXJjaGl0ZWN0dXJlXG5cbnZhciBwYXJzaW5nUnVsZXMgPSBbXTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG52YXIgcmV0dXJuUnVsZXNQbHVnaW4gPSBmdW5jdGlvbiByZXR1cm5SdWxlc1BsdWdpbihjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0ID09PSAtMikge1xuICAgIHZhciBwYXJzZWRSdWxlcyA9IHBhcnNpbmdSdWxlcztcbiAgICBwYXJzaW5nUnVsZXMgPSBbXTtcbiAgICByZXR1cm4gcGFyc2VkUnVsZXM7XG4gIH1cbn07XG5cbnZhciBwYXJzZVJ1bGVzUGx1Z2luID0gX2luc2VydFJ1bGVQbHVnaW4oZnVuY3Rpb24gKHJ1bGUpIHtcbiAgcGFyc2luZ1J1bGVzLnB1c2gocnVsZSk7XG59KTtcblxudmFyIF9jb21wb25lbnRJZCA9IHZvaWQgMDtcbnZhciBfc2VsZWN0b3IgPSB2b2lkIDA7XG52YXIgX3NlbGVjdG9yUmVnZXhwID0gdm9pZCAwO1xuXG52YXIgc2VsZlJlZmVyZW5jZVJlcGxhY2VyID0gZnVuY3Rpb24gc2VsZlJlZmVyZW5jZVJlcGxhY2VyKG1hdGNoLCBvZmZzZXQsIHN0cmluZykge1xuICBpZiAoXG4gIC8vIHRoZSBmaXJzdCBzZWxmLXJlZiBpcyBhbHdheXMgdW50b3VjaGVkXG4gIG9mZnNldCA+IDAgJiZcbiAgLy8gdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IHR3byBzZWxmLXJlZnMgdG8gZG8gYSByZXBsYWNlbWVudCAoLmIgPiAuYilcbiAgc3RyaW5nLnNsaWNlKDAsIG9mZnNldCkuaW5kZXhPZihfc2VsZWN0b3IpICE9PSAtMSAmJlxuICAvLyBubyBjb25zZWN1dGl2ZSBzZWxmIHJlZnMgKC5iLmIpOyB0aGF0IGlzIGEgcHJlY2VkZW5jZSBib29zdCBhbmQgdHJlYXRlZCBkaWZmZXJlbnRseVxuICBzdHJpbmcuc2xpY2Uob2Zmc2V0IC0gX3NlbGVjdG9yLmxlbmd0aCwgb2Zmc2V0KSAhPT0gX3NlbGVjdG9yKSB7XG4gICAgcmV0dXJuICcuJyArIF9jb21wb25lbnRJZDtcbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn07XG5cbi8qKlxuICogV2hlbiB3cml0aW5nIGEgc3R5bGUgbGlrZVxuICpcbiAqICYgKyAmIHtcbiAqICAgY29sb3I6IHJlZDtcbiAqIH1cbiAqXG4gKiBUaGUgc2Vjb25kIGFtcGVyc2FuZCBzaG91bGQgYmUgYSByZWZlcmVuY2UgdG8gdGhlIHN0YXRpYyBjb21wb25lbnQgY2xhc3MuIHN0eWxpc1xuICogaGFzIG5vIGtub3dsZWRnZSBvZiBzdGF0aWMgY2xhc3Mgc28gd2UgaGF2ZSB0byBpbnRlbGxpZ2VudGx5IHJlcGxhY2UgdGhlIGJhc2Ugc2VsZWN0b3IuXG4gKi9cbnZhciBzZWxmUmVmZXJlbmNlUmVwbGFjZW1lbnRQbHVnaW4gPSBmdW5jdGlvbiBzZWxmUmVmZXJlbmNlUmVwbGFjZW1lbnRQbHVnaW4oY29udGV4dCwgXywgc2VsZWN0b3JzKSB7XG4gIGlmIChjb250ZXh0ID09PSAyICYmIHNlbGVjdG9ycy5sZW5ndGggJiYgc2VsZWN0b3JzWzBdLmxhc3RJbmRleE9mKF9zZWxlY3RvcikgPiAwKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgc2VsZWN0b3JzWzBdID0gc2VsZWN0b3JzWzBdLnJlcGxhY2UoX3NlbGVjdG9yUmVnZXhwLCBzZWxmUmVmZXJlbmNlUmVwbGFjZXIpO1xuICB9XG59O1xuXG5zdHlsaXMudXNlKFtzZWxmUmVmZXJlbmNlUmVwbGFjZW1lbnRQbHVnaW4sIHBhcnNlUnVsZXNQbHVnaW4sIHJldHVyblJ1bGVzUGx1Z2luXSk7XG5zdHlsaXNTcGxpdHRlci51c2UoW3BhcnNlUnVsZXNQbHVnaW4sIHJldHVyblJ1bGVzUGx1Z2luXSk7XG5cbnZhciBzcGxpdEJ5UnVsZXMgPSBmdW5jdGlvbiBzcGxpdEJ5UnVsZXMoY3NzKSB7XG4gIHJldHVybiBzdHlsaXNTcGxpdHRlcignJywgY3NzKTtcbn07XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVJ1bGVzKHJ1bGVzLCBzZWxlY3RvciwgcHJlZml4KSB7XG4gIHZhciBjb21wb25lbnRJZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogJyYnO1xuXG4gIHZhciBmbGF0Q1NTID0gcnVsZXMuam9pbignJykucmVwbGFjZShDT01NRU5UX1JFR0VYLCAnJyk7IC8vIHJlcGxhY2UgSlMgY29tbWVudHNcblxuICB2YXIgY3NzU3RyID0gc2VsZWN0b3IgJiYgcHJlZml4ID8gcHJlZml4ICsgJyAnICsgc2VsZWN0b3IgKyAnIHsgJyArIGZsYXRDU1MgKyAnIH0nIDogZmxhdENTUztcblxuICAvLyBzdHlsaXMgaGFzIG5vIGNvbmNlcHQgb2Ygc3RhdGUgdG8gYmUgcGFzc2VkIHRvIHBsdWdpbnNcbiAgLy8gYnV0IHNpbmNlIEpTIGlzIHNpbmdsZT10aHJlYWRlZCwgd2UgY2FuIHJlbHkgb24gdGhhdCB0byBlbnN1cmVcbiAgLy8gdGhlc2UgcHJvcGVydGllcyBzdGF5IGluIHN5bmMgd2l0aCB0aGUgY3VycmVudCBzdHlsaXMgcnVuXG4gIF9jb21wb25lbnRJZCA9IGNvbXBvbmVudElkO1xuICBfc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgX3NlbGVjdG9yUmVnZXhwID0gbmV3IFJlZ0V4cCgnXFxcXCcgKyBfc2VsZWN0b3IgKyAnXFxcXGInLCAnZycpO1xuXG4gIHJldHVybiBzdHlsaXMocHJlZml4IHx8ICFzZWxlY3RvciA/ICcnIDogc2VsZWN0b3IsIGNzc1N0cik7XG59XG5cbi8vIFxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlLCBuby11bmRlZiAqL1xuXG52YXIgZ2V0Tm9uY2UgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIF9fd2VicGFja19ub25jZV9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbn0pO1xuXG4vLyBcbi8qIFRoZXNlIGFyZSBoZWxwZXJzIGZvciB0aGUgU3R5bGVUYWdzIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGluamVjdGVkXG4gKiBydWxlIG5hbWVzIGZvciBlYWNoIChjb21wb25lbnQpIElEIHRoYXQgdGhleSdyZSBrZWVwaW5nIHRyYWNrIG9mLlxuICogVGhleSdyZSBjcnVjaWFsIGZvciBkZXRlY3Rpbmcgd2hldGhlciBhIG5hbWUgaGFzIGFscmVhZHkgYmVlblxuICogaW5qZWN0ZWQuXG4gKiAoVGhpcyBleGNsdWRlcyByZWh5ZHJhdGVkIG5hbWVzKSAqL1xuXG4vKiBhZGRzIGEgbmV3IElEOm5hbWUgcGFpcmluZyB0byBhIG5hbWVzIGRpY3Rpb25hcnkgKi9cbnZhciBhZGROYW1lRm9ySWQgPSBmdW5jdGlvbiBhZGROYW1lRm9ySWQobmFtZXMsIGlkLCBuYW1lKSB7XG4gIGlmIChuYW1lKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgdmFyIG5hbWVzRm9ySWQgPSBuYW1lc1tpZF0gfHwgKG5hbWVzW2lkXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIG5hbWVzRm9ySWRbbmFtZV0gPSB0cnVlO1xuICB9XG59O1xuXG4vKiByZXNldHMgYW4gSUQgZW50aXJlbHkgYnkgb3ZlcndyaXRpbmcgaXQgaW4gdGhlIGRpY3Rpb25hcnkgKi9cbnZhciByZXNldElkTmFtZXMgPSBmdW5jdGlvbiByZXNldElkTmFtZXMobmFtZXMsIGlkKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBuYW1lc1tpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xufTtcblxuLyogZmFjdG9yeSBmb3IgYSBuYW1lcyBkaWN0aW9uYXJ5IGNoZWNraW5nIHRoZSBleGlzdGFuY2Ugb2YgYW4gSUQ6bmFtZSBwYWlyaW5nICovXG52YXIgaGFzTmFtZUZvcklkID0gZnVuY3Rpb24gaGFzTmFtZUZvcklkKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaWQsIG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZXNbaWRdICE9PSB1bmRlZmluZWQgJiYgbmFtZXNbaWRdW25hbWVdO1xuICB9O1xufTtcblxuLyogc3RyaW5naWZpZXMgbmFtZXMgZm9yIHRoZSBodG1sL2VsZW1lbnQgb3V0cHV0ICovXG52YXIgc3RyaW5naWZ5TmFtZXMgPSBmdW5jdGlvbiBzdHJpbmdpZnlOYW1lcyhuYW1lcykge1xuICB2YXIgc3RyID0gJyc7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgZm9yICh2YXIgaWQgaW4gbmFtZXMpIHtcbiAgICBzdHIgKz0gT2JqZWN0LmtleXMobmFtZXNbaWRdKS5qb2luKCcgJykgKyAnICc7XG4gIH1cbiAgcmV0dXJuIHN0ci50cmltKCk7XG59O1xuXG4vKiBjbG9uZXMgdGhlIG5lc3RlZCBuYW1lcyBkaWN0aW9uYXJ5ICovXG52YXIgY2xvbmVOYW1lcyA9IGZ1bmN0aW9uIGNsb25lTmFtZXMobmFtZXMpIHtcbiAgdmFyIGNsb25lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICBmb3IgKHZhciBpZCBpbiBuYW1lcykge1xuICAgIGNsb25lW2lkXSA9IF9leHRlbmRzKHt9LCBuYW1lc1tpZF0pO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbn07XG5cbi8vIFxuXG4vKiBUaGVzZSBhcmUgaGVscGVycyB0aGF0IGRlYWwgd2l0aCB0aGUgaW5zZXJ0UnVsZSAoYWthIHNwZWVkeSkgQVBJXG4gKiBUaGV5IGFyZSB1c2VkIGluIHRoZSBTdHlsZVRhZ3MgYW5kIHNwZWNpZmljYWxseSB0aGUgc3BlZWR5IHRhZ1xuICovXG5cbi8qIHJldHJpZXZlIGEgc2hlZXQgZm9yIGEgZ2l2ZW4gc3R5bGUgdGFnICovXG52YXIgc2hlZXRGb3JUYWcgPSBmdW5jdGlvbiBzaGVldEZvclRhZyh0YWcpIHtcbiAgLy8gJEZsb3dGaXhNZVxuICBpZiAodGFnLnNoZWV0KSByZXR1cm4gdGFnLnNoZWV0O1xuXG4gIC8qIEZpcmVmb3ggcXVpcmsgcmVxdWlyZXMgdXMgdG8gc3RlcCB0aHJvdWdoIGFsbCBzdHlsZXNoZWV0cyB0byBmaW5kIG9uZSBvd25lZCBieSB0aGUgZ2l2ZW4gdGFnICovXG4gIHZhciBzaXplID0gdGFnLm93bmVyRG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkgKz0gMSkge1xuICAgIHZhciBzaGVldCA9IHRhZy5vd25lckRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBpZiAoc2hlZXQub3duZXJOb2RlID09PSB0YWcpIHJldHVybiBzaGVldDtcbiAgfVxuXG4gIC8qIHdlIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBmaW5kIGEgdGFnICovXG4gIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoMTApO1xufTtcblxuLyogaW5zZXJ0IGEgcnVsZSBzYWZlbHkgYW5kIHJldHVybiB3aGV0aGVyIGl0IHdhcyBhY3R1YWxseSBpbmplY3RlZCAqL1xudmFyIHNhZmVJbnNlcnRSdWxlID0gZnVuY3Rpb24gc2FmZUluc2VydFJ1bGUoc2hlZXQsIGNzc1J1bGUsIGluZGV4KSB7XG4gIC8qIGFib3J0IGVhcmx5IGlmIGNzc1J1bGUgc3RyaW5nIGlzIGZhbHN5ICovXG4gIGlmICghY3NzUnVsZSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBtYXhJbmRleCA9IHNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcblxuICB0cnkge1xuICAgIC8qIHVzZSBpbnNlcnRSdWxlIGFuZCBjYXAgcGFzc2VkIGluZGV4IHdpdGggbWF4SW5kZXggKG5vIG9mIGNzc1J1bGVzKSAqL1xuICAgIHNoZWV0Lmluc2VydFJ1bGUoY3NzUnVsZSwgaW5kZXggPD0gbWF4SW5kZXggPyBpbmRleCA6IG1heEluZGV4KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLyogYW55IGVycm9yIGluZGljYXRlcyBhbiBpbnZhbGlkIHJ1bGUgKi9cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qIGRlbGV0ZXMgYHNpemVgIHJ1bGVzIHN0YXJ0aW5nIGZyb20gYHJlbW92YWxJbmRleGAgKi9cbnZhciBkZWxldGVSdWxlcyA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGVzKHNoZWV0LCByZW1vdmFsSW5kZXgsIHNpemUpIHtcbiAgdmFyIGxvd2VyQm91bmQgPSByZW1vdmFsSW5kZXggLSBzaXplO1xuICBmb3IgKHZhciBpID0gcmVtb3ZhbEluZGV4OyBpID4gbG93ZXJCb3VuZDsgaSAtPSAxKSB7XG4gICAgc2hlZXQuZGVsZXRlUnVsZShpKTtcbiAgfVxufTtcblxuLy8gXG5cbi8qIHRoaXMgbWFya2VyIHNlcGFyYXRlcyBjb21wb25lbnQgc3R5bGVzIGFuZCBpcyBpbXBvcnRhbnQgZm9yIHJlaHlkcmF0aW9uICovXG52YXIgbWFrZVRleHRNYXJrZXIgPSBmdW5jdGlvbiBtYWtlVGV4dE1hcmtlcihpZCkge1xuICByZXR1cm4gJ1xcbi8qIHNjLWNvbXBvbmVudC1pZDogJyArIGlkICsgJyAqL1xcbic7XG59O1xuXG4vKiBhZGQgdXAgYWxsIG51bWJlcnMgaW4gYXJyYXkgdXAgdW50aWwgYW5kIGluY2x1ZGluZyB0aGUgaW5kZXggKi9cbnZhciBhZGRVcFVudGlsSW5kZXggPSBmdW5jdGlvbiBhZGRVcFVudGlsSW5kZXgoc2l6ZXMsIGluZGV4KSB7XG4gIHZhciB0b3RhbFVwVG9JbmRleCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGluZGV4OyBpICs9IDEpIHtcbiAgICB0b3RhbFVwVG9JbmRleCArPSBzaXplc1tpXTtcbiAgfVxuXG4gIHJldHVybiB0b3RhbFVwVG9JbmRleDtcbn07XG5cbi8qIGNyZWF0ZSBhIG5ldyBzdHlsZSB0YWcgYWZ0ZXIgbGFzdEVsICovXG52YXIgbWFrZVN0eWxlVGFnID0gZnVuY3Rpb24gbWFrZVN0eWxlVGFnKHRhcmdldCwgdGFnRWwsIGluc2VydEJlZm9yZSkge1xuICB2YXIgdGFyZ2V0RG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgaWYgKHRhcmdldCkgdGFyZ2V0RG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtlbHNlIGlmICh0YWdFbCkgdGFyZ2V0RG9jdW1lbnQgPSB0YWdFbC5vd25lckRvY3VtZW50O1xuXG4gIHZhciBlbCA9IHRhcmdldERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIGVsLnNldEF0dHJpYnV0ZShTQ19BVFRSLCAnJyk7XG4gIGVsLnNldEF0dHJpYnV0ZShTQ19WRVJTSU9OX0FUVFIsIFwiNC40LjFcIik7XG5cbiAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgaWYgKG5vbmNlKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgfVxuXG4gIC8qIFdvcmsgYXJvdW5kIGluc2VydFJ1bGUgcXVpcmsgaW4gRWRnZUhUTUwgKi9cbiAgZWwuYXBwZW5kQ2hpbGQodGFyZ2V0RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpKTtcblxuICBpZiAodGFyZ2V0ICYmICF0YWdFbCkge1xuICAgIC8qIEFwcGVuZCB0byB0YXJnZXQgd2hlbiBubyBwcmV2aW91cyBlbGVtZW50IHdhcyBwYXNzZWQgKi9cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoZWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghdGFnRWwgfHwgIXRhcmdldCB8fCAhdGFnRWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcig2KTtcbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgbmV3IHN0eWxlIHRhZyBhZnRlciB0aGUgcHJldmlvdXMgb25lICovXG4gICAgdGFnRWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIGluc2VydEJlZm9yZSA/IHRhZ0VsIDogdGFnRWwubmV4dFNpYmxpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGVsO1xufTtcblxuLyogdGFrZXMgYSBjc3MgZmFjdG9yeSBmdW5jdGlvbiBhbmQgb3V0cHV0cyBhbiBodG1sIHN0eWxlZCB0YWcgZmFjdG9yeSAqL1xudmFyIHdyYXBBc0h0bWxUYWcgPSBmdW5jdGlvbiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhZGRpdGlvbmFsQXR0cnMpIHtcbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIHZhciBhdHRycyA9IFtub25jZSAmJiAnbm9uY2U9XCInICsgbm9uY2UgKyAnXCInLCBTQ19BVFRSICsgJz1cIicgKyBzdHJpbmdpZnlOYW1lcyhuYW1lcykgKyAnXCInLCBTQ19WRVJTSU9OX0FUVFIgKyAnPVwiJyArIFwiNC40LjFcIiArICdcIicsIGFkZGl0aW9uYWxBdHRyc107XG5cbiAgICB2YXIgaHRtbEF0dHIgPSBhdHRycy5maWx0ZXIoQm9vbGVhbikuam9pbignICcpO1xuICAgIHJldHVybiAnPHN0eWxlICcgKyBodG1sQXR0ciArICc+JyArIGNzcygpICsgJzwvc3R5bGU+JztcbiAgfTtcbn07XG5cbi8qIHRha2VzIGEgY3NzIGZhY3RvcnkgZnVuY3Rpb24gYW5kIG91dHB1dHMgYW4gZWxlbWVudCBmYWN0b3J5ICovXG52YXIgd3JhcEFzRWxlbWVudCA9IGZ1bmN0aW9uIHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcHJvcHM7XG5cbiAgICB2YXIgcHJvcHMgPSAoX3Byb3BzID0ge30sIF9wcm9wc1tTQ19BVFRSXSA9IHN0cmluZ2lmeU5hbWVzKG5hbWVzKSwgX3Byb3BzW1NDX1ZFUlNJT05fQVRUUl0gPSBcIjQuNC4xXCIsIF9wcm9wcyk7XG5cbiAgICB2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuICAgIGlmIChub25jZSkge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcHJvcHMubm9uY2UgPSBub25jZTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGFuZ2VyXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7IF9faHRtbDogY3NzKCkgfSB9KSk7XG4gIH07XG59O1xuXG52YXIgZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0SWRzRnJvbU1hcmtlcnNGYWN0b3J5KG1hcmtlcnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWFya2Vycyk7XG4gIH07XG59O1xuXG4vKiBzcGVlZHkgdGFncyB1dGlsaXNlIGluc2VydFJ1bGUgKi9cbnZhciBtYWtlU3BlZWR5VGFnID0gZnVuY3Rpb24gbWFrZVNwZWVkeVRhZyhlbCwgZ2V0SW1wb3J0UnVsZVRhZykge1xuICB2YXIgbmFtZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbWFya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBzaXplcyA9IFtdO1xuXG4gIHZhciBleHRyYWN0SW1wb3J0ID0gZ2V0SW1wb3J0UnVsZVRhZyAhPT0gdW5kZWZpbmVkO1xuICAvKiBpbmRpY2F0ZXMgd2hldGhlciBnZXRJbXBvcnRSdWxlVGFnIHdhcyBjYWxsZWQgKi9cbiAgdmFyIHVzZWRJbXBvcnRSdWxlVGFnID0gZmFsc2U7XG5cbiAgdmFyIGluc2VydE1hcmtlciA9IGZ1bmN0aW9uIGluc2VydE1hcmtlcihpZCkge1xuICAgIHZhciBwcmV2ID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgbWFya2Vyc1tpZF0gPSBzaXplcy5sZW5ndGg7XG4gICAgc2l6ZXMucHVzaCgwKTtcbiAgICByZXNldElkTmFtZXMobmFtZXMsIGlkKTtcblxuICAgIHJldHVybiBtYXJrZXJzW2lkXTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhpZCwgY3NzUnVsZXMsIG5hbWUpIHtcbiAgICB2YXIgbWFya2VyID0gaW5zZXJ0TWFya2VyKGlkKTtcbiAgICB2YXIgc2hlZXQgPSBzaGVldEZvclRhZyhlbCk7XG4gICAgdmFyIGluc2VydEluZGV4ID0gYWRkVXBVbnRpbEluZGV4KHNpemVzLCBtYXJrZXIpO1xuXG4gICAgdmFyIGluamVjdGVkUnVsZXMgPSAwO1xuICAgIHZhciBpbXBvcnRSdWxlcyA9IFtdO1xuICAgIHZhciBjc3NSdWxlc1NpemUgPSBjc3NSdWxlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc1J1bGVzU2l6ZTsgaSArPSAxKSB7XG4gICAgICB2YXIgY3NzUnVsZSA9IGNzc1J1bGVzW2ldO1xuICAgICAgdmFyIG1heUhhdmVJbXBvcnQgPSBleHRyYWN0SW1wb3J0OyAvKiBAaW1wb3J0IHJ1bGVzIGFyZSByZW9yZGVyZWQgdG8gYXBwZWFyIGZpcnN0ICovXG4gICAgICBpZiAobWF5SGF2ZUltcG9ydCAmJiBjc3NSdWxlLmluZGV4T2YoJ0BpbXBvcnQnKSAhPT0gLTEpIHtcbiAgICAgICAgaW1wb3J0UnVsZXMucHVzaChjc3NSdWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2FmZUluc2VydFJ1bGUoc2hlZXQsIGNzc1J1bGUsIGluc2VydEluZGV4ICsgaW5qZWN0ZWRSdWxlcykpIHtcbiAgICAgICAgbWF5SGF2ZUltcG9ydCA9IGZhbHNlO1xuICAgICAgICBpbmplY3RlZFJ1bGVzICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4dHJhY3RJbXBvcnQgJiYgaW1wb3J0UnVsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdXNlZEltcG9ydFJ1bGVUYWcgPSB0cnVlO1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgZ2V0SW1wb3J0UnVsZVRhZygpLmluc2VydFJ1bGVzKGlkICsgJy1pbXBvcnQnLCBpbXBvcnRSdWxlcyk7XG4gICAgfVxuXG4gICAgc2l6ZXNbbWFya2VyXSArPSBpbmplY3RlZFJ1bGVzOyAvKiBhZGQgdXAgbm8gb2YgaW5qZWN0ZWQgcnVsZXMgKi9cbiAgICBhZGROYW1lRm9ySWQobmFtZXMsIGlkLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgcmVtb3ZlUnVsZXMgPSBmdW5jdGlvbiByZW1vdmVSdWxlcyhpZCkge1xuICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2lkXTtcbiAgICBpZiAobWFya2VyID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgaWYgKGVsLmlzQ29ubmVjdGVkID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgdmFyIHNpemUgPSBzaXplc1ttYXJrZXJdO1xuICAgIHZhciBzaGVldCA9IHNoZWV0Rm9yVGFnKGVsKTtcbiAgICB2YXIgcmVtb3ZhbEluZGV4ID0gYWRkVXBVbnRpbEluZGV4KHNpemVzLCBtYXJrZXIpIC0gMTtcbiAgICBkZWxldGVSdWxlcyhzaGVldCwgcmVtb3ZhbEluZGV4LCBzaXplKTtcbiAgICBzaXplc1ttYXJrZXJdID0gMDtcbiAgICByZXNldElkTmFtZXMobmFtZXMsIGlkKTtcblxuICAgIGlmIChleHRyYWN0SW1wb3J0ICYmIHVzZWRJbXBvcnRSdWxlVGFnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBnZXRJbXBvcnRSdWxlVGFnKCkucmVtb3ZlUnVsZXMoaWQgKyAnLWltcG9ydCcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgY3NzID0gZnVuY3Rpb24gY3NzKCkge1xuICAgIHZhciBfc2hlZXRGb3JUYWcgPSBzaGVldEZvclRhZyhlbCksXG4gICAgICAgIGNzc1J1bGVzID0gX3NoZWV0Rm9yVGFnLmNzc1J1bGVzO1xuXG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHN0ciArPSBtYWtlVGV4dE1hcmtlcihpZCk7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF07XG4gICAgICB2YXIgZW5kID0gYWRkVXBVbnRpbEluZGV4KHNpemVzLCBtYXJrZXIpO1xuICAgICAgdmFyIHNpemUgPSBzaXplc1ttYXJrZXJdO1xuICAgICAgZm9yICh2YXIgaSA9IGVuZCAtIHNpemU7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcnVsZSA9IGNzc1J1bGVzW2ldO1xuICAgICAgICBpZiAocnVsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RyICs9IHJ1bGUuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDUpO1xuICAgIH0sXG5cbiAgICBjc3M6IGNzcyxcbiAgICBnZXRJZHM6IGdldElkc0Zyb21NYXJrZXJzRmFjdG9yeShtYXJrZXJzKSxcbiAgICBoYXNOYW1lRm9ySWQ6IGhhc05hbWVGb3JJZChuYW1lcyksXG4gICAgaW5zZXJ0TWFya2VyOiBpbnNlcnRNYXJrZXIsXG4gICAgaW5zZXJ0UnVsZXM6IGluc2VydFJ1bGVzLFxuICAgIHJlbW92ZVJ1bGVzOiByZW1vdmVSdWxlcyxcbiAgICBzZWFsZWQ6IGZhbHNlLFxuICAgIHN0eWxlVGFnOiBlbCxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgdG9IVE1MOiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpXG4gIH07XG59O1xuXG52YXIgbWFrZVRleHROb2RlID0gZnVuY3Rpb24gbWFrZVRleHROb2RlKHRhcmdldERvY3VtZW50LCBpZCkge1xuICByZXR1cm4gdGFyZ2V0RG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobWFrZVRleHRNYXJrZXIoaWQpKTtcbn07XG5cbnZhciBtYWtlQnJvd3NlclRhZyA9IGZ1bmN0aW9uIG1ha2VCcm93c2VyVGFnKGVsLCBnZXRJbXBvcnRSdWxlVGFnKSB7XG4gIHZhciBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBtYXJrZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICB2YXIgZXh0cmFjdEltcG9ydCA9IGdldEltcG9ydFJ1bGVUYWcgIT09IHVuZGVmaW5lZDtcblxuICAvKiBpbmRpY2F0ZXMgd2hldGhlciBnZXRJbXBvcnRSdWxlVGFnIHdhcyBjYWxsZWQgKi9cbiAgdmFyIHVzZWRJbXBvcnRSdWxlVGFnID0gZmFsc2U7XG5cbiAgdmFyIGluc2VydE1hcmtlciA9IGZ1bmN0aW9uIGluc2VydE1hcmtlcihpZCkge1xuICAgIHZhciBwcmV2ID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKHByZXYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgbWFya2Vyc1tpZF0gPSBtYWtlVGV4dE5vZGUoZWwub3duZXJEb2N1bWVudCwgaWQpO1xuICAgIGVsLmFwcGVuZENoaWxkKG1hcmtlcnNbaWRdKTtcbiAgICBuYW1lc1tpZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgcmV0dXJuIG1hcmtlcnNbaWRdO1xuICB9O1xuXG4gIHZhciBpbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIGluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgIHZhciBtYXJrZXIgPSBpbnNlcnRNYXJrZXIoaWQpO1xuICAgIHZhciBpbXBvcnRSdWxlcyA9IFtdO1xuICAgIHZhciBjc3NSdWxlc1NpemUgPSBjc3NSdWxlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc1J1bGVzU2l6ZTsgaSArPSAxKSB7XG4gICAgICB2YXIgcnVsZSA9IGNzc1J1bGVzW2ldO1xuICAgICAgdmFyIG1heUhhdmVJbXBvcnQgPSBleHRyYWN0SW1wb3J0O1xuICAgICAgaWYgKG1heUhhdmVJbXBvcnQgJiYgcnVsZS5pbmRleE9mKCdAaW1wb3J0JykgIT09IC0xKSB7XG4gICAgICAgIGltcG9ydFJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXlIYXZlSW1wb3J0ID0gZmFsc2U7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSBpID09PSBjc3NSdWxlc1NpemUgLSAxID8gJycgOiAnICc7XG4gICAgICAgIG1hcmtlci5hcHBlbmREYXRhKCcnICsgcnVsZSArIHNlcGFyYXRvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkTmFtZUZvcklkKG5hbWVzLCBpZCwgbmFtZSk7XG5cbiAgICBpZiAoZXh0cmFjdEltcG9ydCAmJiBpbXBvcnRSdWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICB1c2VkSW1wb3J0UnVsZVRhZyA9IHRydWU7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBnZXRJbXBvcnRSdWxlVGFnKCkuaW5zZXJ0UnVsZXMoaWQgKyAnLWltcG9ydCcsIGltcG9ydFJ1bGVzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJlbW92ZVJ1bGVzID0gZnVuY3Rpb24gcmVtb3ZlUnVsZXMoaWQpIHtcbiAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKG1hcmtlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAvKiBjcmVhdGUgbmV3IGVtcHR5IHRleHQgbm9kZSBhbmQgcmVwbGFjZSB0aGUgY3VycmVudCBvbmUgKi9cbiAgICB2YXIgbmV3TWFya2VyID0gbWFrZVRleHROb2RlKGVsLm93bmVyRG9jdW1lbnQsIGlkKTtcbiAgICBlbC5yZXBsYWNlQ2hpbGQobmV3TWFya2VyLCBtYXJrZXIpO1xuICAgIG1hcmtlcnNbaWRdID0gbmV3TWFya2VyO1xuICAgIHJlc2V0SWROYW1lcyhuYW1lcywgaWQpO1xuXG4gICAgaWYgKGV4dHJhY3RJbXBvcnQgJiYgdXNlZEltcG9ydFJ1bGVUYWcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIGdldEltcG9ydFJ1bGVUYWcoKS5yZW1vdmVSdWxlcyhpZCArICctaW1wb3J0Jyk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBjc3MgPSBmdW5jdGlvbiBjc3MoKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHN0ciArPSBtYXJrZXJzW2lkXS5kYXRhO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBjbG9uZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDUpO1xuICAgIH0sXG5cbiAgICBjc3M6IGNzcyxcbiAgICBnZXRJZHM6IGdldElkc0Zyb21NYXJrZXJzRmFjdG9yeShtYXJrZXJzKSxcbiAgICBoYXNOYW1lRm9ySWQ6IGhhc05hbWVGb3JJZChuYW1lcyksXG4gICAgaW5zZXJ0TWFya2VyOiBpbnNlcnRNYXJrZXIsXG4gICAgaW5zZXJ0UnVsZXM6IGluc2VydFJ1bGVzLFxuICAgIHJlbW92ZVJ1bGVzOiByZW1vdmVSdWxlcyxcbiAgICBzZWFsZWQ6IGZhbHNlLFxuICAgIHN0eWxlVGFnOiBlbCxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgdG9IVE1MOiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpXG4gIH07XG59O1xuXG52YXIgbWFrZVNlcnZlclRhZyA9IGZ1bmN0aW9uIG1ha2VTZXJ2ZXJUYWcobmFtZXNBcmcsIG1hcmtlcnNBcmcpIHtcbiAgdmFyIG5hbWVzID0gbmFtZXNBcmcgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBuYW1lc0FyZztcbiAgdmFyIG1hcmtlcnMgPSBtYXJrZXJzQXJnID09PSB1bmRlZmluZWQgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogbWFya2Vyc0FyZztcblxuICB2YXIgaW5zZXJ0TWFya2VyID0gZnVuY3Rpb24gaW5zZXJ0TWFya2VyKGlkKSB7XG4gICAgdmFyIHByZXYgPSBtYXJrZXJzW2lkXTtcbiAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya2Vyc1tpZF0gPSBbJyddO1xuICB9O1xuXG4gIHZhciBpbnNlcnRSdWxlcyA9IGZ1bmN0aW9uIGluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgIHZhciBtYXJrZXIgPSBpbnNlcnRNYXJrZXIoaWQpO1xuICAgIG1hcmtlclswXSArPSBjc3NSdWxlcy5qb2luKCcgJyk7XG4gICAgYWRkTmFtZUZvcklkKG5hbWVzLCBpZCwgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHJlbW92ZVJ1bGVzID0gZnVuY3Rpb24gcmVtb3ZlUnVsZXMoaWQpIHtcbiAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpZF07XG4gICAgaWYgKG1hcmtlciA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgbWFya2VyWzBdID0gJyc7XG4gICAgcmVzZXRJZE5hbWVzKG5hbWVzLCBpZCk7XG4gIH07XG5cbiAgdmFyIGNzcyA9IGZ1bmN0aW9uIGNzcygpIHtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIHZhciBjc3NGb3JJZCA9IG1hcmtlcnNbaWRdWzBdO1xuICAgICAgaWYgKGNzc0ZvcklkKSB7XG4gICAgICAgIHN0ciArPSBtYWtlVGV4dE1hcmtlcihpZCkgKyBjc3NGb3JJZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICB2YXIgY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICB2YXIgbmFtZXNDbG9uZSA9IGNsb25lTmFtZXMobmFtZXMpO1xuICAgIHZhciBtYXJrZXJzQ2xvbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgIGZvciAodmFyIGlkIGluIG1hcmtlcnMpIHtcbiAgICAgIG1hcmtlcnNDbG9uZVtpZF0gPSBbbWFya2Vyc1tpZF1bMF1dO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlU2VydmVyVGFnKG5hbWVzQ2xvbmUsIG1hcmtlcnNDbG9uZSk7XG4gIH07XG5cbiAgdmFyIHRhZyA9IHtcbiAgICBjbG9uZTogY2xvbmUsXG4gICAgY3NzOiBjc3MsXG4gICAgZ2V0SWRzOiBnZXRJZHNGcm9tTWFya2Vyc0ZhY3RvcnkobWFya2VycyksXG4gICAgaGFzTmFtZUZvcklkOiBoYXNOYW1lRm9ySWQobmFtZXMpLFxuICAgIGluc2VydE1hcmtlcjogaW5zZXJ0TWFya2VyLFxuICAgIGluc2VydFJ1bGVzOiBpbnNlcnRSdWxlcyxcbiAgICByZW1vdmVSdWxlczogcmVtb3ZlUnVsZXMsXG4gICAgc2VhbGVkOiBmYWxzZSxcbiAgICBzdHlsZVRhZzogbnVsbCxcbiAgICB0b0VsZW1lbnQ6IHdyYXBBc0VsZW1lbnQoY3NzLCBuYW1lcyksXG4gICAgdG9IVE1MOiB3cmFwQXNIdG1sVGFnKGNzcywgbmFtZXMpXG4gIH07XG5cbiAgcmV0dXJuIHRhZztcbn07XG5cbnZhciBtYWtlVGFnID0gZnVuY3Rpb24gbWFrZVRhZyh0YXJnZXQsIHRhZ0VsLCBmb3JjZVNlcnZlciwgaW5zZXJ0QmVmb3JlLCBnZXRJbXBvcnRSdWxlVGFnKSB7XG4gIGlmIChJU19CUk9XU0VSICYmICFmb3JjZVNlcnZlcikge1xuICAgIHZhciBlbCA9IG1ha2VTdHlsZVRhZyh0YXJnZXQsIHRhZ0VsLCBpbnNlcnRCZWZvcmUpO1xuXG4gICAgaWYgKERJU0FCTEVfU1BFRURZKSB7XG4gICAgICByZXR1cm4gbWFrZUJyb3dzZXJUYWcoZWwsIGdldEltcG9ydFJ1bGVUYWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWFrZVNwZWVkeVRhZyhlbCwgZ2V0SW1wb3J0UnVsZVRhZyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1ha2VTZXJ2ZXJUYWcoKTtcbn07XG5cbnZhciByZWh5ZHJhdGUgPSBmdW5jdGlvbiByZWh5ZHJhdGUodGFnLCBlbHMsIGV4dHJhY3RlZCkge1xuICAvKiBhZGQgYWxsIGV4dHJhY3RlZCBjb21wb25lbnRzIHRvIHRoZSBuZXcgdGFnICovXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHRyYWN0ZWQubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICB2YXIgX2V4dHJhY3RlZCRpID0gZXh0cmFjdGVkW2ldLFxuICAgICAgICBjb21wb25lbnRJZCA9IF9leHRyYWN0ZWQkaS5jb21wb25lbnRJZCxcbiAgICAgICAgY3NzRnJvbURPTSA9IF9leHRyYWN0ZWQkaS5jc3NGcm9tRE9NO1xuXG4gICAgdmFyIGNzc1J1bGVzID0gc3BsaXRCeVJ1bGVzKGNzc0Zyb21ET00pO1xuICAgIHRhZy5pbnNlcnRSdWxlcyhjb21wb25lbnRJZCwgY3NzUnVsZXMpO1xuICB9XG5cbiAgLyogcmVtb3ZlIG9sZCBIVE1MU3R5bGVFbGVtZW50cywgc2luY2UgdGhleSBoYXZlIGJlZW4gcmVoeWRyYXRlZCAqL1xuICBmb3IgKHZhciBfaSA9IDAsIF9sZW4gPSBlbHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pICs9IDEpIHtcbiAgICB2YXIgZWwgPSBlbHNbX2ldO1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIFxuXG52YXIgU1BMSVRfUkVHRVggPSAvXFxzKy87XG5cbi8qIGRldGVybWluZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgY29tcG9uZW50cyBiZWZvcmUgdGFncyBhcmUgc2hhcmRlZCAqL1xudmFyIE1BWF9TSVpFID0gdm9pZCAwO1xuaWYgKElTX0JST1dTRVIpIHtcbiAgLyogaW4gc3BlZWR5IG1vZGUgd2UgY2FuIGtlZXAgYSBsb3QgbW9yZSBydWxlcyBpbiBhIHNoZWV0IGJlZm9yZSBhIHNsb3dkb3duIGNhbiBiZSBleHBlY3RlZCAqL1xuICBNQVhfU0laRSA9IERJU0FCTEVfU1BFRURZID8gNDAgOiAxMDAwO1xufSBlbHNlIHtcbiAgLyogZm9yIHNlcnZlcnMgd2UgZG8gbm90IG5lZWQgdG8gc2hhcmQgYXQgYWxsICovXG4gIE1BWF9TSVpFID0gLTE7XG59XG5cbnZhciBzaGVldFJ1bm5pbmdJZCA9IDA7XG52YXIgbWFzdGVyID0gdm9pZCAwO1xuXG52YXIgU3R5bGVTaGVldCA9IGZ1bmN0aW9uICgpIHtcblxuICAvKiBhIG1hcCBmcm9tIGlkcyB0byB0YWdzICovXG5cbiAgLyogZGVmZXJyZWQgcnVsZXMgZm9yIGEgZ2l2ZW4gaWQgKi9cblxuICAvKiB0aGlzIGlzIHVzZWQgZm9yIG5vdCByZWluamVjdGluZyBydWxlcyB2aWEgaGFzTmFtZUZvcklkKCkgKi9cblxuICAvKiB3aGVuIHJ1bGVzIGZvciBhbiBpZCBhcmUgcmVtb3ZlZCB1c2luZyByZW1vdmUoKSB3ZSBoYXZlIHRvIGlnbm9yZSByZWh5ZHJhdGVkTmFtZXMgZm9yIGl0ICovXG5cbiAgLyogYSBsaXN0IG9mIHRhZ3MgYmVsb25naW5nIHRvIHRoaXMgU3R5bGVTaGVldCAqL1xuXG4gIC8qIGEgdGFnIGZvciBpbXBvcnQgcnVsZXMgKi9cblxuICAvKiBjdXJyZW50IGNhcGFjaXR5IHVudGlsIGEgbmV3IHRhZyBtdXN0IGJlIGNyZWF0ZWQgKi9cblxuICAvKiBjaGlsZHJlbiAoYWthIGNsb25lcykgb2YgdGhpcyBTdHlsZVNoZWV0IGluaGVyaXRpbmcgYWxsIGFuZCBmdXR1cmUgaW5qZWN0aW9ucyAqL1xuXG4gIGZ1bmN0aW9uIFN0eWxlU2hlZXQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IElTX0JST1dTRVIgPyBkb2N1bWVudC5oZWFkIDogbnVsbDtcbiAgICB2YXIgZm9yY2VTZXJ2ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlU2hlZXQpO1xuXG4gICAgdGhpcy5nZXRJbXBvcnRSdWxlVGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGltcG9ydFJ1bGVUYWcgPSBfdGhpcy5pbXBvcnRSdWxlVGFnO1xuXG4gICAgICBpZiAoaW1wb3J0UnVsZVRhZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbXBvcnRSdWxlVGFnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RUYWcgPSBfdGhpcy50YWdzWzBdO1xuICAgICAgdmFyIGluc2VydEJlZm9yZSA9IHRydWU7XG5cbiAgICAgIHJldHVybiBfdGhpcy5pbXBvcnRSdWxlVGFnID0gbWFrZVRhZyhfdGhpcy50YXJnZXQsIGZpcnN0VGFnID8gZmlyc3RUYWcuc3R5bGVUYWcgOiBudWxsLCBfdGhpcy5mb3JjZVNlcnZlciwgaW5zZXJ0QmVmb3JlKTtcbiAgICB9O1xuXG4gICAgc2hlZXRSdW5uaW5nSWQgKz0gMTtcbiAgICB0aGlzLmlkID0gc2hlZXRSdW5uaW5nSWQ7XG4gICAgdGhpcy5mb3JjZVNlcnZlciA9IGZvcmNlU2VydmVyO1xuICAgIHRoaXMudGFyZ2V0ID0gZm9yY2VTZXJ2ZXIgPyBudWxsIDogdGFyZ2V0O1xuICAgIHRoaXMudGFnTWFwID0ge307XG4gICAgdGhpcy5kZWZlcnJlZCA9IHt9O1xuICAgIHRoaXMucmVoeWRyYXRlZE5hbWVzID0ge307XG4gICAgdGhpcy5pZ25vcmVSZWh5ZHJhdGVkTmFtZXMgPSB7fTtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLmNhcGFjaXR5ID0gMTtcbiAgICB0aGlzLmNsb25lcyA9IFtdO1xuICB9XG5cbiAgLyogcmVoeWRyYXRlIGFsbCBTU1InZCBzdHlsZSB0YWdzICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5yZWh5ZHJhdGUgPSBmdW5jdGlvbiByZWh5ZHJhdGUkJDEoKSB7XG4gICAgaWYgKCFJU19CUk9XU0VSIHx8IHRoaXMuZm9yY2VTZXJ2ZXIpIHJldHVybiB0aGlzO1xuXG4gICAgdmFyIGVscyA9IFtdO1xuICAgIHZhciBleHRyYWN0ZWQgPSBbXTtcbiAgICB2YXIgaXNTdHJlYW1lZCA9IGZhbHNlO1xuXG4gICAgLyogcmV0cmlldmUgYWxsIG9mIG91ciBTU1Igc3R5bGUgZWxlbWVudHMgZnJvbSB0aGUgRE9NICovXG4gICAgdmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbJyArIFNDX0FUVFIgKyAnXVsnICsgU0NfVkVSU0lPTl9BVFRSICsgJz1cIicgKyBcIjQuNC4xXCIgKyAnXCJdJyk7XG5cbiAgICB2YXIgbm9kZXNTaXplID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgLyogYWJvcnQgcmVoeWRyYXRpb24gaWYgbm8gcHJldmlvdXMgc3R5bGUgdGFncyB3ZXJlIGZvdW5kICovXG4gICAgaWYgKCFub2Rlc1NpemUpIHJldHVybiB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlc1NpemU7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsID0gbm9kZXNbaV07XG5cbiAgICAgIC8qIGNoZWNrIGlmIHN0eWxlIHRhZyBpcyBhIHN0cmVhbWVkIHRhZyAqL1xuICAgICAgaWYgKCFpc1N0cmVhbWVkKSBpc1N0cmVhbWVkID0gISFlbC5nZXRBdHRyaWJ1dGUoU0NfU1RSRUFNX0FUVFIpO1xuXG4gICAgICAvKiByZXRyaWV2ZSBhbGwgY29tcG9uZW50IG5hbWVzICovXG4gICAgICB2YXIgZWxOYW1lcyA9IChlbC5nZXRBdHRyaWJ1dGUoU0NfQVRUUikgfHwgJycpLnRyaW0oKS5zcGxpdChTUExJVF9SRUdFWCk7XG4gICAgICB2YXIgZWxOYW1lc1NpemUgPSBlbE5hbWVzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGogPSAwLCBuYW1lOyBqIDwgZWxOYW1lc1NpemU7IGogKz0gMSkge1xuICAgICAgICBuYW1lID0gZWxOYW1lc1tqXTtcbiAgICAgICAgLyogYWRkIHJlaHlkcmF0ZWQgbmFtZSB0byBzaGVldCB0byBhdm9pZCByZS1hZGRpbmcgc3R5bGVzICovXG4gICAgICAgIHRoaXMucmVoeWRyYXRlZE5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogZXh0cmFjdCBhbGwgY29tcG9uZW50cyBhbmQgdGhlaXIgQ1NTICovXG4gICAgICBleHRyYWN0ZWQucHVzaC5hcHBseShleHRyYWN0ZWQsIGV4dHJhY3RDb21wcyhlbC50ZXh0Q29udGVudCkpO1xuXG4gICAgICAvKiBzdG9yZSBvcmlnaW5hbCBIVE1MU3R5bGVFbGVtZW50ICovXG4gICAgICBlbHMucHVzaChlbCk7XG4gICAgfVxuXG4gICAgLyogYWJvcnQgcmVoeWRyYXRpb24gaWYgbm90aGluZyB3YXMgZXh0cmFjdGVkICovXG4gICAgdmFyIGV4dHJhY3RlZFNpemUgPSBleHRyYWN0ZWQubGVuZ3RoO1xuICAgIGlmICghZXh0cmFjdGVkU2l6ZSkgcmV0dXJuIHRoaXM7XG5cbiAgICAvKiBjcmVhdGUgYSB0YWcgdG8gYmUgdXNlZCBmb3IgcmVoeWRyYXRpb24gKi9cbiAgICB2YXIgdGFnID0gdGhpcy5tYWtlVGFnKG51bGwpO1xuXG4gICAgcmVoeWRyYXRlKHRhZywgZWxzLCBleHRyYWN0ZWQpO1xuXG4gICAgLyogcmVzZXQgY2FwYWNpdHkgYW5kIGFkanVzdCBNQVhfU0laRSBieSB0aGUgaW5pdGlhbCBzaXplIG9mIHRoZSByZWh5ZHJhdGlvbiAqL1xuICAgIHRoaXMuY2FwYWNpdHkgPSBNYXRoLm1heCgxLCBNQVhfU0laRSAtIGV4dHJhY3RlZFNpemUpO1xuICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG5cbiAgICAvKiByZXRyaWV2ZSBhbGwgY29tcG9uZW50IGlkcyAqL1xuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBleHRyYWN0ZWRTaXplOyBfaiArPSAxKSB7XG4gICAgICB0aGlzLnRhZ01hcFtleHRyYWN0ZWRbX2pdLmNvbXBvbmVudElkXSA9IHRhZztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKiByZXRyaWV2ZSBhIFwibWFzdGVyXCIgaW5zdGFuY2Ugb2YgU3R5bGVTaGVldCB3aGljaCBpcyB0eXBpY2FsbHkgdXNlZCB3aGVuIG5vIG90aGVyIGlzIGF2YWlsYWJsZVxuICAgKiBUaGUgbWFzdGVyIFN0eWxlU2hlZXQgaXMgdGFyZ2V0ZWQgYnkgY3JlYXRlR2xvYmFsU3R5bGUsIGtleWZyYW1lcywgYW5kIGNvbXBvbmVudHMgb3V0c2lkZSBvZiBhbnlcbiAgICAqIFN0eWxlU2hlZXRNYW5hZ2VyJ3MgY29udGV4dCAqL1xuXG5cbiAgLyogcmVzZXQgdGhlIGludGVybmFsIFwibWFzdGVyXCIgaW5zdGFuY2UgKi9cbiAgU3R5bGVTaGVldC5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHZhciBmb3JjZVNlcnZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICBtYXN0ZXIgPSBuZXcgU3R5bGVTaGVldCh1bmRlZmluZWQsIGZvcmNlU2VydmVyKS5yZWh5ZHJhdGUoKTtcbiAgfTtcblxuICAvKiBhZGRzIFwiY2hpbGRyZW5cIiB0byB0aGUgU3R5bGVTaGVldCB0aGF0IGluaGVyaXQgYWxsIG9mIHRoZSBwYXJlbnRzJyBydWxlc1xuICAgKiB3aGlsZSB0aGVpciBvd24gcnVsZXMgZG8gbm90IGFmZmVjdCB0aGUgcGFyZW50ICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHZhciBzaGVldCA9IG5ldyBTdHlsZVNoZWV0KHRoaXMudGFyZ2V0LCB0aGlzLmZvcmNlU2VydmVyKTtcblxuICAgIC8qIGFkZCB0byBjbG9uZSBhcnJheSAqL1xuICAgIHRoaXMuY2xvbmVzLnB1c2goc2hlZXQpO1xuXG4gICAgLyogY2xvbmUgYWxsIHRhZ3MgKi9cbiAgICBzaGVldC50YWdzID0gdGhpcy50YWdzLm1hcChmdW5jdGlvbiAodGFnKSB7XG4gICAgICB2YXIgaWRzID0gdGFnLmdldElkcygpO1xuICAgICAgdmFyIG5ld1RhZyA9IHRhZy5jbG9uZSgpO1xuXG4gICAgICAvKiByZWNvbnN0cnVjdCB0YWdNYXAgKi9cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHNoZWV0LnRhZ01hcFtpZHNbaV1dID0gbmV3VGFnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3VGFnO1xuICAgIH0pO1xuXG4gICAgLyogY2xvbmUgb3RoZXIgbWFwcyAqL1xuICAgIHNoZWV0LnJlaHlkcmF0ZWROYW1lcyA9IF9leHRlbmRzKHt9LCB0aGlzLnJlaHlkcmF0ZWROYW1lcyk7XG4gICAgc2hlZXQuZGVmZXJyZWQgPSBfZXh0ZW5kcyh7fSwgdGhpcy5kZWZlcnJlZCk7XG5cbiAgICByZXR1cm4gc2hlZXQ7XG4gIH07XG5cbiAgLyogZm9yY2UgU3R5bGVTaGVldCB0byBjcmVhdGUgYSBuZXcgdGFnIG9uIHRoZSBuZXh0IGluamVjdGlvbiAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuc2VhbEFsbFRhZ3MgPSBmdW5jdGlvbiBzZWFsQWxsVGFncygpIHtcbiAgICB0aGlzLmNhcGFjaXR5ID0gMTtcblxuICAgIHRoaXMudGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgdGFnLnNlYWxlZCA9IHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUubWFrZVRhZyA9IGZ1bmN0aW9uIG1ha2VUYWckJDEodGFnKSB7XG4gICAgdmFyIGxhc3RFbCA9IHRhZyA/IHRhZy5zdHlsZVRhZyA6IG51bGw7XG4gICAgdmFyIGluc2VydEJlZm9yZSA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIG1ha2VUYWcodGhpcy50YXJnZXQsIGxhc3RFbCwgdGhpcy5mb3JjZVNlcnZlciwgaW5zZXJ0QmVmb3JlLCB0aGlzLmdldEltcG9ydFJ1bGVUYWcpO1xuICB9O1xuXG4gIC8qIGdldCBhIHRhZyBmb3IgYSBnaXZlbiBjb21wb25lbnRJZCwgYXNzaWduIHRoZSBjb21wb25lbnRJZCB0byBvbmUsIG9yIHNoYXJkICovXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLmdldFRhZ0ZvcklkID0gZnVuY3Rpb24gZ2V0VGFnRm9ySWQoaWQpIHtcbiAgICAvKiBzaW1wbHkgcmV0dXJuIGEgdGFnLCB3aGVuIHRoZSBjb21wb25lbnRJZCB3YXMgYWxyZWFkeSBhc3NpZ25lZCBvbmUgKi9cbiAgICB2YXIgcHJldiA9IHRoaXMudGFnTWFwW2lkXTtcbiAgICBpZiAocHJldiAhPT0gdW5kZWZpbmVkICYmICFwcmV2LnNlYWxlZCkge1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IHRoaXMudGFnc1t0aGlzLnRhZ3MubGVuZ3RoIC0gMV07XG5cbiAgICAvKiBzaGFyZCAoY3JlYXRlIGEgbmV3IHRhZykgaWYgdGhlIHRhZyBpcyBleGhhdXN0ZWQgKFNlZSBNQVhfU0laRSkgKi9cbiAgICB0aGlzLmNhcGFjaXR5IC09IDE7XG5cbiAgICBpZiAodGhpcy5jYXBhY2l0eSA9PT0gMCkge1xuICAgICAgdGhpcy5jYXBhY2l0eSA9IE1BWF9TSVpFO1xuICAgICAgdGFnID0gdGhpcy5tYWtlVGFnKHRhZyk7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRhZ01hcFtpZF0gPSB0YWc7XG4gIH07XG5cbiAgLyogbWFpbmx5IGZvciBjcmVhdGVHbG9iYWxTdHlsZSB0byBjaGVjayBmb3IgaXRzIGlkICovXG5cblxuICBTdHlsZVNoZWV0LnByb3RvdHlwZS5oYXNJZCA9IGZ1bmN0aW9uIGhhc0lkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnTWFwW2lkXSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qIGNhY2hpbmcgbGF5ZXIgY2hlY2tpbmcgaWQrbmFtZSB0byBhbHJlYWR5IGhhdmUgYSBjb3JyZXNwb25kaW5nIHRhZyBhbmQgaW5qZWN0ZWQgcnVsZXMgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLmhhc05hbWVGb3JJZCA9IGZ1bmN0aW9uIGhhc05hbWVGb3JJZChpZCwgbmFtZSkge1xuICAgIC8qIGV4Y2VwdGlvbiBmb3IgcmVoeWRyYXRlZCBuYW1lcyB3aGljaCBhcmUgY2hlY2tlZCBzZXBhcmF0ZWx5ICovXG4gICAgaWYgKHRoaXMuaWdub3JlUmVoeWRyYXRlZE5hbWVzW2lkXSA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmVoeWRyYXRlZE5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gdGhpcy50YWdNYXBbaWRdO1xuICAgIHJldHVybiB0YWcgIT09IHVuZGVmaW5lZCAmJiB0YWcuaGFzTmFtZUZvcklkKGlkLCBuYW1lKTtcbiAgfTtcblxuICAvKiByZWdpc3RlcnMgYSBjb21wb25lbnRJZCBhbmQgcmVnaXN0ZXJzIGl0IG9uIGl0cyB0YWcgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLmRlZmVycmVkSW5qZWN0ID0gZnVuY3Rpb24gZGVmZXJyZWRJbmplY3QoaWQsIGNzc1J1bGVzKSB7XG4gICAgLyogZG9uJ3QgaW5qZWN0IHdoZW4gdGhlIGlkIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCAqL1xuICAgIGlmICh0aGlzLnRhZ01hcFtpZF0gIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgdmFyIGNsb25lcyA9IHRoaXMuY2xvbmVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNsb25lc1tpXS5kZWZlcnJlZEluamVjdChpZCwgY3NzUnVsZXMpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0VGFnRm9ySWQoaWQpLmluc2VydE1hcmtlcihpZCk7XG4gICAgdGhpcy5kZWZlcnJlZFtpZF0gPSBjc3NSdWxlcztcbiAgfTtcblxuICAvKiBpbmplY3RzIHJ1bGVzIGZvciBhIGdpdmVuIGlkIHdpdGggYSBuYW1lIHRoYXQgd2lsbCBuZWVkIHRvIGJlIGNhY2hlZCAqL1xuXG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUuaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KGlkLCBjc3NSdWxlcywgbmFtZSkge1xuICAgIHZhciBjbG9uZXMgPSB0aGlzLmNsb25lcztcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNsb25lc1tpXS5pbmplY3QoaWQsIGNzc1J1bGVzLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgdGFnID0gdGhpcy5nZXRUYWdGb3JJZChpZCk7XG5cbiAgICAvKiBhZGQgZGVmZXJyZWQgcnVsZXMgZm9yIGNvbXBvbmVudCAqL1xuICAgIGlmICh0aGlzLmRlZmVycmVkW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDb21iaW5lIHBhc3NlZCBjc3NSdWxlcyB3aXRoIHByZXZpb3VzbHkgZGVmZXJyZWQgQ1NTIHJ1bGVzXG4gICAgICAvLyBOT1RFOiBXZSBjYW5ub3QgbXV0YXRlIHRoZSBkZWZlcnJlZCBhcnJheSBpdHNlbGYgYXMgYWxsIGNsb25lc1xuICAgICAgLy8gZG8gdGhlIHNhbWUgKHNlZSBjbG9uZXNbaV0uaW5qZWN0KVxuICAgICAgdmFyIHJ1bGVzID0gdGhpcy5kZWZlcnJlZFtpZF0uY29uY2F0KGNzc1J1bGVzKTtcbiAgICAgIHRhZy5pbnNlcnRSdWxlcyhpZCwgcnVsZXMsIG5hbWUpO1xuXG4gICAgICB0aGlzLmRlZmVycmVkW2lkXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnLmluc2VydFJ1bGVzKGlkLCBjc3NSdWxlcywgbmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qIHJlbW92ZXMgYWxsIHJ1bGVzIGZvciBhIGdpdmVuIGlkLCB3aGljaCBkb2Vzbid0IHJlbW92ZSBpdHMgbWFya2VyIGJ1dCByZXNldHMgaXQgKi9cblxuXG4gIFN0eWxlU2hlZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShpZCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZ01hcFtpZF07XG4gICAgaWYgKHRhZyA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICB2YXIgY2xvbmVzID0gdGhpcy5jbG9uZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2xvbmVzW2ldLnJlbW92ZShpZCk7XG4gICAgfVxuXG4gICAgLyogcmVtb3ZlIGFsbCBydWxlcyBmcm9tIHRoZSB0YWcgKi9cbiAgICB0YWcucmVtb3ZlUnVsZXMoaWQpO1xuXG4gICAgLyogaWdub3JlIHBvc3NpYmxlIHJlaHlkcmF0ZWQgbmFtZXMgKi9cbiAgICB0aGlzLmlnbm9yZVJlaHlkcmF0ZWROYW1lc1tpZF0gPSB0cnVlO1xuXG4gICAgLyogZGVsZXRlIHBvc3NpYmxlIGRlZmVycmVkIHJ1bGVzICovXG4gICAgdGhpcy5kZWZlcnJlZFtpZF0gPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24gdG9IVE1MKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MubWFwKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgIHJldHVybiB0YWcudG9IVE1MKCk7XG4gICAgfSkuam9pbignJyk7XG4gIH07XG5cbiAgU3R5bGVTaGVldC5wcm90b3R5cGUudG9SZWFjdEVsZW1lbnRzID0gZnVuY3Rpb24gdG9SZWFjdEVsZW1lbnRzKCkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG5cblxuICAgIHJldHVybiB0aGlzLnRhZ3MubWFwKGZ1bmN0aW9uICh0YWcsIGkpIHtcbiAgICAgIHZhciBrZXkgPSAnc2MtJyArIGlkICsgJy0nICsgaTtcbiAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQodGFnLnRvRWxlbWVudCgpLCB7IGtleToga2V5IH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIGNyZWF0ZUNsYXNzKFN0eWxlU2hlZXQsIG51bGwsIFt7XG4gICAga2V5OiAnbWFzdGVyJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBtYXN0ZXIgfHwgKG1hc3RlciA9IG5ldyBTdHlsZVNoZWV0KCkucmVoeWRyYXRlKCkpO1xuICAgIH1cblxuICAgIC8qIE5PVEU6IFRoaXMgaXMganVzdCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCBqZXN0LXN0eWxlZC1jb21wb25lbnRzICovXG5cbiAgfSwge1xuICAgIGtleTogJ2luc3RhbmNlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiBTdHlsZVNoZWV0Lm1hc3RlcjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbi8vIFxuXG52YXIgS2V5ZnJhbWVzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBLZXlmcmFtZXMobmFtZSwgcnVsZXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgS2V5ZnJhbWVzKTtcblxuICAgIHRoaXMuaW5qZWN0ID0gZnVuY3Rpb24gKHN0eWxlU2hlZXQpIHtcbiAgICAgIGlmICghc3R5bGVTaGVldC5oYXNOYW1lRm9ySWQoX3RoaXMuaWQsIF90aGlzLm5hbWUpKSB7XG4gICAgICAgIHN0eWxlU2hlZXQuaW5qZWN0KF90aGlzLmlkLCBfdGhpcy5ydWxlcywgX3RoaXMubmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDEyLCBTdHJpbmcoX3RoaXMubmFtZSkpO1xuICAgIH07XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucnVsZXMgPSBydWxlcztcblxuICAgIHRoaXMuaWQgPSAnc2Mta2V5ZnJhbWVzLScgKyBuYW1lO1xuICB9XG5cbiAgS2V5ZnJhbWVzLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZXM7XG59KCk7XG5cbi8vIFxuXG4vKipcbiAqIGlubGluZWQgdmVyc2lvbiBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9tYXN0ZXIvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9oeXBoZW5hdGVTdHlsZU5hbWUuanNcbiAqL1xuXG52YXIgdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG4vLyBcblxuLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iODdhYWJkZmUxYjc0NjFlNzMzMWFiYjM2MDFkOWU2YmIyNzU0NGJjL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL2Rhbmdlcm91c1N0eWxlVmFsdWUuanNcbmZ1bmN0aW9uIGFkZFVuaXRJZk5lZWRlZChuYW1lLCB2YWx1ZSkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW1pbGFqYWNrL2VzbGludC1wbHVnaW4tZmxvd3R5cGUtZXJyb3JzL2lzc3Vlcy8xMzNcbiAgLy8gJEZsb3dGaXhNZVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKG5hbWUgaW4gdW5pdGxlc3MpKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnRyaW0oKTtcbn1cblxuLy8gXG5cbi8qKlxuICogSXQncyBmYWxzaXNoIG5vdCBmYWxzeSBiZWNhdXNlIDAgaXMgYWxsb3dlZC5cbiAqL1xudmFyIGlzRmFsc2lzaCA9IGZ1bmN0aW9uIGlzRmFsc2lzaChjaHVuaykge1xuICByZXR1cm4gY2h1bmsgPT09IHVuZGVmaW5lZCB8fCBjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gZmFsc2UgfHwgY2h1bmsgPT09ICcnO1xufTtcblxudmFyIG9ialRvQ3NzQXJyYXkgPSBmdW5jdGlvbiBvYmpUb0Nzc0FycmF5KG9iaiwgcHJldktleSkge1xuICB2YXIgcnVsZXMgPSBbXTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFpc0ZhbHNpc2gob2JqW2tleV0pKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgcnVsZXMucHVzaC5hcHBseShydWxlcywgb2JqVG9Dc3NBcnJheShvYmpba2V5XSwga2V5KSk7XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG9ialtrZXldKSkge1xuICAgICAgICBydWxlcy5wdXNoKGh5cGhlbmF0ZVN0eWxlTmFtZShrZXkpICsgJzonLCBvYmpba2V5XSwgJzsnKTtcblxuICAgICAgICByZXR1cm4gcnVsZXM7XG4gICAgICB9XG4gICAgICBydWxlcy5wdXNoKGh5cGhlbmF0ZVN0eWxlTmFtZShrZXkpICsgJzogJyArIGFkZFVuaXRJZk5lZWRlZChrZXksIG9ialtrZXldKSArICc7Jyk7XG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbiAgfSk7XG5cbiAgcmV0dXJuIHByZXZLZXkgPyBbcHJldktleSArICcgeyddLmNvbmNhdChydWxlcywgWyd9J10pIDogcnVsZXM7XG59O1xuXG5mdW5jdGlvbiBmbGF0dGVuKGNodW5rLCBleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNodW5rKSkge1xuICAgIHZhciBydWxlU2V0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2h1bmsubGVuZ3RoLCByZXN1bHQ7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgcmVzdWx0ID0gZmxhdHRlbihjaHVua1tpXSwgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGNvbnRpbnVlO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkgcnVsZVNldC5wdXNoLmFwcGx5KHJ1bGVTZXQsIHJlc3VsdCk7ZWxzZSBydWxlU2V0LnB1c2gocmVzdWx0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnVsZVNldDtcbiAgfVxuXG4gIGlmIChpc0ZhbHNpc2goY2h1bmspKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiBIYW5kbGUgb3RoZXIgY29tcG9uZW50cyAqL1xuICBpZiAoaXNTdHlsZWRDb21wb25lbnQoY2h1bmspKSB7XG4gICAgcmV0dXJuICcuJyArIGNodW5rLnN0eWxlZENvbXBvbmVudElkO1xuICB9XG5cbiAgLyogRWl0aGVyIGV4ZWN1dGUgb3IgZGVmZXIgdGhlIGZ1bmN0aW9uICovXG4gIGlmIChpc0Z1bmN0aW9uKGNodW5rKSkge1xuICAgIGlmIChpc1N0YXRlbGVzc0Z1bmN0aW9uKGNodW5rKSAmJiBleGVjdXRpb25Db250ZXh0KSB7XG4gICAgICB2YXIgX3Jlc3VsdCA9IGNodW5rKGV4ZWN1dGlvbkNvbnRleHQpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0VsZW1lbnQoX3Jlc3VsdCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKGdldENvbXBvbmVudE5hbWUoY2h1bmspICsgJyBpcyBub3QgYSBzdHlsZWQgY29tcG9uZW50IGFuZCBjYW5ub3QgYmUgcmVmZXJyZWQgdG8gdmlhIGNvbXBvbmVudCBzZWxlY3Rvci4gU2VlIGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2FkdmFuY2VkI3JlZmVycmluZy10by1vdGhlci1jb21wb25lbnRzIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbGF0dGVuKF9yZXN1bHQsIGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpO1xuICAgIH0gZWxzZSByZXR1cm4gY2h1bms7XG4gIH1cblxuICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBLZXlmcmFtZXMpIHtcbiAgICBpZiAoc3R5bGVTaGVldCkge1xuICAgICAgY2h1bmsuaW5qZWN0KHN0eWxlU2hlZXQpO1xuICAgICAgcmV0dXJuIGNodW5rLmdldE5hbWUoKTtcbiAgICB9IGVsc2UgcmV0dXJuIGNodW5rO1xuICB9XG5cbiAgLyogSGFuZGxlIG9iamVjdHMgKi9cbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QoY2h1bmspID8gb2JqVG9Dc3NBcnJheShjaHVuaykgOiBjaHVuay50b1N0cmluZygpO1xufVxuXG4vLyBcblxuZnVuY3Rpb24gY3NzKHN0eWxlcykge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaW50ZXJwb2xhdGlvbnMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgaW50ZXJwb2xhdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24oc3R5bGVzKSB8fCBpc1BsYWluT2JqZWN0KHN0eWxlcykpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgcmV0dXJuIGZsYXR0ZW4oaW50ZXJsZWF2ZShFTVBUWV9BUlJBWSwgW3N0eWxlc10uY29uY2F0KGludGVycG9sYXRpb25zKSkpO1xuICB9XG5cbiAgLy8gJEZsb3dGaXhNZVxuICByZXR1cm4gZmxhdHRlbihpbnRlcmxlYXZlKHN0eWxlcywgaW50ZXJwb2xhdGlvbnMpKTtcbn1cblxuLy8gXG5cbmZ1bmN0aW9uIGNvbnN0cnVjdFdpdGhPcHRpb25zKGNvbXBvbmVudENvbnN0cnVjdG9yLCB0YWcpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEVNUFRZX09CSkVDVDtcblxuICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0YWcpKSB7XG4gICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcigxLCBTdHJpbmcodGFnKSk7XG4gIH1cblxuICAvKiBUaGlzIGlzIGNhbGxhYmxlIGRpcmVjdGx5IGFzIGEgdGVtcGxhdGUgZnVuY3Rpb24gKi9cbiAgLy8gJEZsb3dGaXhNZTogTm90IHR5cGVkIHRvIGF2b2lkIGRlc3RydWN0dXJpbmcgYXJndW1lbnRzXG4gIHZhciB0ZW1wbGF0ZUZ1bmN0aW9uID0gZnVuY3Rpb24gdGVtcGxhdGVGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29tcG9uZW50Q29uc3RydWN0b3IodGFnLCBvcHRpb25zLCBjc3MuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKTtcbiAgfTtcblxuICAvKiBJZiBjb25maWcgbWV0aG9kcyBhcmUgY2FsbGVkLCB3cmFwIHVwIGEgbmV3IHRlbXBsYXRlIGZ1bmN0aW9uIGFuZCBtZXJnZSBvcHRpb25zICovXG4gIHRlbXBsYXRlRnVuY3Rpb24ud2l0aENvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICByZXR1cm4gY29uc3RydWN0V2l0aE9wdGlvbnMoY29tcG9uZW50Q29uc3RydWN0b3IsIHRhZywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIGNvbmZpZykpO1xuICB9O1xuXG4gIC8qIE1vZGlmeS9pbmplY3QgbmV3IHByb3BzIGF0IHJ1bnRpbWUgKi9cbiAgdGVtcGxhdGVGdW5jdGlvbi5hdHRycyA9IGZ1bmN0aW9uIChhdHRycykge1xuICAgIHJldHVybiBjb25zdHJ1Y3RXaXRoT3B0aW9ucyhjb21wb25lbnRDb25zdHJ1Y3RvciwgdGFnLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYXR0cnM6IEFycmF5LnByb3RvdHlwZS5jb25jYXQob3B0aW9ucy5hdHRycywgYXR0cnMpLmZpbHRlcihCb29sZWFuKVxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gdGVtcGxhdGVGdW5jdGlvbjtcbn1cblxuLy8gXG4vLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9nYXJ5Y291cnQvbXVybXVyaGFzaC1qcy9ibG9iL21hc3Rlci9tdXJtdXJoYXNoMl9nYy5qc1xuZnVuY3Rpb24gbXVybXVyaGFzaChjKSB7XG4gIGZvciAodmFyIGUgPSBjLmxlbmd0aCB8IDAsIGEgPSBlIHwgMCwgZCA9IDAsIGI7IGUgPj0gNDspIHtcbiAgICBiID0gYy5jaGFyQ29kZUF0KGQpICYgMjU1IHwgKGMuY2hhckNvZGVBdCgrK2QpICYgMjU1KSA8PCA4IHwgKGMuY2hhckNvZGVBdCgrK2QpICYgMjU1KSA8PCAxNiB8IChjLmNoYXJDb2RlQXQoKytkKSAmIDI1NSkgPDwgMjQsIGIgPSAxNTQwNDgzNDc3ICogKGIgJiA2NTUzNSkgKyAoKDE1NDA0ODM0NzcgKiAoYiA+Pj4gMTYpICYgNjU1MzUpIDw8IDE2KSwgYiBePSBiID4+PiAyNCwgYiA9IDE1NDA0ODM0NzcgKiAoYiAmIDY1NTM1KSArICgoMTU0MDQ4MzQ3NyAqIChiID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpLCBhID0gMTU0MDQ4MzQ3NyAqIChhICYgNjU1MzUpICsgKCgxNTQwNDgzNDc3ICogKGEgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNikgXiBiLCBlIC09IDQsICsrZDtcbiAgfVxuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIDM6XG4gICAgICBhIF49IChjLmNoYXJDb2RlQXQoZCArIDIpICYgMjU1KSA8PCAxNjtcbiAgICBjYXNlIDI6XG4gICAgICBhIF49IChjLmNoYXJDb2RlQXQoZCArIDEpICYgMjU1KSA8PCA4O1xuICAgIGNhc2UgMTpcbiAgICAgIGEgXj0gYy5jaGFyQ29kZUF0KGQpICYgMjU1LCBhID0gMTU0MDQ4MzQ3NyAqIChhICYgNjU1MzUpICsgKCgxNTQwNDgzNDc3ICogKGEgPj4+IDE2KSAmIDY1NTM1KSA8PCAxNik7XG4gIH1cbiAgYSBePSBhID4+PiAxMztcbiAgYSA9IDE1NDA0ODM0NzcgKiAoYSAmIDY1NTM1KSArICgoMTU0MDQ4MzQ3NyAqIChhID4+PiAxNikgJiA2NTUzNSkgPDwgMTYpO1xuICByZXR1cm4gKGEgXiBhID4+PiAxNSkgPj4+IDA7XG59XG5cbi8vIFxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKiBUaGlzIGlzIHRoZSBcImNhcGFjaXR5XCIgb2Ygb3VyIGFscGhhYmV0IGkuZS4gMngyNiBmb3IgYWxsIGxldHRlcnMgcGx1cyB0aGVpciBjYXBpdGFsaXNlZFxuICogY291bnRlcnBhcnRzICovXG52YXIgY2hhcnNMZW5ndGggPSA1MjtcblxuLyogc3RhcnQgYXQgNzUgZm9yICdhJyB1bnRpbCAneicgKDI1KSBhbmQgdGhlbiBzdGFydCBhdCA2NSBmb3IgY2FwaXRhbGlzZWQgbGV0dGVycyAqL1xudmFyIGdldEFscGhhYmV0aWNDaGFyID0gZnVuY3Rpb24gZ2V0QWxwaGFiZXRpY0NoYXIoY29kZSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlICsgKGNvZGUgPiAyNSA/IDM5IDogOTcpKTtcbn07XG5cbi8qIGlucHV0IGEgbnVtYmVyLCB1c3VhbGx5IGEgaGFzaCBhbmQgY29udmVydCBpdCB0byBiYXNlLTUyICovXG5mdW5jdGlvbiBnZW5lcmF0ZUFscGhhYmV0aWNOYW1lKGNvZGUpIHtcbiAgdmFyIG5hbWUgPSAnJztcbiAgdmFyIHggPSB2b2lkIDA7XG5cbiAgLyogZ2V0IGEgY2hhciBhbmQgZGl2aWRlIGJ5IGFscGhhYmV0LWxlbmd0aCAqL1xuICBmb3IgKHggPSBjb2RlOyB4ID4gY2hhcnNMZW5ndGg7IHggPSBNYXRoLmZsb29yKHggLyBjaGFyc0xlbmd0aCkpIHtcbiAgICBuYW1lID0gZ2V0QWxwaGFiZXRpY0NoYXIoeCAlIGNoYXJzTGVuZ3RoKSArIG5hbWU7XG4gIH1cblxuICByZXR1cm4gZ2V0QWxwaGFiZXRpY0NoYXIoeCAlIGNoYXJzTGVuZ3RoKSArIG5hbWU7XG59XG5cbi8vIFxuXG5mdW5jdGlvbiBoYXNGdW5jdGlvbk9iamVjdEtleShvYmopIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbiwgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9ialtrZXldKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1N0YXRpY1J1bGVzKHJ1bGVzLCBhdHRycykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgdmFyIHJ1bGUgPSBydWxlc1tpXTtcblxuICAgIC8vIHJlY3Vyc2l2ZSBjYXNlXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocnVsZSkgJiYgIWlzU3RhdGljUnVsZXMocnVsZSwgYXR0cnMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHJ1bGUpICYmICFpc1N0eWxlZENvbXBvbmVudChydWxlKSkge1xuICAgICAgLy8gZnVuY3Rpb25zIGFyZSBhbGxvd2VkIHRvIGJlIHN0YXRpYyBpZiB0aGV5J3JlIGp1c3QgYmVpbmdcbiAgICAgIC8vIHVzZWQgdG8gZ2V0IHRoZSBjbGFzc25hbWUgb2YgYSBuZXN0ZWQgc3R5bGVkIGNvbXBvbmVudFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdHRycy5zb21lKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oeCkgfHwgaGFzRnVuY3Rpb25PYmplY3RLZXkoeCk7XG4gIH0pKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFxuXG4vKiBjb21iaW5lcyBoYXNoU3RyIChtdXJtdXJoYXNoKSBhbmQgbmFtZUdlbmVyYXRvciBmb3IgY29udmVuaWVuY2UgKi9cbnZhciBoYXNoZXIgPSBmdW5jdGlvbiBoYXNoZXIoc3RyKSB7XG4gIHJldHVybiBnZW5lcmF0ZUFscGhhYmV0aWNOYW1lKG11cm11cmhhc2goc3RyKSk7XG59O1xuXG4vKlxuIENvbXBvbmVudFN0eWxlIGlzIGFsbCB0aGUgQ1NTLXNwZWNpZmljIHN0dWZmLCBub3RcbiB0aGUgUmVhY3Qtc3BlY2lmaWMgc3R1ZmYuXG4gKi9cblxudmFyIENvbXBvbmVudFN0eWxlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb25lbnRTdHlsZShydWxlcywgYXR0cnMsIGNvbXBvbmVudElkKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50U3R5bGUpO1xuXG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMuaXNTdGF0aWMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIGlzU3RhdGljUnVsZXMocnVsZXMsIGF0dHJzKTtcbiAgICB0aGlzLmNvbXBvbmVudElkID0gY29tcG9uZW50SWQ7XG5cbiAgICBpZiAoIVN0eWxlU2hlZXQubWFzdGVyLmhhc0lkKGNvbXBvbmVudElkKSkge1xuICAgICAgU3R5bGVTaGVldC5tYXN0ZXIuZGVmZXJyZWRJbmplY3QoY29tcG9uZW50SWQsIFtdKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBGbGF0dGVucyBhIHJ1bGUgc2V0IGludG8gdmFsaWQgQ1NTXG4gICAqIEhhc2hlcyBpdCwgd3JhcHMgdGhlIHdob2xlIGNodW5rIGluIGEgLmhhc2gxMjM0IHt9XG4gICAqIFJldHVybnMgdGhlIGhhc2ggdG8gYmUgaW5qZWN0ZWQgb24gcmVuZGVyKClcbiAgICogKi9cblxuXG4gIENvbXBvbmVudFN0eWxlLnByb3RvdHlwZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyA9IGZ1bmN0aW9uIGdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpIHtcbiAgICB2YXIgaXNTdGF0aWMgPSB0aGlzLmlzU3RhdGljLFxuICAgICAgICBjb21wb25lbnRJZCA9IHRoaXMuY29tcG9uZW50SWQsXG4gICAgICAgIGxhc3RDbGFzc05hbWUgPSB0aGlzLmxhc3RDbGFzc05hbWU7XG5cbiAgICBpZiAoSVNfQlJPV1NFUiAmJiBpc1N0YXRpYyAmJiB0eXBlb2YgbGFzdENsYXNzTmFtZSA9PT0gJ3N0cmluZycgJiYgc3R5bGVTaGVldC5oYXNOYW1lRm9ySWQoY29tcG9uZW50SWQsIGxhc3RDbGFzc05hbWUpKSB7XG4gICAgICByZXR1cm4gbGFzdENsYXNzTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgZmxhdENTUyA9IGZsYXR0ZW4odGhpcy5ydWxlcywgZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCk7XG4gICAgdmFyIG5hbWUgPSBoYXNoZXIodGhpcy5jb21wb25lbnRJZCArIGZsYXRDU1Muam9pbignJykpO1xuICAgIGlmICghc3R5bGVTaGVldC5oYXNOYW1lRm9ySWQoY29tcG9uZW50SWQsIG5hbWUpKSB7XG4gICAgICBzdHlsZVNoZWV0LmluamVjdCh0aGlzLmNvbXBvbmVudElkLCBzdHJpbmdpZnlSdWxlcyhmbGF0Q1NTLCAnLicgKyBuYW1lLCB1bmRlZmluZWQsIGNvbXBvbmVudElkKSwgbmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Q2xhc3NOYW1lID0gbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuICBDb21wb25lbnRTdHlsZS5nZW5lcmF0ZU5hbWUgPSBmdW5jdGlvbiBnZW5lcmF0ZU5hbWUoc3RyKSB7XG4gICAgcmV0dXJuIGhhc2hlcihzdHIpO1xuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnRTdHlsZTtcbn0oKTtcblxuLy8gXG5cbnZhciBMSU1JVCA9IDIwMDtcblxudmFyIGNyZWF0ZVdhcm5Ub29NYW55Q2xhc3NlcyA9IChmdW5jdGlvbiAoZGlzcGxheU5hbWUpIHtcbiAgdmFyIGdlbmVyYXRlZENsYXNzZXMgPSB7fTtcbiAgdmFyIHdhcm5pbmdTZWVuID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICBpZiAoIXdhcm5pbmdTZWVuKSB7XG4gICAgICBnZW5lcmF0ZWRDbGFzc2VzW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGdlbmVyYXRlZENsYXNzZXMpLmxlbmd0aCA+PSBMSU1JVCkge1xuICAgICAgICAvLyBVbmFibGUgdG8gZmluZCBsYXRlc3RSdWxlIGluIHRlc3QgZW52aXJvbm1lbnQuXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUsIHByZWZlci10ZW1wbGF0ZSAqL1xuICAgICAgICBjb25zb2xlLndhcm4oJ092ZXIgJyArIExJTUlUICsgJyBjbGFzc2VzIHdlcmUgZ2VuZXJhdGVkIGZvciBjb21wb25lbnQgJyArIGRpc3BsYXlOYW1lICsgJy4gXFxuJyArICdDb25zaWRlciB1c2luZyB0aGUgYXR0cnMgbWV0aG9kLCB0b2dldGhlciB3aXRoIGEgc3R5bGUgb2JqZWN0IGZvciBmcmVxdWVudGx5IGNoYW5nZWQgc3R5bGVzLlxcbicgKyAnRXhhbXBsZTpcXG4nICsgJyAgY29uc3QgQ29tcG9uZW50ID0gc3R5bGVkLmRpdi5hdHRycyhwcm9wcyA9PiAoe1xcbicgKyAnICAgIHN0eWxlOiB7XFxuJyArICcgICAgICBiYWNrZ3JvdW5kOiBwcm9wcy5iYWNrZ3JvdW5kLFxcbicgKyAnICAgIH0sXFxuJyArICcgIH0pKWB3aWR0aDogMTAwJTtgXFxuXFxuJyArICcgIDxDb21wb25lbnQgLz4nKTtcbiAgICAgICAgd2FybmluZ1NlZW4gPSB0cnVlO1xuICAgICAgICBnZW5lcmF0ZWRDbGFzc2VzID0ge307XG4gICAgICB9XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIFxuXG52YXIgZGV0ZXJtaW5lVGhlbWUgPSAoZnVuY3Rpb24gKHByb3BzLCBmYWxsYmFja1RoZW1lKSB7XG4gIHZhciBkZWZhdWx0UHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IEVNUFRZX09CSkVDVDtcblxuICAvLyBQcm9wcyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgVGhlbWVQcm92aWRlciwgd2hpY2ggc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyXG4gIC8vIGRlZmF1bHRQcm9wcywgYnV0IFJlYWN0IGF1dG9tYXRpY2FsbHkgcHV0cyBkZWZhdWx0UHJvcHMgb24gcHJvcHMuXG5cbiAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QvcHJvcC10eXBlcywgZmxvd3R5cGUtZXJyb3JzL3Nob3ctZXJyb3JzICovXG4gIHZhciBpc0RlZmF1bHRUaGVtZSA9IGRlZmF1bHRQcm9wcyA/IHByb3BzLnRoZW1lID09PSBkZWZhdWx0UHJvcHMudGhlbWUgOiBmYWxzZTtcbiAgdmFyIHRoZW1lID0gcHJvcHMudGhlbWUgJiYgIWlzRGVmYXVsdFRoZW1lID8gcHJvcHMudGhlbWUgOiBmYWxsYmFja1RoZW1lIHx8IGRlZmF1bHRQcm9wcy50aGVtZTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIHJldHVybiB0aGVtZTtcbn0pO1xuXG4vLyBcbnZhciBlc2NhcGVSZWdleCA9IC9bW1xcXS4jKiQ+PCt+PXxeOigpLFwiJ2AtXSsvZztcbnZhciBkYXNoZXNBdEVuZHMgPSAvKF4tfC0kKS9nO1xuXG4vKipcbiAqIFRPRE86IEV4cGxvcmUgdXNpbmcgQ1NTLmVzY2FwZSB3aGVuIGl0IGJlY29tZXMgbW9yZSBhdmFpbGFibGVcbiAqIGluIGV2ZXJncmVlbiBicm93c2Vycy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHN0cikge1xuICByZXR1cm4gc3RyXG4gIC8vIFJlcGxhY2UgYWxsIHBvc3NpYmxlIENTUyBzZWxlY3RvcnNcbiAgLnJlcGxhY2UoZXNjYXBlUmVnZXgsICctJylcblxuICAvLyBSZW1vdmUgZXh0cmFuZW91cyBoeXBoZW5zIGF0IHRoZSBzdGFydCBhbmQgZW5kXG4gIC5yZXBsYWNlKGRhc2hlc0F0RW5kcywgJycpO1xufVxuXG4vLyBcblxuZnVuY3Rpb24gaXNUYWcodGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHRhcmdldC5jaGFyQXQoMCkgPT09IHRhcmdldC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSA6IHRydWUpO1xufVxuXG4vLyBcblxuZnVuY3Rpb24gZ2VuZXJhdGVEaXNwbGF5TmFtZSh0YXJnZXQpIHtcbiAgLy8gJEZsb3dGaXhNZVxuICByZXR1cm4gaXNUYWcodGFyZ2V0KSA/ICdzdHlsZWQuJyArIHRhcmdldCA6ICdTdHlsZWQoJyArIGdldENvbXBvbmVudE5hbWUodGFyZ2V0KSArICcpJztcbn1cblxudmFyIF9UWVBFX1NUQVRJQ1M7XG5cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcblxudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcblxudmFyIFRZUEVfU1RBVElDUyA9IChfVFlQRV9TVEFUSUNTID0ge30sIF9UWVBFX1NUQVRJQ1NbRm9yd2FyZFJlZl0gPSB7XG4gICQkdHlwZW9mOiB0cnVlLFxuICByZW5kZXI6IHRydWVcbn0sIF9UWVBFX1NUQVRJQ1MpO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsXG4gICAgX09iamVjdCRnZXRPd25Qcm9wZXJ0ID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBfT2JqZWN0JGdldE93blByb3BlcnQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFtdO1xufSA6IF9PYmplY3QkZ2V0T3duUHJvcGVydCxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgYXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cblxuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGFycmF5UHJvdG90eXBlLmNvbmNhdChnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCksXG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcblxuICAgIHZhciB0YXJnZXRTdGF0aWNzID0gVFlQRV9TVEFUSUNTW3RhcmdldENvbXBvbmVudC4kJHR5cGVvZl0gfHwgUkVBQ1RfU1RBVElDUztcblxuICAgIHZhciBzb3VyY2VTdGF0aWNzID0gVFlQRV9TVEFUSUNTW3NvdXJjZUNvbXBvbmVudC4kJHR5cGVvZl0gfHwgUkVBQ1RfU1RBVElDUztcblxuICAgIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSB2b2lkIDA7XG4gICAgdmFyIGtleSA9IHZvaWQgMDtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShibGFja2xpc3QgJiYgYmxhY2tsaXN0W2tleV0pICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmXG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcblxuICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSQxKHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBmYWlsIHNpbGVudGx5ICovXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbi8vIFxuZnVuY3Rpb24gaXNEZXJpdmVkUmVhY3RDb21wb25lbnQoZm4pIHtcbiAgcmV0dXJuICEhKGZuICYmIGZuLnByb3RvdHlwZSAmJiBmbi5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbi8vIFxuLy8gSGVscGVyIHRvIGNhbGwgYSBnaXZlbiBmdW5jdGlvbiwgb25seSBvbmNlXG52YXIgb25jZSA9IChmdW5jdGlvbiAoY2IpIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8vIFxuXG52YXIgVGhlbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuXG52YXIgVGhlbWVDb25zdW1lciA9IFRoZW1lQ29udGV4dC5Db25zdW1lcjtcblxuLyoqXG4gKiBQcm92aWRlIGEgdGhlbWUgdG8gYW4gZW50aXJlIHJlYWN0IGNvbXBvbmVudCB0cmVlIHZpYSBjb250ZXh0XG4gKi9cblxudmFyIFRoZW1lUHJvdmlkZXIgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBpbmhlcml0cyhUaGVtZVByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBUaGVtZVByb3ZpZGVyKHByb3BzKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgVGhlbWVQcm92aWRlcik7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgX3RoaXMuZ2V0Q29udGV4dCA9IG1lbW9pemUoX3RoaXMuZ2V0Q29udGV4dC5iaW5kKF90aGlzKSk7XG4gICAgX3RoaXMucmVuZGVySW5uZXIgPSBfdGhpcy5yZW5kZXJJbm5lci5iaW5kKF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUaGVtZVByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLmNoaWxkcmVuKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgVGhlbWVDb250ZXh0LkNvbnN1bWVyLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMucmVuZGVySW5uZXJcbiAgICApO1xuICB9O1xuXG4gIFRoZW1lUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlcklubmVyID0gZnVuY3Rpb24gcmVuZGVySW5uZXIob3V0ZXJUaGVtZSkge1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KHRoaXMucHJvcHMudGhlbWUsIG91dGVyVGhlbWUpO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBUaGVtZUNvbnRleHQuUHJvdmlkZXIsXG4gICAgICB7IHZhbHVlOiBjb250ZXh0IH0sXG4gICAgICB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHRoZSB0aGVtZSBmcm9tIHRoZSBwcm9wcywgc3VwcG9ydGluZyBib3RoIChvdXRlclRoZW1lKSA9PiB7fVxuICAgKiBhcyB3ZWxsIGFzIG9iamVjdCBub3RhdGlvblxuICAgKi9cblxuXG4gIFRoZW1lUHJvdmlkZXIucHJvdG90eXBlLmdldFRoZW1lID0gZnVuY3Rpb24gZ2V0VGhlbWUodGhlbWUsIG91dGVyVGhlbWUpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGVtZSkpIHtcbiAgICAgIHZhciBtZXJnZWRUaGVtZSA9IHRoZW1lKG91dGVyVGhlbWUpO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAobWVyZ2VkVGhlbWUgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShtZXJnZWRUaGVtZSkgfHwgKHR5cGVvZiBtZXJnZWRUaGVtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YobWVyZ2VkVGhlbWUpKSAhPT0gJ29iamVjdCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoNyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWRUaGVtZTtcbiAgICB9XG5cbiAgICBpZiAodGhlbWUgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheSh0aGVtZSkgfHwgKHR5cGVvZiB0aGVtZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGhlbWUpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoOCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBvdXRlclRoZW1lLCB0aGVtZSk7XG4gIH07XG5cbiAgVGhlbWVQcm92aWRlci5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQodGhlbWUsIG91dGVyVGhlbWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRUaGVtZSh0aGVtZSwgb3V0ZXJUaGVtZSk7XG4gIH07XG5cbiAgcmV0dXJuIFRoZW1lUHJvdmlkZXI7XG59KENvbXBvbmVudCk7XG5cbi8vIFxuXG52YXIgQ0xPU0lOR19UQUdfUiA9IC9eXFxzKjxcXC9bYS16XS9pO1xuXG52YXIgU2VydmVyU3R5bGVTaGVldCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2VydmVyU3R5bGVTaGVldCgpIHtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBTZXJ2ZXJTdHlsZVNoZWV0KTtcblxuICAgIC8qIFRoZSBtYXN0ZXIgc2hlZXQgbWlnaHQgYmUgcmVzZXQsIHNvIGtlZXAgYSByZWZlcmVuY2UgaGVyZSAqL1xuICAgIHRoaXMubWFzdGVyU2hlZXQgPSBTdHlsZVNoZWV0Lm1hc3RlcjtcbiAgICB0aGlzLmluc3RhbmNlID0gdGhpcy5tYXN0ZXJTaGVldC5jbG9uZSgpO1xuICAgIHRoaXMuc2VhbGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGUgU2VydmVyU3R5bGVTaGVldCBhcyBiZWluZyBmdWxseSBlbWl0dGVkIGFuZCBtYW51YWxseSBHQyBpdCBmcm9tIHRoZVxuICAgKiBTdHlsZVNoZWV0IHNpbmdsZXRvbi5cbiAgICovXG5cblxuICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5zZWFsID0gZnVuY3Rpb24gc2VhbCgpIHtcbiAgICBpZiAoIXRoaXMuc2VhbGVkKSB7XG4gICAgICAvKiBSZW1vdmUgc2VhbGVkIFN0eWxlU2hlZXRzIGZyb20gdGhlIG1hc3RlciBzaGVldCAqL1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5tYXN0ZXJTaGVldC5jbG9uZXMuaW5kZXhPZih0aGlzLmluc3RhbmNlKTtcbiAgICAgIHRoaXMubWFzdGVyU2hlZXQuY2xvbmVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLnNlYWxlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIFNlcnZlclN0eWxlU2hlZXQucHJvdG90eXBlLmNvbGxlY3RTdHlsZXMgPSBmdW5jdGlvbiBjb2xsZWN0U3R5bGVzKGNoaWxkcmVuKSB7XG4gICAgaWYgKHRoaXMuc2VhbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3R5bGVkQ29tcG9uZW50c0Vycm9yKDIpO1xuICAgIH1cblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU3R5bGVTaGVldE1hbmFnZXIsXG4gICAgICB7IHNoZWV0OiB0aGlzLmluc3RhbmNlIH0sXG4gICAgICBjaGlsZHJlblxuICAgICk7XG4gIH07XG5cbiAgU2VydmVyU3R5bGVTaGVldC5wcm90b3R5cGUuZ2V0U3R5bGVUYWdzID0gZnVuY3Rpb24gZ2V0U3R5bGVUYWdzKCkge1xuICAgIHRoaXMuc2VhbCgpO1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLnRvSFRNTCgpO1xuICB9O1xuXG4gIFNlcnZlclN0eWxlU2hlZXQucHJvdG90eXBlLmdldFN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIGdldFN0eWxlRWxlbWVudCgpIHtcbiAgICB0aGlzLnNlYWwoKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS50b1JlYWN0RWxlbWVudHMoKTtcbiAgfTtcblxuICBTZXJ2ZXJTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW0gPSBmdW5jdGlvbiBpbnRlcmxlYXZlV2l0aE5vZGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKElTX0JST1dTRVIpIHtcbiAgICAgIHRocm93IG5ldyBTdHlsZWRDb21wb25lbnRzRXJyb3IoMyk7XG4gICAgfVxuXG4gICAgLyogdGhlIHRhZyBpbmRleCBrZWVwcyB0cmFjayBvZiB3aGljaCB0YWdzIGhhdmUgYWxyZWFkeSBiZWVuIGVtaXR0ZWQgKi9cbiAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXG4gICAgdmFyIGluc3RhbmNlVGFnSW5kZXggPSAwO1xuXG4gICAgdmFyIHN0cmVhbUF0dHIgPSBTQ19TVFJFQU1fQVRUUiArICc9XCJ0cnVlXCInO1xuXG4gICAgdmFyIHRyYW5zZm9ybWVyID0gbmV3IHN0cmVhbS5UcmFuc2Zvcm0oe1xuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiBhcHBlbmRTdHlsZUNodW5rcyhjaHVuaywgLyogZW5jb2RpbmcgKi9fLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdGFncyA9IGluc3RhbmNlLnRhZ3M7XG5cbiAgICAgICAgdmFyIGh0bWwgPSAnJztcblxuICAgICAgICAvKiByZXRyaWV2ZSBodG1sIGZvciBlYWNoIG5ldyBzdHlsZSB0YWcgKi9cbiAgICAgICAgZm9yICg7IGluc3RhbmNlVGFnSW5kZXggPCB0YWdzLmxlbmd0aDsgaW5zdGFuY2VUYWdJbmRleCArPSAxKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHRhZ3NbaW5zdGFuY2VUYWdJbmRleF07XG4gICAgICAgICAgaHRtbCArPSB0YWcudG9IVE1MKHN0cmVhbUF0dHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogZm9yY2Ugb3VyIFN0eWxlU2hlZXRzIHRvIGVtaXQgZW50aXJlbHkgbmV3IHRhZ3MgKi9cbiAgICAgICAgaW5zdGFuY2Uuc2VhbEFsbFRhZ3MoKTtcblxuICAgICAgICB2YXIgcmVuZGVyZWRIdG1sID0gY2h1bmsudG9TdHJpbmcoKTtcblxuICAgICAgICAvKiBwcmVwZW5kIHN0eWxlIGh0bWwgdG8gY2h1bmssIHVubGVzcyB0aGUgc3RhcnQgb2YgdGhlIGNodW5rIGlzIGEgY2xvc2luZyB0YWcgaW4gd2hpY2ggY2FzZSBhcHBlbmQgcmlnaHQgYWZ0ZXIgdGhhdCAqL1xuICAgICAgICBpZiAoQ0xPU0lOR19UQUdfUi50ZXN0KHJlbmRlcmVkSHRtbCkpIHtcbiAgICAgICAgICB2YXIgZW5kT2ZDbG9zaW5nVGFnID0gcmVuZGVyZWRIdG1sLmluZGV4T2YoJz4nKTtcblxuICAgICAgICAgIHRoaXMucHVzaChyZW5kZXJlZEh0bWwuc2xpY2UoMCwgZW5kT2ZDbG9zaW5nVGFnICsgMSkgKyBodG1sICsgcmVuZGVyZWRIdG1sLnNsaWNlKGVuZE9mQ2xvc2luZ1RhZyArIDEpKTtcbiAgICAgICAgfSBlbHNlIHRoaXMucHVzaChodG1sICsgcmVuZGVyZWRIdG1sKTtcblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhZGFibGVTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5zZWFsKCk7XG4gICAgfSk7XG5cbiAgICByZWFkYWJsZVN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBfdGhpcy5zZWFsKCk7XG5cbiAgICAgIC8vIGZvcndhcmQgdGhlIGVycm9yIHRvIHRoZSB0cmFuc2Zvcm0gc3RyZWFtXG4gICAgICB0cmFuc2Zvcm1lci5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVhZGFibGVTdHJlYW0ucGlwZSh0cmFuc2Zvcm1lcik7XG4gIH07XG5cbiAgcmV0dXJuIFNlcnZlclN0eWxlU2hlZXQ7XG59KCk7XG5cbi8vIFxuXG52YXIgU3R5bGVTaGVldENvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG52YXIgU3R5bGVTaGVldENvbnN1bWVyID0gU3R5bGVTaGVldENvbnRleHQuQ29uc3VtZXI7XG5cbnZhciBTdHlsZVNoZWV0TWFuYWdlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFN0eWxlU2hlZXRNYW5hZ2VyLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTdHlsZVNoZWV0TWFuYWdlcihwcm9wcykge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlU2hlZXRNYW5hZ2VyKTtcblxuICAgIHZhciBfdGhpcyA9IHBvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICBfdGhpcy5nZXRDb250ZXh0ID0gbWVtb2l6ZShfdGhpcy5nZXRDb250ZXh0KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTdHlsZVNoZWV0TWFuYWdlci5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQoc2hlZXQsIHRhcmdldCkge1xuICAgIGlmIChzaGVldCkge1xuICAgICAgcmV0dXJuIHNoZWV0O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gbmV3IFN0eWxlU2hlZXQodGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN0eWxlZENvbXBvbmVudHNFcnJvcig0KTtcbiAgICB9XG4gIH07XG5cbiAgU3R5bGVTaGVldE1hbmFnZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIHNoZWV0ID0gX3Byb3BzLnNoZWV0LFxuICAgICAgICB0YXJnZXQgPSBfcHJvcHMudGFyZ2V0O1xuXG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFN0eWxlU2hlZXRDb250ZXh0LlByb3ZpZGVyLFxuICAgICAgeyB2YWx1ZTogdGhpcy5nZXRDb250ZXh0KHNoZWV0LCB0YXJnZXQpIH0sXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBjaGlsZHJlblxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXRNYW5hZ2VyO1xufShDb21wb25lbnQpO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU3R5bGVTaGVldE1hbmFnZXIucHJvcFR5cGVzID0ge1xuICBzaGVldDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmluc3RhbmNlT2YoU3R5bGVTaGVldCksIFByb3BUeXBlcy5pbnN0YW5jZU9mKFNlcnZlclN0eWxlU2hlZXQpXSksXG5cbiAgdGFyZ2V0OiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGFwcGVuZENoaWxkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXG4gIH0pXG59IDogdm9pZCAwO1xuXG4vLyBcblxudmFyIGlkZW50aWZpZXJzID0ge307XG5cbi8qIFdlIGRlcGVuZCBvbiBjb21wb25lbnRzIGhhdmluZyB1bmlxdWUgSURzICovXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKF9Db21wb25lbnRTdHlsZSwgX2Rpc3BsYXlOYW1lLCBwYXJlbnRDb21wb25lbnRJZCkge1xuICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgX2Rpc3BsYXlOYW1lICE9PSAnc3RyaW5nJyA/ICdzYycgOiBlc2NhcGUoX2Rpc3BsYXlOYW1lKTtcblxuICAvKipcbiAgICogVGhpcyBlbnN1cmVzIHVuaXF1ZW5lc3MgaWYgdHdvIGNvbXBvbmVudHMgaGFwcGVuIHRvIHNoYXJlXG4gICAqIHRoZSBzYW1lIGRpc3BsYXlOYW1lLlxuICAgKi9cbiAgdmFyIG5yID0gKGlkZW50aWZpZXJzW2Rpc3BsYXlOYW1lXSB8fCAwKSArIDE7XG4gIGlkZW50aWZpZXJzW2Rpc3BsYXlOYW1lXSA9IG5yO1xuXG4gIHZhciBjb21wb25lbnRJZCA9IGRpc3BsYXlOYW1lICsgJy0nICsgX0NvbXBvbmVudFN0eWxlLmdlbmVyYXRlTmFtZShkaXNwbGF5TmFtZSArIG5yKTtcblxuICByZXR1cm4gcGFyZW50Q29tcG9uZW50SWQgPyBwYXJlbnRDb21wb25lbnRJZCArICctJyArIGNvbXBvbmVudElkIDogY29tcG9uZW50SWQ7XG59XG5cbi8vICRGbG93Rml4TWVcblxudmFyIFN0eWxlZENvbXBvbmVudCA9IGZ1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIGluaGVyaXRzKFN0eWxlZENvbXBvbmVudCwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3R5bGVkQ29tcG9uZW50KCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlZENvbXBvbmVudCk7XG5cbiAgICB2YXIgX3RoaXMgPSBwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9Db21wb25lbnQuY2FsbCh0aGlzKSk7XG5cbiAgICBfdGhpcy5hdHRycyA9IHt9O1xuXG4gICAgX3RoaXMucmVuZGVyT3V0ZXIgPSBfdGhpcy5yZW5kZXJPdXRlci5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5yZW5kZXJJbm5lciA9IF90aGlzLnJlbmRlcklubmVyLmJpbmQoX3RoaXMpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIF90aGlzLndhcm5Jbm5lclJlZiA9IG9uY2UoZnVuY3Rpb24gKGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBcImlubmVyUmVmXCIgQVBJIGhhcyBiZWVuIHJlbW92ZWQgaW4gc3R5bGVkLWNvbXBvbmVudHMgdjQgaW4gZmF2b3Igb2YgUmVhY3QgMTYgcmVmIGZvcndhcmRpbmcsIHVzZSBcInJlZlwiIGluc3RlYWQgbGlrZSBhIHR5cGljYWwgY29tcG9uZW50LiBcImlubmVyUmVmXCIgd2FzIGRldGVjdGVkIG9uIGNvbXBvbmVudCBcIicgKyBkaXNwbGF5TmFtZSArICdcIi4nKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIF90aGlzLndhcm5BdHRyc0ZuT2JqZWN0S2V5RGVwcmVjYXRlZCA9IG9uY2UoZnVuY3Rpb24gKGtleSwgZGlzcGxheU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUud2FybignRnVuY3Rpb25zIGFzIG9iamVjdC1mb3JtIGF0dHJzKHt9KSBrZXlzIGFyZSBub3cgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2Ygc3R5bGVkLWNvbXBvbmVudHMuIFN3aXRjaCB0byB0aGUgbmV3IGF0dHJzKHByb3BzID0+ICh7fSkpIHN5bnRheCBpbnN0ZWFkIGZvciBlYXNpZXIgYW5kIG1vcmUgcG93ZXJmdWwgY29tcG9zaXRpb24uIFRoZSBhdHRycyBrZXkgaW4gcXVlc3Rpb24gaXMgXCInICsga2V5ICsgJ1wiIG9uIGNvbXBvbmVudCBcIicgKyBkaXNwbGF5TmFtZSArICdcIi4nLCAnXFxuICcgKyBuZXcgRXJyb3IoKS5zdGFjaylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBfdGhpcy53YXJuTm9uU3R5bGVkQ29tcG9uZW50QXR0cnNPYmplY3RLZXkgPSBvbmNlKGZ1bmN0aW9uIChrZXksIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0l0IGxvb2tzIGxpa2UgeW91XFwndmUgdXNlZCBhIG5vbiBzdHlsZWQtY29tcG9uZW50IGFzIHRoZSB2YWx1ZSBmb3IgdGhlIFwiJyArIGtleSArICdcIiBwcm9wIGluIGFuIG9iamVjdC1mb3JtIGF0dHJzIGNvbnN0cnVjdG9yIG9mIFwiJyArIGRpc3BsYXlOYW1lICsgJ1wiLlxcbicgKyAnWW91IHNob3VsZCB1c2UgdGhlIG5ldyBmdW5jdGlvbi1mb3JtIGF0dHJzIGNvbnN0cnVjdG9yIHdoaWNoIGF2b2lkcyB0aGlzIGlzc3VlOiBhdHRycyhwcm9wcyA9PiAoeyB5b3VyU3R1ZmYgfSkpXFxuJyArIFwiVG8gY29udGludWUgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgb2JqZWN0IHN5bnRheCwgeW91J2xsIG5lZWQgdG8gd3JhcCB5b3VyIGNvbXBvbmVudCBwcm9wIGluIGEgZnVuY3Rpb24gdG8gbWFrZSBpdCBhdmFpbGFibGUgaW5zaWRlIHRoZSBzdHlsZWQgY29tcG9uZW50ICh5b3UnbGwgc3RpbGwgZ2V0IHRoZSBkZXByZWNhdGlvbiB3YXJuaW5nIHRob3VnaC4pXFxuXCIgKyAoJ0ZvciBleGFtcGxlLCB7ICcgKyBrZXkgKyAnOiAoKSA9PiBJbm5lckNvbXBvbmVudCB9IGluc3RlYWQgb2YgeyAnICsga2V5ICsgJzogSW5uZXJDb21wb25lbnQgfScpKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFN0eWxlZENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgU3R5bGVTaGVldENvbnN1bWVyLFxuICAgICAgbnVsbCxcbiAgICAgIHRoaXMucmVuZGVyT3V0ZXJcbiAgICApO1xuICB9O1xuXG4gIFN0eWxlZENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyT3V0ZXIgPSBmdW5jdGlvbiByZW5kZXJPdXRlcigpIHtcbiAgICB2YXIgc3R5bGVTaGVldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogU3R5bGVTaGVldC5tYXN0ZXI7XG5cbiAgICB0aGlzLnN0eWxlU2hlZXQgPSBzdHlsZVNoZWV0O1xuXG4gICAgLy8gTm8gbmVlZCB0byBzdWJzY3JpYmUgYSBzdGF0aWMgY29tcG9uZW50IHRvIHRoZW1lIGNoYW5nZXMsIGl0IHdvbid0IGNoYW5nZSBhbnl0aGluZ1xuICAgIGlmICh0aGlzLnByb3BzLmZvcndhcmRlZENvbXBvbmVudC5jb21wb25lbnRTdHlsZS5pc1N0YXRpYykgcmV0dXJuIHRoaXMucmVuZGVySW5uZXIoKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgVGhlbWVDb25zdW1lcixcbiAgICAgIG51bGwsXG4gICAgICB0aGlzLnJlbmRlcklubmVyXG4gICAgKTtcbiAgfTtcblxuICBTdHlsZWRDb21wb25lbnQucHJvdG90eXBlLnJlbmRlcklubmVyID0gZnVuY3Rpb24gcmVuZGVySW5uZXIodGhlbWUpIHtcbiAgICB2YXIgX3Byb3BzJGZvcndhcmRlZENvbXBvID0gdGhpcy5wcm9wcy5mb3J3YXJkZWRDb21wb25lbnQsXG4gICAgICAgIGNvbXBvbmVudFN0eWxlID0gX3Byb3BzJGZvcndhcmRlZENvbXBvLmNvbXBvbmVudFN0eWxlLFxuICAgICAgICBkZWZhdWx0UHJvcHMgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8uZGVmYXVsdFByb3BzLFxuICAgICAgICBkaXNwbGF5TmFtZSA9IF9wcm9wcyRmb3J3YXJkZWRDb21wby5kaXNwbGF5TmFtZSxcbiAgICAgICAgZm9sZGVkQ29tcG9uZW50SWRzID0gX3Byb3BzJGZvcndhcmRlZENvbXBvLmZvbGRlZENvbXBvbmVudElkcyxcbiAgICAgICAgc3R5bGVkQ29tcG9uZW50SWQgPSBfcHJvcHMkZm9yd2FyZGVkQ29tcG8uc3R5bGVkQ29tcG9uZW50SWQsXG4gICAgICAgIHRhcmdldCA9IF9wcm9wcyRmb3J3YXJkZWRDb21wby50YXJnZXQ7XG5cblxuICAgIHZhciBnZW5lcmF0ZWRDbGFzc05hbWUgPSB2b2lkIDA7XG4gICAgaWYgKGNvbXBvbmVudFN0eWxlLmlzU3RhdGljKSB7XG4gICAgICBnZW5lcmF0ZWRDbGFzc05hbWUgPSB0aGlzLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKEVNUFRZX09CSkVDVCwgdGhpcy5wcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbmVyYXRlZENsYXNzTmFtZSA9IHRoaXMuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXMoZGV0ZXJtaW5lVGhlbWUodGhpcy5wcm9wcywgdGhlbWUsIGRlZmF1bHRQcm9wcykgfHwgRU1QVFlfT0JKRUNULCB0aGlzLnByb3BzKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudFRvQmVDcmVhdGVkID0gdGhpcy5wcm9wcy5hcyB8fCB0aGlzLmF0dHJzLmFzIHx8IHRhcmdldDtcbiAgICB2YXIgaXNUYXJnZXRUYWcgPSBpc1RhZyhlbGVtZW50VG9CZUNyZWF0ZWQpO1xuXG4gICAgdmFyIHByb3BzRm9yRWxlbWVudCA9IHt9O1xuICAgIHZhciBjb21wdXRlZFByb3BzID0gX2V4dGVuZHMoe30sIHRoaXMucHJvcHMsIHRoaXMuYXR0cnMpO1xuXG4gICAgdmFyIGtleSA9IHZvaWQgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgZm9yIChrZXkgaW4gY29tcHV0ZWRQcm9wcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYga2V5ID09PSAnaW5uZXJSZWYnICYmIGlzVGFyZ2V0VGFnKSB7XG4gICAgICAgIHRoaXMud2FybklubmVyUmVmKGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PT0gJ2ZvcndhcmRlZENvbXBvbmVudCcgfHwga2V5ID09PSAnYXMnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdmb3J3YXJkZWRSZWYnKSBwcm9wc0ZvckVsZW1lbnQucmVmID0gY29tcHV0ZWRQcm9wc1trZXldO2Vsc2UgaWYgKGtleSA9PT0gJ2ZvcndhcmRlZEFzJykgcHJvcHNGb3JFbGVtZW50LmFzID0gY29tcHV0ZWRQcm9wc1trZXldO2Vsc2UgaWYgKCFpc1RhcmdldFRhZyB8fCB2YWxpZEF0dHIoa2V5KSkge1xuICAgICAgICAvLyBEb24ndCBwYXNzIHRocm91Z2ggbm9uIEhUTUwgdGFncyB0aHJvdWdoIHRvIEhUTUwgZWxlbWVudHNcbiAgICAgICAgcHJvcHNGb3JFbGVtZW50W2tleV0gPSBjb21wdXRlZFByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuc3R5bGUgJiYgdGhpcy5hdHRycy5zdHlsZSkge1xuICAgICAgcHJvcHNGb3JFbGVtZW50LnN0eWxlID0gX2V4dGVuZHMoe30sIHRoaXMuYXR0cnMuc3R5bGUsIHRoaXMucHJvcHMuc3R5bGUpO1xuICAgIH1cblxuICAgIHByb3BzRm9yRWxlbWVudC5jbGFzc05hbWUgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0KGZvbGRlZENvbXBvbmVudElkcywgc3R5bGVkQ29tcG9uZW50SWQsIGdlbmVyYXRlZENsYXNzTmFtZSAhPT0gc3R5bGVkQ29tcG9uZW50SWQgPyBnZW5lcmF0ZWRDbGFzc05hbWUgOiBudWxsLCB0aGlzLnByb3BzLmNsYXNzTmFtZSwgdGhpcy5hdHRycy5jbGFzc05hbWUpLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJyk7XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChlbGVtZW50VG9CZUNyZWF0ZWQsIHByb3BzRm9yRWxlbWVudCk7XG4gIH07XG5cbiAgU3R5bGVkQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZEV4ZWN1dGlvbkNvbnRleHQgPSBmdW5jdGlvbiBidWlsZEV4ZWN1dGlvbkNvbnRleHQodGhlbWUsIHByb3BzLCBhdHRycykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGNvbnRleHQgPSBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgdGhlbWU6IHRoZW1lIH0pO1xuXG4gICAgaWYgKCFhdHRycy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuXG4gICAgdGhpcy5hdHRycyA9IHt9O1xuXG4gICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0ckRlZikge1xuICAgICAgdmFyIHJlc29sdmVkQXR0ckRlZiA9IGF0dHJEZWY7XG4gICAgICB2YXIgYXR0ckRlZldhc0ZuID0gZmFsc2U7XG4gICAgICB2YXIgYXR0ciA9IHZvaWQgMDtcbiAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHJlc29sdmVkQXR0ckRlZikpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICByZXNvbHZlZEF0dHJEZWYgPSByZXNvbHZlZEF0dHJEZWYoY29udGV4dCk7XG4gICAgICAgIGF0dHJEZWZXYXNGbiA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgZm9yIChrZXkgaW4gcmVzb2x2ZWRBdHRyRGVmKSB7XG4gICAgICAgIGF0dHIgPSByZXNvbHZlZEF0dHJEZWZba2V5XTtcblxuICAgICAgICBpZiAoIWF0dHJEZWZXYXNGbikge1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGF0dHIpICYmICFpc0Rlcml2ZWRSZWFjdENvbXBvbmVudChhdHRyKSAmJiAhaXNTdHlsZWRDb21wb25lbnQoYXR0cikpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIF90aGlzMi53YXJuQXR0cnNGbk9iamVjdEtleURlcHJlY2F0ZWQoa2V5LCBwcm9wcy5mb3J3YXJkZWRDb21wb25lbnQuZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRyID0gYXR0cihjb250ZXh0KTtcblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgUmVhY3QuaXNWYWxpZEVsZW1lbnQoYXR0cikpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLndhcm5Ob25TdHlsZWRDb21wb25lbnRBdHRyc09iamVjdEtleShrZXksIHByb3BzLmZvcndhcmRlZENvbXBvbmVudC5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLmF0dHJzW2tleV0gPSBhdHRyO1xuICAgICAgICBjb250ZXh0W2tleV0gPSBhdHRyO1xuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH07XG5cbiAgU3R5bGVkQ29tcG9uZW50LnByb3RvdHlwZS5nZW5lcmF0ZUFuZEluamVjdFN0eWxlcyA9IGZ1bmN0aW9uIGdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKHRoZW1lLCBwcm9wcykge1xuICAgIHZhciBfcHJvcHMkZm9yd2FyZGVkQ29tcG8yID0gcHJvcHMuZm9yd2FyZGVkQ29tcG9uZW50LFxuICAgICAgICBhdHRycyA9IF9wcm9wcyRmb3J3YXJkZWRDb21wbzIuYXR0cnMsXG4gICAgICAgIGNvbXBvbmVudFN0eWxlID0gX3Byb3BzJGZvcndhcmRlZENvbXBvMi5jb21wb25lbnRTdHlsZSxcbiAgICAgICAgd2FyblRvb01hbnlDbGFzc2VzID0gX3Byb3BzJGZvcndhcmRlZENvbXBvMi53YXJuVG9vTWFueUNsYXNzZXM7XG5cbiAgICAvLyBzdGF0aWNhbGx5IHN0eWxlZC1jb21wb25lbnRzIGRvbid0IG5lZWQgdG8gYnVpbGQgYW4gZXhlY3V0aW9uIGNvbnRleHQgb2JqZWN0LFxuICAgIC8vIGFuZCBzaG91bGRuJ3QgYmUgaW5jcmVhc2luZyB0aGUgbnVtYmVyIG9mIGNsYXNzIG5hbWVzXG5cbiAgICBpZiAoY29tcG9uZW50U3R5bGUuaXNTdGF0aWMgJiYgIWF0dHJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNvbXBvbmVudFN0eWxlLmdlbmVyYXRlQW5kSW5qZWN0U3R5bGVzKEVNUFRZX09CSkVDVCwgdGhpcy5zdHlsZVNoZWV0KTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NOYW1lID0gY29tcG9uZW50U3R5bGUuZ2VuZXJhdGVBbmRJbmplY3RTdHlsZXModGhpcy5idWlsZEV4ZWN1dGlvbkNvbnRleHQodGhlbWUsIHByb3BzLCBhdHRycyksIHRoaXMuc3R5bGVTaGVldCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuVG9vTWFueUNsYXNzZXMpIHdhcm5Ub29NYW55Q2xhc3NlcyhjbGFzc05hbWUpO1xuXG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgfTtcblxuICByZXR1cm4gU3R5bGVkQ29tcG9uZW50O1xufShDb21wb25lbnQpO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZWRDb21wb25lbnQodGFyZ2V0LCBvcHRpb25zLCBydWxlcykge1xuICB2YXIgaXNUYXJnZXRTdHlsZWRDb21wID0gaXNTdHlsZWRDb21wb25lbnQodGFyZ2V0KTtcbiAgdmFyIGlzQ2xhc3MgPSAhaXNUYWcodGFyZ2V0KTtcblxuICB2YXIgX29wdGlvbnMkZGlzcGxheU5hbWUgPSBvcHRpb25zLmRpc3BsYXlOYW1lLFxuICAgICAgZGlzcGxheU5hbWUgPSBfb3B0aW9ucyRkaXNwbGF5TmFtZSA9PT0gdW5kZWZpbmVkID8gZ2VuZXJhdGVEaXNwbGF5TmFtZSh0YXJnZXQpIDogX29wdGlvbnMkZGlzcGxheU5hbWUsXG4gICAgICBfb3B0aW9ucyRjb21wb25lbnRJZCA9IG9wdGlvbnMuY29tcG9uZW50SWQsXG4gICAgICBjb21wb25lbnRJZCA9IF9vcHRpb25zJGNvbXBvbmVudElkID09PSB1bmRlZmluZWQgPyBnZW5lcmF0ZUlkKENvbXBvbmVudFN0eWxlLCBvcHRpb25zLmRpc3BsYXlOYW1lLCBvcHRpb25zLnBhcmVudENvbXBvbmVudElkKSA6IF9vcHRpb25zJGNvbXBvbmVudElkLFxuICAgICAgX29wdGlvbnMkUGFyZW50Q29tcG9uID0gb3B0aW9ucy5QYXJlbnRDb21wb25lbnQsXG4gICAgICBQYXJlbnRDb21wb25lbnQgPSBfb3B0aW9ucyRQYXJlbnRDb21wb24gPT09IHVuZGVmaW5lZCA/IFN0eWxlZENvbXBvbmVudCA6IF9vcHRpb25zJFBhcmVudENvbXBvbixcbiAgICAgIF9vcHRpb25zJGF0dHJzID0gb3B0aW9ucy5hdHRycyxcbiAgICAgIGF0dHJzID0gX29wdGlvbnMkYXR0cnMgPT09IHVuZGVmaW5lZCA/IEVNUFRZX0FSUkFZIDogX29wdGlvbnMkYXR0cnM7XG5cblxuICB2YXIgc3R5bGVkQ29tcG9uZW50SWQgPSBvcHRpb25zLmRpc3BsYXlOYW1lICYmIG9wdGlvbnMuY29tcG9uZW50SWQgPyBlc2NhcGUob3B0aW9ucy5kaXNwbGF5TmFtZSkgKyAnLScgKyBvcHRpb25zLmNvbXBvbmVudElkIDogb3B0aW9ucy5jb21wb25lbnRJZCB8fCBjb21wb25lbnRJZDtcblxuICAvLyBmb2xkIHRoZSB1bmRlcmx5aW5nIFN0eWxlZENvbXBvbmVudCBhdHRycyB1cCAoaW1wbGljaXQgZXh0ZW5kKVxuICB2YXIgZmluYWxBdHRycyA9XG4gIC8vICRGbG93Rml4TWVcbiAgaXNUYXJnZXRTdHlsZWRDb21wICYmIHRhcmdldC5hdHRycyA/IEFycmF5LnByb3RvdHlwZS5jb25jYXQodGFyZ2V0LmF0dHJzLCBhdHRycykuZmlsdGVyKEJvb2xlYW4pIDogYXR0cnM7XG5cbiAgdmFyIGNvbXBvbmVudFN0eWxlID0gbmV3IENvbXBvbmVudFN0eWxlKGlzVGFyZ2V0U3R5bGVkQ29tcCA/IC8vIGZvbGQgdGhlIHVuZGVybHlpbmcgU3R5bGVkQ29tcG9uZW50IHJ1bGVzIHVwIChpbXBsaWNpdCBleHRlbmQpXG4gIC8vICRGbG93Rml4TWVcbiAgdGFyZ2V0LmNvbXBvbmVudFN0eWxlLnJ1bGVzLmNvbmNhdChydWxlcykgOiBydWxlcywgZmluYWxBdHRycywgc3R5bGVkQ29tcG9uZW50SWQpO1xuXG4gIC8qKlxuICAgKiBmb3J3YXJkUmVmIGNyZWF0ZXMgYSBuZXcgaW50ZXJpbSBjb21wb25lbnQsIHdoaWNoIHdlJ2xsIHRha2UgYWR2YW50YWdlIG9mXG4gICAqIGluc3RlYWQgb2YgZXh0ZW5kaW5nIFBhcmVudENvbXBvbmVudCB0byBjcmVhdGUgX2Fub3RoZXJfIGludGVyaW0gY2xhc3NcbiAgICovXG4gIHZhciBXcmFwcGVkU3R5bGVkQ29tcG9uZW50ID0gdm9pZCAwO1xuICB2YXIgZm9yd2FyZFJlZiA9IGZ1bmN0aW9uIGZvcndhcmRSZWYocHJvcHMsIHJlZikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFBhcmVudENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHByb3BzLCB7IGZvcndhcmRlZENvbXBvbmVudDogV3JhcHBlZFN0eWxlZENvbXBvbmVudCwgZm9yd2FyZGVkUmVmOiByZWYgfSkpO1xuICB9O1xuICBmb3J3YXJkUmVmLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKGZvcndhcmRSZWYpO1xuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG5cbiAgLy8gJEZsb3dGaXhNZVxuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LmF0dHJzID0gZmluYWxBdHRycztcbiAgLy8gJEZsb3dGaXhNZVxuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LmNvbXBvbmVudFN0eWxlID0gY29tcG9uZW50U3R5bGU7XG5cbiAgLy8gJEZsb3dGaXhNZVxuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LmZvbGRlZENvbXBvbmVudElkcyA9IGlzVGFyZ2V0U3R5bGVkQ29tcCA/IC8vICRGbG93Rml4TWVcbiAgQXJyYXkucHJvdG90eXBlLmNvbmNhdCh0YXJnZXQuZm9sZGVkQ29tcG9uZW50SWRzLCB0YXJnZXQuc3R5bGVkQ29tcG9uZW50SWQpIDogRU1QVFlfQVJSQVk7XG5cbiAgLy8gJEZsb3dGaXhNZVxuICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50LnN0eWxlZENvbXBvbmVudElkID0gc3R5bGVkQ29tcG9uZW50SWQ7XG5cbiAgLy8gZm9sZCB0aGUgdW5kZXJseWluZyBTdHlsZWRDb21wb25lbnQgdGFyZ2V0IHVwIHNpbmNlIHdlIGZvbGRlZCB0aGUgc3R5bGVzXG4gIC8vICRGbG93Rml4TWVcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC50YXJnZXQgPSBpc1RhcmdldFN0eWxlZENvbXAgPyB0YXJnZXQudGFyZ2V0IDogdGFyZ2V0O1xuXG4gIC8vICRGbG93Rml4TWVcbiAgV3JhcHBlZFN0eWxlZENvbXBvbmVudC53aXRoQ29tcG9uZW50ID0gZnVuY3Rpb24gd2l0aENvbXBvbmVudCh0YWcpIHtcbiAgICB2YXIgcHJldmlvdXNDb21wb25lbnRJZCA9IG9wdGlvbnMuY29tcG9uZW50SWQsXG4gICAgICAgIG9wdGlvbnNUb0NvcHkgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhvcHRpb25zLCBbJ2NvbXBvbmVudElkJ10pO1xuXG5cbiAgICB2YXIgbmV3Q29tcG9uZW50SWQgPSBwcmV2aW91c0NvbXBvbmVudElkICYmIHByZXZpb3VzQ29tcG9uZW50SWQgKyAnLScgKyAoaXNUYWcodGFnKSA/IHRhZyA6IGVzY2FwZShnZXRDb21wb25lbnROYW1lKHRhZykpKTtcblxuICAgIHZhciBuZXdPcHRpb25zID0gX2V4dGVuZHMoe30sIG9wdGlvbnNUb0NvcHksIHtcbiAgICAgIGF0dHJzOiBmaW5hbEF0dHJzLFxuICAgICAgY29tcG9uZW50SWQ6IG5ld0NvbXBvbmVudElkLFxuICAgICAgUGFyZW50Q29tcG9uZW50OiBQYXJlbnRDb21wb25lbnRcbiAgICB9KTtcblxuICAgIHJldHVybiBjcmVhdGVTdHlsZWRDb21wb25lbnQodGFnLCBuZXdPcHRpb25zLCBydWxlcyk7XG4gIH07XG5cbiAgLy8gJEZsb3dGaXhNZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JhcHBlZFN0eWxlZENvbXBvbmVudCwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb2xkZWREZWZhdWx0UHJvcHM7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCQkMShvYmopIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHRoaXMuX2ZvbGRlZERlZmF1bHRQcm9wcyA9IGlzVGFyZ2V0U3R5bGVkQ29tcCA/IG1lcmdlKHRhcmdldC5kZWZhdWx0UHJvcHMsIG9iaikgOiBvYmo7XG4gICAgfVxuICB9KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBXcmFwcGVkU3R5bGVkQ29tcG9uZW50Lndhcm5Ub29NYW55Q2xhc3NlcyA9IGNyZWF0ZVdhcm5Ub29NYW55Q2xhc3NlcyhkaXNwbGF5TmFtZSk7XG4gIH1cblxuICAvLyAkRmxvd0ZpeE1lXG4gIFdyYXBwZWRTdHlsZWRDb21wb25lbnQudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcuJyArIFdyYXBwZWRTdHlsZWRDb21wb25lbnQuc3R5bGVkQ29tcG9uZW50SWQ7XG4gIH07XG5cbiAgaWYgKGlzQ2xhc3MpIHtcbiAgICBob2lzdE5vblJlYWN0U3RhdGljcyhXcmFwcGVkU3R5bGVkQ29tcG9uZW50LCB0YXJnZXQsIHtcbiAgICAgIC8vIGFsbCBTQy1zcGVjaWZpYyB0aGluZ3Mgc2hvdWxkIG5vdCBiZSBob2lzdGVkXG4gICAgICBhdHRyczogdHJ1ZSxcbiAgICAgIGNvbXBvbmVudFN0eWxlOiB0cnVlLFxuICAgICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgICBmb2xkZWRDb21wb25lbnRJZHM6IHRydWUsXG4gICAgICBzdHlsZWRDb21wb25lbnRJZDogdHJ1ZSxcbiAgICAgIHRhcmdldDogdHJ1ZSxcbiAgICAgIHdpdGhDb21wb25lbnQ6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBXcmFwcGVkU3R5bGVkQ29tcG9uZW50O1xufVxuXG4vLyBcbi8vIFRoYW5rcyB0byBSZWFjdERPTUZhY3RvcmllcyBmb3IgdGhpcyBoYW5keSBsaXN0IVxuXG52YXIgZG9tRWxlbWVudHMgPSBbJ2EnLCAnYWJicicsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2Jhc2UnLCAnYmRpJywgJ2JkbycsICdiaWcnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYW52YXMnLCAnY2FwdGlvbicsICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RhdGEnLCAnZGF0YWxpc3QnLCAnZGQnLCAnZGVsJywgJ2RldGFpbHMnLCAnZGZuJywgJ2RpYWxvZycsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW0nLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaScsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAna2V5Z2VuJywgJ2xhYmVsJywgJ2xlZ2VuZCcsICdsaScsICdsaW5rJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbWV0ZXInLCAnbmF2JywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAnb3V0cHV0JywgJ3AnLCAncGFyYW0nLCAncGljdHVyZScsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsICdycCcsICdydCcsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc21hbGwnLCAnc291cmNlJywgJ3NwYW4nLCAnc3Ryb25nJywgJ3N0eWxlJywgJ3N1YicsICdzdW1tYXJ5JywgJ3N1cCcsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aW1lJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3UnLCAndWwnLCAndmFyJywgJ3ZpZGVvJywgJ3dicicsXG5cbi8vIFNWR1xuJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZm9yZWlnbk9iamVjdCcsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N2ZycsICd0ZXh0JywgJ3RzcGFuJ107XG5cbi8vIFxuXG52YXIgc3R5bGVkID0gZnVuY3Rpb24gc3R5bGVkKHRhZykge1xuICByZXR1cm4gY29uc3RydWN0V2l0aE9wdGlvbnMoY3JlYXRlU3R5bGVkQ29tcG9uZW50LCB0YWcpO1xufTtcblxuLy8gU2hvcnRoYW5kcyBmb3IgYWxsIHZhbGlkIEhUTUwgRWxlbWVudHNcbmRvbUVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvbUVsZW1lbnQpIHtcbiAgc3R5bGVkW2RvbUVsZW1lbnRdID0gc3R5bGVkKGRvbUVsZW1lbnQpO1xufSk7XG5cbi8vIFxuXG52YXIgR2xvYmFsU3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdsb2JhbFN0eWxlKHJ1bGVzLCBjb21wb25lbnRJZCkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEdsb2JhbFN0eWxlKTtcblxuICAgIHRoaXMucnVsZXMgPSBydWxlcztcbiAgICB0aGlzLmNvbXBvbmVudElkID0gY29tcG9uZW50SWQ7XG4gICAgdGhpcy5pc1N0YXRpYyA9IGlzU3RhdGljUnVsZXMocnVsZXMsIEVNUFRZX0FSUkFZKTtcblxuICAgIGlmICghU3R5bGVTaGVldC5tYXN0ZXIuaGFzSWQoY29tcG9uZW50SWQpKSB7XG4gICAgICBTdHlsZVNoZWV0Lm1hc3Rlci5kZWZlcnJlZEluamVjdChjb21wb25lbnRJZCwgW10pO1xuICAgIH1cbiAgfVxuXG4gIEdsb2JhbFN0eWxlLnByb3RvdHlwZS5jcmVhdGVTdHlsZXMgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZXMoZXhlY3V0aW9uQ29udGV4dCwgc3R5bGVTaGVldCkge1xuICAgIHZhciBmbGF0Q1NTID0gZmxhdHRlbih0aGlzLnJ1bGVzLCBleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KTtcbiAgICB2YXIgY3NzID0gc3RyaW5naWZ5UnVsZXMoZmxhdENTUywgJycpO1xuXG4gICAgc3R5bGVTaGVldC5pbmplY3QodGhpcy5jb21wb25lbnRJZCwgY3NzKTtcbiAgfTtcblxuICBHbG9iYWxTdHlsZS5wcm90b3R5cGUucmVtb3ZlU3R5bGVzID0gZnVuY3Rpb24gcmVtb3ZlU3R5bGVzKHN0eWxlU2hlZXQpIHtcbiAgICB2YXIgY29tcG9uZW50SWQgPSB0aGlzLmNvbXBvbmVudElkO1xuXG4gICAgaWYgKHN0eWxlU2hlZXQuaGFzSWQoY29tcG9uZW50SWQpKSB7XG4gICAgICBzdHlsZVNoZWV0LnJlbW92ZShjb21wb25lbnRJZCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IG92ZXJ3cml0ZSBpbi1wbGFjZSBpbnN0ZWFkIG9mIHJlbW92ZStjcmVhdGU/XG5cblxuICBHbG9iYWxTdHlsZS5wcm90b3R5cGUucmVuZGVyU3R5bGVzID0gZnVuY3Rpb24gcmVuZGVyU3R5bGVzKGV4ZWN1dGlvbkNvbnRleHQsIHN0eWxlU2hlZXQpIHtcbiAgICB0aGlzLnJlbW92ZVN0eWxlcyhzdHlsZVNoZWV0KTtcbiAgICB0aGlzLmNyZWF0ZVN0eWxlcyhleGVjdXRpb25Db250ZXh0LCBzdHlsZVNoZWV0KTtcbiAgfTtcblxuICByZXR1cm4gR2xvYmFsU3R5bGU7XG59KCk7XG5cbi8vIFxuXG4vLyBwbGFjZSBvdXIgY2FjaGUgaW50byBzaGFyZWQgY29udGV4dCBzbyBpdCdsbCBwZXJzaXN0IGJldHdlZW4gSE1Sc1xuaWYgKElTX0JST1dTRVIpIHtcbiAgd2luZG93LnNjQ0dTSE1SQ2FjaGUgPSB7fTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlR2xvYmFsU3R5bGUoc3RyaW5ncykge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaW50ZXJwb2xhdGlvbnMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgaW50ZXJwb2xhdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgdmFyIHJ1bGVzID0gY3NzLmFwcGx5KHVuZGVmaW5lZCwgW3N0cmluZ3NdLmNvbmNhdChpbnRlcnBvbGF0aW9ucykpO1xuICB2YXIgaWQgPSAnc2MtZ2xvYmFsLScgKyBtdXJtdXJoYXNoKEpTT04uc3RyaW5naWZ5KHJ1bGVzKSk7XG4gIHZhciBzdHlsZSA9IG5ldyBHbG9iYWxTdHlsZShydWxlcywgaWQpO1xuXG4gIHZhciBHbG9iYWxTdHlsZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gICAgaW5oZXJpdHMoR2xvYmFsU3R5bGVDb21wb25lbnQsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gICAgZnVuY3Rpb24gR2xvYmFsU3R5bGVDb21wb25lbnQocHJvcHMpIHtcbiAgICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIEdsb2JhbFN0eWxlQ29tcG9uZW50KTtcblxuICAgICAgdmFyIF90aGlzID0gcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpKTtcblxuICAgICAgdmFyIF90aGlzJGNvbnN0cnVjdG9yID0gX3RoaXMuY29uc3RydWN0b3IsXG4gICAgICAgICAgZ2xvYmFsU3R5bGUgPSBfdGhpcyRjb25zdHJ1Y3Rvci5nbG9iYWxTdHlsZSxcbiAgICAgICAgICBzdHlsZWRDb21wb25lbnRJZCA9IF90aGlzJGNvbnN0cnVjdG9yLnN0eWxlZENvbXBvbmVudElkO1xuXG5cbiAgICAgIGlmIChJU19CUk9XU0VSKSB7XG4gICAgICAgIHdpbmRvdy5zY0NHU0hNUkNhY2hlW3N0eWxlZENvbXBvbmVudElkXSA9ICh3aW5kb3cuc2NDR1NITVJDYWNoZVtzdHlsZWRDb21wb25lbnRJZF0gfHwgMCkgKyAxO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgZml4ZXMgSE1SIGNvbXBhdGliaWxpdHkuIERvbid0IGFzayBtZSB3aHksIGJ1dCB0aGlzIGNvbWJpbmF0aW9uIG9mXG4gICAgICAgKiBjYWNoaW5nIHRoZSBjbG9zdXJlIHZhcmlhYmxlcyB2aWEgc3RhdGljcyBhbmQgdGhlbiBwZXJzaXN0aW5nIHRoZSBzdGF0aWNzIGluXG4gICAgICAgKiBzdGF0ZSB3b3JrcyBhY3Jvc3MgSE1SIHdoZXJlIG5vIG90aGVyIGNvbWJpbmF0aW9uIGRpZC4gwq9cXF8o44OEKV8vwq9cbiAgICAgICAqL1xuICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgIGdsb2JhbFN0eWxlOiBnbG9iYWxTdHlsZSxcbiAgICAgICAgc3R5bGVkQ29tcG9uZW50SWQ6IHN0eWxlZENvbXBvbmVudElkXG4gICAgICB9O1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIEdsb2JhbFN0eWxlQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgaWYgKHdpbmRvdy5zY0NHU0hNUkNhY2hlW3RoaXMuc3RhdGUuc3R5bGVkQ29tcG9uZW50SWRdKSB7XG4gICAgICAgIHdpbmRvdy5zY0NHU0hNUkNhY2hlW3RoaXMuc3RhdGUuc3R5bGVkQ29tcG9uZW50SWRdIC09IDE7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIERlcGVuZGluZyBvbiB0aGUgb3JkZXIgXCJyZW5kZXJcIiBpcyBjYWxsZWQgdGhpcyBjYW4gY2F1c2UgdGhlIHN0eWxlcyB0byBiZSBsb3N0XG4gICAgICAgKiB1bnRpbCB0aGUgbmV4dCByZW5kZXIgcGFzcyBvZiB0aGUgcmVtYWluaW5nIGluc3RhbmNlLCB3aGljaCBtYXlcbiAgICAgICAqIG5vdCBiZSBpbW1lZGlhdGUuXG4gICAgICAgKi9cbiAgICAgIGlmICh3aW5kb3cuc2NDR1NITVJDYWNoZVt0aGlzLnN0YXRlLnN0eWxlZENvbXBvbmVudElkXSA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXRlLmdsb2JhbFN0eWxlLnJlbW92ZVN0eWxlcyh0aGlzLnN0eWxlU2hlZXQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBHbG9iYWxTdHlsZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIFJlYWN0LkNoaWxkcmVuLmNvdW50KHRoaXMucHJvcHMuY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybignVGhlIGdsb2JhbCBzdHlsZSBjb21wb25lbnQgJyArIHRoaXMuc3RhdGUuc3R5bGVkQ29tcG9uZW50SWQgKyAnIHdhcyBnaXZlbiBjaGlsZCBKU1guIGNyZWF0ZUdsb2JhbFN0eWxlIGRvZXMgbm90IHJlbmRlciBjaGlsZHJlbi4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFN0eWxlU2hlZXRDb25zdW1lcixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZnVuY3Rpb24gKHN0eWxlU2hlZXQpIHtcbiAgICAgICAgICBfdGhpczIuc3R5bGVTaGVldCA9IHN0eWxlU2hlZXQgfHwgU3R5bGVTaGVldC5tYXN0ZXI7XG5cbiAgICAgICAgICB2YXIgZ2xvYmFsU3R5bGUgPSBfdGhpczIuc3RhdGUuZ2xvYmFsU3R5bGU7XG5cblxuICAgICAgICAgIGlmIChnbG9iYWxTdHlsZS5pc1N0YXRpYykge1xuICAgICAgICAgICAgZ2xvYmFsU3R5bGUucmVuZGVyU3R5bGVzKFNUQVRJQ19FWEVDVVRJT05fQ09OVEVYVCwgX3RoaXMyLnN0eWxlU2hlZXQpO1xuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICAgICAgIFRoZW1lQ29uc3VtZXIsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICh0aGVtZSkge1xuICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gX3RoaXMyLmNvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcztcblxuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBfZXh0ZW5kcyh7fSwgX3RoaXMyLnByb3BzKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0LnRoZW1lID0gZGV0ZXJtaW5lVGhlbWUoX3RoaXMyLnByb3BzLCB0aGVtZSwgZGVmYXVsdFByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBnbG9iYWxTdHlsZS5yZW5kZXJTdHlsZXMoY29udGV4dCwgX3RoaXMyLnN0eWxlU2hlZXQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG5cbiAgICByZXR1cm4gR2xvYmFsU3R5bGVDb21wb25lbnQ7XG4gIH0oUmVhY3QuQ29tcG9uZW50KTtcblxuICBHbG9iYWxTdHlsZUNvbXBvbmVudC5nbG9iYWxTdHlsZSA9IHN0eWxlO1xuICBHbG9iYWxTdHlsZUNvbXBvbmVudC5zdHlsZWRDb21wb25lbnRJZCA9IGlkO1xuXG5cbiAgcmV0dXJuIEdsb2JhbFN0eWxlQ29tcG9uZW50O1xufVxuXG4vLyBcblxudmFyIHJlcGxhY2VXaGl0ZXNwYWNlID0gZnVuY3Rpb24gcmVwbGFjZVdoaXRlc3BhY2Uoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzfFxcXFxuL2csICcnKTtcbn07XG5cbmZ1bmN0aW9uIGtleWZyYW1lcyhzdHJpbmdzKSB7XG4gIC8qIFdhcm5pbmcgaWYgeW91J3ZlIHVzZWQga2V5ZnJhbWVzIG9uIFJlYWN0IE5hdGl2ZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKCdga2V5ZnJhbWVzYCBjYW5ub3QgYmUgdXNlZCBvbiBSZWFjdE5hdGl2ZSwgb25seSBvbiB0aGUgd2ViLiBUbyBkbyBhbmltYXRpb24gaW4gUmVhY3ROYXRpdmUgcGxlYXNlIHVzZSBBbmltYXRlZC4nKTtcbiAgfVxuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnRlcnBvbGF0aW9ucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBpbnRlcnBvbGF0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgcnVsZXMgPSBjc3MuYXBwbHkodW5kZWZpbmVkLCBbc3RyaW5nc10uY29uY2F0KGludGVycG9sYXRpb25zKSk7XG5cbiAgdmFyIG5hbWUgPSBnZW5lcmF0ZUFscGhhYmV0aWNOYW1lKG11cm11cmhhc2gocmVwbGFjZVdoaXRlc3BhY2UoSlNPTi5zdHJpbmdpZnkocnVsZXMpKSkpO1xuXG4gIHJldHVybiBuZXcgS2V5ZnJhbWVzKG5hbWUsIHN0cmluZ2lmeVJ1bGVzKHJ1bGVzLCBuYW1lLCAnQGtleWZyYW1lcycpKTtcbn1cblxuLy8gXG5cbnZhciB3aXRoVGhlbWUgPSAoZnVuY3Rpb24gKENvbXBvbmVudCQkMSkge1xuICB2YXIgV2l0aFRoZW1lID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgVGhlbWVDb25zdW1lcixcbiAgICAgIG51bGwsXG4gICAgICBmdW5jdGlvbiAodGhlbWUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50JCQxLmRlZmF1bHRQcm9wcztcblxuICAgICAgICB2YXIgdGhlbWVQcm9wID0gZGV0ZXJtaW5lVGhlbWUocHJvcHMsIHRoZW1lLCBkZWZhdWx0UHJvcHMpO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHRoZW1lUHJvcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1t3aXRoVGhlbWVdIFlvdSBhcmUgbm90IHVzaW5nIGEgVGhlbWVQcm92aWRlciBub3IgcGFzc2luZyBhIHRoZW1lIHByb3Agb3IgYSB0aGVtZSBpbiBkZWZhdWx0UHJvcHMgaW4gY29tcG9uZW50IGNsYXNzIFwiJyArIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50JCQxKSArICdcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50JCQxLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHsgdGhlbWU6IHRoZW1lUHJvcCwgcmVmOiByZWYgfSkpO1xuICAgICAgfVxuICAgICk7XG4gIH0pO1xuXG4gIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKFdpdGhUaGVtZSwgQ29tcG9uZW50JCQxKTtcblxuICBXaXRoVGhlbWUuZGlzcGxheU5hbWUgPSAnV2l0aFRoZW1lKCcgKyBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCQkMSkgKyAnKSc7XG5cbiAgcmV0dXJuIFdpdGhUaGVtZTtcbn0pO1xuXG4vLyBcblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfSEFVTlRFRF9CWV9TUE9PS1lfR0hPU1RTID0ge1xuICBTdHlsZVNoZWV0OiBTdHlsZVNoZWV0XG59O1xuXG4vLyBcblxuLyogV2FybmluZyBpZiB5b3UndmUgaW1wb3J0ZWQgdGhpcyBmaWxlIG9uIFJlYWN0IE5hdGl2ZSAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS53YXJuKFwiSXQgbG9va3MgbGlrZSB5b3UndmUgaW1wb3J0ZWQgJ3N0eWxlZC1jb21wb25lbnRzJyBvbiBSZWFjdCBOYXRpdmUuXFxuXCIgKyBcIlBlcmhhcHMgeW91J3JlIGxvb2tpbmcgdG8gaW1wb3J0ICdzdHlsZWQtY29tcG9uZW50cy9uYXRpdmUnP1xcblwiICsgJ1JlYWQgbW9yZSBhYm91dCB0aGlzIGF0IGh0dHBzOi8vd3d3LnN0eWxlZC1jb21wb25lbnRzLmNvbS9kb2NzL2Jhc2ljcyNyZWFjdC1uYXRpdmUnKTtcbn1cblxuLyogV2FybmluZyBpZiB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2Ygc3R5bGVkLWNvbXBvbmVudHMgKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignTm9kZS5qcycpID09PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ2pzZG9tJykgPT09IC0xKSB7XG4gIHdpbmRvd1snX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSA9IHdpbmRvd1snX19zdHlsZWQtY29tcG9uZW50cy1pbml0X18nXSB8fCAwO1xuXG4gIGlmICh3aW5kb3dbJ19fc3R5bGVkLWNvbXBvbmVudHMtaW5pdF9fJ10gPT09IDEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcIkl0IGxvb2tzIGxpa2UgdGhlcmUgYXJlIHNldmVyYWwgaW5zdGFuY2VzIG9mICdzdHlsZWQtY29tcG9uZW50cycgaW5pdGlhbGl6ZWQgaW4gdGhpcyBhcHBsaWNhdGlvbi4gXCIgKyAnVGhpcyBtYXkgY2F1c2UgZHluYW1pYyBzdHlsZXMgbm90IHJlbmRlcmluZyBwcm9wZXJseSwgZXJyb3JzIGhhcHBlbmluZyBkdXJpbmcgcmVoeWRyYXRpb24gcHJvY2VzcyAnICsgJ2FuZCBtYWtlcyB5b3VyIGFwcGxpY2F0aW9uIGJpZ2dlciB3aXRob3V0IGEgZ29vZCByZWFzb24uXFxuXFxuJyArICdTZWUgaHR0cHM6Ly9zLWMuc2gvMkJBWHplZCBmb3IgbW9yZSBpbmZvLicpO1xuICB9XG5cbiAgd2luZG93WydfX3N0eWxlZC1jb21wb25lbnRzLWluaXRfXyddICs9IDE7XG59XG5cbi8vXG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlZDtcbmV4cG9ydCB7IGNyZWF0ZUdsb2JhbFN0eWxlLCBjc3MsIGlzU3R5bGVkQ29tcG9uZW50LCBrZXlmcmFtZXMsIFNlcnZlclN0eWxlU2hlZXQsIFN0eWxlU2hlZXRDb25zdW1lciwgU3R5bGVTaGVldENvbnRleHQsIFN0eWxlU2hlZXRNYW5hZ2VyLCBUaGVtZUNvbnN1bWVyLCBUaGVtZUNvbnRleHQsIFRoZW1lUHJvdmlkZXIsIHdpdGhUaGVtZSwgX19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0hBVU5URURfQllfU1BPT0tZX0dIT1NUUyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3R5bGVkLWNvbXBvbmVudHMuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIlN0eWxpcyIsIl9pbnNlcnRSdWxlUGx1Z2luIiwiUmVhY3QiLCJjbG9uZUVsZW1lbnQiLCJjcmVhdGVDb250ZXh0IiwiQ29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsInVuaXRsZXNzIiwiaXNFbGVtZW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiRm9yd2FyZFJlZiIsIm1lbW9pemUiLCJzdHJlYW0iLCJQcm9wVHlwZXMiLCJ2YWxpZEF0dHIiLCJtZXJnZSIsImludGVybGVhdmUiLCJzdHJpbmdzIiwiaW50ZXJwb2xhdGlvbnMiLCJyZXN1bHQiLCJpIiwibGVuIiwibGVuZ3RoIiwicHVzaCIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm9iaiIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIkNvbnN0cnVjdG9yIiwiVHlwZUVycm9yIiwiY3JlYXRlQ2xhc3MiLCJkZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfZXh0ZW5kcyIsImFzc2lnbiIsImFyZ3VtZW50cyIsInNvdXJjZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiY3JlYXRlIiwidmFsdWUiLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsIm9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwia2V5cyIsImluZGV4T2YiLCJwb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIiwic2VsZiIsIlJlZmVyZW5jZUVycm9yIiwiaXNQbGFpbk9iamVjdCIsIngiLCJFTVBUWV9BUlJBWSIsImZyZWV6ZSIsIkVNUFRZX09CSkVDVCIsImlzRnVuY3Rpb24iLCJ0ZXN0IiwiZ2V0Q29tcG9uZW50TmFtZSIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSIsIm5hbWUiLCJpc1N0YXRlbGVzc0Z1bmN0aW9uIiwiaXNSZWFjdENvbXBvbmVudCIsImlzU3R5bGVkQ29tcG9uZW50Iiwic3R5bGVkQ29tcG9uZW50SWQiLCJTQ19BVFRSIiwiZW52IiwiUkVBQ1RfQVBQX1NDX0FUVFIiLCJTQ19WRVJTSU9OX0FUVFIiLCJTQ19TVFJFQU1fQVRUUiIsIklTX0JST1dTRVIiLCJ3aW5kb3ciLCJESVNBQkxFX1NQRUVEWSIsIlNDX0RJU0FCTEVfU1BFRURZIiwiUkVBQ1RfQVBQX1NDX0RJU0FCTEVfU1BFRURZIiwiU1RBVElDX0VYRUNVVElPTl9DT05URVhUIiwiRVJST1JTIiwiZm9ybWF0IiwiYSIsInVuZGVmaW5lZCIsImIiLCJjIiwiZm9yRWFjaCIsImQiLCJyZXBsYWNlIiwiU3R5bGVkQ29tcG9uZW50c0Vycm9yIiwiX0Vycm9yIiwiY29kZSIsIl9sZW4iLCJBcnJheSIsIl9rZXkiLCJfdGhpcyIsImpvaW4iLCJhcHBseSIsImNvbmNhdCIsInRyaW0iLCJFcnJvciIsIlNDX0NPTVBPTkVOVF9JRCIsImV4dHJhY3RDb21wcyIsIm1heWJlQ1NTIiwiY3NzIiwiZXhpc3RpbmdDb21wb25lbnRzIiwibWF0Y2giLCJjb21wb25lbnRJZCIsIm1hdGNoSW5kZXgiLCJtYXAiLCJfcmVmIiwibmV4dENvbXAiLCJjc3NGcm9tRE9NIiwic2xpY2UiLCJDT01NRU5UX1JFR0VYIiwic3R5bGlzU3BsaXR0ZXIiLCJnbG9iYWwiLCJjYXNjYWRlIiwia2V5ZnJhbWUiLCJwcmVmaXgiLCJjb21wcmVzcyIsInNlbWljb2xvbiIsInN0eWxpcyIsInBhcnNpbmdSdWxlcyIsInJldHVyblJ1bGVzUGx1Z2luIiwiY29udGV4dCIsInBhcnNlZFJ1bGVzIiwicGFyc2VSdWxlc1BsdWdpbiIsInJ1bGUiLCJfY29tcG9uZW50SWQiLCJfc2VsZWN0b3IiLCJfc2VsZWN0b3JSZWdleHAiLCJzZWxmUmVmZXJlbmNlUmVwbGFjZXIiLCJvZmZzZXQiLCJzdHJpbmciLCJzZWxmUmVmZXJlbmNlUmVwbGFjZW1lbnRQbHVnaW4iLCJfIiwic2VsZWN0b3JzIiwibGFzdEluZGV4T2YiLCJ1c2UiLCJzcGxpdEJ5UnVsZXMiLCJzdHJpbmdpZnlSdWxlcyIsInJ1bGVzIiwic2VsZWN0b3IiLCJmbGF0Q1NTIiwiY3NzU3RyIiwiUmVnRXhwIiwiZ2V0Tm9uY2UiLCJfX3dlYnBhY2tfbm9uY2VfXyIsImFkZE5hbWVGb3JJZCIsIm5hbWVzIiwiaWQiLCJuYW1lc0ZvcklkIiwicmVzZXRJZE5hbWVzIiwiaGFzTmFtZUZvcklkIiwic3RyaW5naWZ5TmFtZXMiLCJzdHIiLCJjbG9uZU5hbWVzIiwiY2xvbmUiLCJzaGVldEZvclRhZyIsInRhZyIsInNoZWV0Iiwic2l6ZSIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZVNoZWV0cyIsIm93bmVyTm9kZSIsInNhZmVJbnNlcnRSdWxlIiwiY3NzUnVsZSIsImluZGV4IiwibWF4SW5kZXgiLCJjc3NSdWxlcyIsImluc2VydFJ1bGUiLCJlcnIiLCJkZWxldGVSdWxlcyIsInJlbW92YWxJbmRleCIsImxvd2VyQm91bmQiLCJkZWxldGVSdWxlIiwibWFrZVRleHRNYXJrZXIiLCJhZGRVcFVudGlsSW5kZXgiLCJzaXplcyIsInRvdGFsVXBUb0luZGV4IiwibWFrZVN0eWxlVGFnIiwidGFnRWwiLCJpbnNlcnRCZWZvcmUiLCJ0YXJnZXREb2N1bWVudCIsImRvY3VtZW50IiwiZWwiLCJzZXRBdHRyaWJ1dGUiLCJub25jZSIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJwYXJlbnROb2RlIiwibmV4dFNpYmxpbmciLCJ3cmFwQXNIdG1sVGFnIiwiYWRkaXRpb25hbEF0dHJzIiwiYXR0cnMiLCJodG1sQXR0ciIsImZpbHRlciIsIkJvb2xlYW4iLCJ3cmFwQXNFbGVtZW50IiwiX3Byb3BzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJnZXRJZHNGcm9tTWFya2Vyc0ZhY3RvcnkiLCJtYXJrZXJzIiwibWFrZVNwZWVkeVRhZyIsImdldEltcG9ydFJ1bGVUYWciLCJleHRyYWN0SW1wb3J0IiwidXNlZEltcG9ydFJ1bGVUYWciLCJpbnNlcnRNYXJrZXIiLCJwcmV2IiwiaW5zZXJ0UnVsZXMiLCJtYXJrZXIiLCJpbnNlcnRJbmRleCIsImluamVjdGVkUnVsZXMiLCJpbXBvcnRSdWxlcyIsImNzc1J1bGVzU2l6ZSIsIm1heUhhdmVJbXBvcnQiLCJyZW1vdmVSdWxlcyIsImlzQ29ubmVjdGVkIiwiX3NoZWV0Rm9yVGFnIiwiZW5kIiwiY3NzVGV4dCIsImdldElkcyIsInNlYWxlZCIsInN0eWxlVGFnIiwidG9FbGVtZW50IiwidG9IVE1MIiwibWFrZVRleHROb2RlIiwibWFrZUJyb3dzZXJUYWciLCJzZXBhcmF0b3IiLCJhcHBlbmREYXRhIiwibmV3TWFya2VyIiwicmVwbGFjZUNoaWxkIiwiZGF0YSIsIm1ha2VTZXJ2ZXJUYWciLCJuYW1lc0FyZyIsIm1hcmtlcnNBcmciLCJjc3NGb3JJZCIsIm5hbWVzQ2xvbmUiLCJtYXJrZXJzQ2xvbmUiLCJtYWtlVGFnIiwiZm9yY2VTZXJ2ZXIiLCJyZWh5ZHJhdGUiLCJlbHMiLCJleHRyYWN0ZWQiLCJfZXh0cmFjdGVkJGkiLCJfaSIsInJlbW92ZUNoaWxkIiwiU1BMSVRfUkVHRVgiLCJNQVhfU0laRSIsInNoZWV0UnVubmluZ0lkIiwibWFzdGVyIiwiU3R5bGVTaGVldCIsImhlYWQiLCJpbXBvcnRSdWxlVGFnIiwiZmlyc3RUYWciLCJ0YWdzIiwidGFnTWFwIiwiZGVmZXJyZWQiLCJyZWh5ZHJhdGVkTmFtZXMiLCJpZ25vcmVSZWh5ZHJhdGVkTmFtZXMiLCJjYXBhY2l0eSIsImNsb25lcyIsInJlaHlkcmF0ZSQkMSIsImlzU3RyZWFtZWQiLCJub2RlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJub2Rlc1NpemUiLCJnZXRBdHRyaWJ1dGUiLCJlbE5hbWVzIiwic3BsaXQiLCJlbE5hbWVzU2l6ZSIsImoiLCJ0ZXh0Q29udGVudCIsImV4dHJhY3RlZFNpemUiLCJNYXRoIiwibWF4IiwiX2oiLCJyZXNldCIsImlkcyIsIm5ld1RhZyIsInNlYWxBbGxUYWdzIiwibWFrZVRhZyQkMSIsImxhc3RFbCIsImdldFRhZ0ZvcklkIiwiaGFzSWQiLCJkZWZlcnJlZEluamVjdCIsImluamVjdCIsInJlbW92ZSIsInRvUmVhY3RFbGVtZW50cyIsImdldCIsImdldCQkMSIsIktleWZyYW1lcyIsInN0eWxlU2hlZXQiLCJ0b1N0cmluZyIsIlN0cmluZyIsImdldE5hbWUiLCJ1cHBlcmNhc2VQYXR0ZXJuIiwibXNQYXR0ZXJuIiwiaHlwaGVuYXRlU3R5bGVOYW1lIiwidG9Mb3dlckNhc2UiLCJhZGRVbml0SWZOZWVkZWQiLCJpc0ZhbHNpc2giLCJjaHVuayIsIm9ialRvQ3NzQXJyYXkiLCJwcmV2S2V5IiwiZmxhdHRlbiIsImV4ZWN1dGlvbkNvbnRleHQiLCJpc0FycmF5IiwicnVsZVNldCIsIl9yZXN1bHQiLCJjb25zb2xlIiwid2FybiIsInN0eWxlcyIsImNvbnN0cnVjdFdpdGhPcHRpb25zIiwiY29tcG9uZW50Q29uc3RydWN0b3IiLCJvcHRpb25zIiwidGVtcGxhdGVGdW5jdGlvbiIsIndpdGhDb25maWciLCJjb25maWciLCJtdXJtdXJoYXNoIiwiZSIsImNoYXJDb2RlQXQiLCJjaGFyc0xlbmd0aCIsImdldEFscGhhYmV0aWNDaGFyIiwiZnJvbUNoYXJDb2RlIiwiZ2VuZXJhdGVBbHBoYWJldGljTmFtZSIsImZsb29yIiwiaGFzRnVuY3Rpb25PYmplY3RLZXkiLCJpc1N0YXRpY1J1bGVzIiwic29tZSIsImhhc2hlciIsIkNvbXBvbmVudFN0eWxlIiwiaXNTdGF0aWMiLCJnZW5lcmF0ZUFuZEluamVjdFN0eWxlcyIsImxhc3RDbGFzc05hbWUiLCJnZW5lcmF0ZU5hbWUiLCJMSU1JVCIsImNyZWF0ZVdhcm5Ub29NYW55Q2xhc3NlcyIsImdlbmVyYXRlZENsYXNzZXMiLCJ3YXJuaW5nU2VlbiIsImNsYXNzTmFtZSIsImRldGVybWluZVRoZW1lIiwiZmFsbGJhY2tUaGVtZSIsImRlZmF1bHRQcm9wcyIsImlzRGVmYXVsdFRoZW1lIiwidGhlbWUiLCJlc2NhcGVSZWdleCIsImRhc2hlc0F0RW5kcyIsImVzY2FwZSIsImlzVGFnIiwiY2hhckF0IiwiZ2VuZXJhdGVEaXNwbGF5TmFtZSIsIl9UWVBFX1NUQVRJQ1MiLCJSRUFDVF9TVEFUSUNTIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb250ZXh0VHlwZXMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJwcm9wVHlwZXMiLCJ0eXBlIiwiS05PV05fU1RBVElDUyIsImNhbGxlciIsImNhbGxlZSIsImFyaXR5IiwiVFlQRV9TVEFUSUNTIiwiJCR0eXBlb2YiLCJyZW5kZXIiLCJkZWZpbmVQcm9wZXJ0eSQxIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9PYmplY3QkZ2V0T3duUHJvcGVydCIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0UHJvdG90eXBlIiwiYXJyYXlQcm90b3R5cGUiLCJob2lzdE5vblJlYWN0U3RhdGljcyIsInRhcmdldENvbXBvbmVudCIsInNvdXJjZUNvbXBvbmVudCIsImJsYWNrbGlzdCIsImluaGVyaXRlZENvbXBvbmVudCIsInRhcmdldFN0YXRpY3MiLCJzb3VyY2VTdGF0aWNzIiwiaXNEZXJpdmVkUmVhY3RDb21wb25lbnQiLCJmbiIsIm9uY2UiLCJjYiIsImNhbGxlZCIsIlRoZW1lQ29udGV4dCIsIlRoZW1lQ29uc3VtZXIiLCJDb25zdW1lciIsIlRoZW1lUHJvdmlkZXIiLCJfQ29tcG9uZW50IiwiZ2V0Q29udGV4dCIsImJpbmQiLCJyZW5kZXJJbm5lciIsImNoaWxkcmVuIiwib3V0ZXJUaGVtZSIsIlByb3ZpZGVyIiwiZ2V0VGhlbWUiLCJtZXJnZWRUaGVtZSIsIkNMT1NJTkdfVEFHX1IiLCJTZXJ2ZXJTdHlsZVNoZWV0IiwibWFzdGVyU2hlZXQiLCJzZWFsIiwic3BsaWNlIiwiY29sbGVjdFN0eWxlcyIsIlN0eWxlU2hlZXRNYW5hZ2VyIiwiZ2V0U3R5bGVUYWdzIiwiZ2V0U3R5bGVFbGVtZW50IiwiaW50ZXJsZWF2ZVdpdGhOb2RlU3RyZWFtIiwicmVhZGFibGVTdHJlYW0iLCJpbnN0YW5jZVRhZ0luZGV4Iiwic3RyZWFtQXR0ciIsInRyYW5zZm9ybWVyIiwiVHJhbnNmb3JtIiwidHJhbnNmb3JtIiwiYXBwZW5kU3R5bGVDaHVua3MiLCJjYWxsYmFjayIsImh0bWwiLCJyZW5kZXJlZEh0bWwiLCJlbmRPZkNsb3NpbmdUYWciLCJvbiIsImVtaXQiLCJwaXBlIiwiU3R5bGVTaGVldENvbnRleHQiLCJTdHlsZVNoZWV0Q29uc3VtZXIiLCJDaGlsZHJlbiIsIm9ubHkiLCJvbmVPZlR5cGUiLCJpbnN0YW5jZU9mIiwic2hhcGUiLCJmdW5jIiwiaXNSZXF1aXJlZCIsImlkZW50aWZpZXJzIiwiZ2VuZXJhdGVJZCIsIl9Db21wb25lbnRTdHlsZSIsIl9kaXNwbGF5TmFtZSIsInBhcmVudENvbXBvbmVudElkIiwibnIiLCJTdHlsZWRDb21wb25lbnQiLCJyZW5kZXJPdXRlciIsIndhcm5Jbm5lclJlZiIsIndhcm5BdHRyc0ZuT2JqZWN0S2V5RGVwcmVjYXRlZCIsInN0YWNrIiwid2Fybk5vblN0eWxlZENvbXBvbmVudEF0dHJzT2JqZWN0S2V5IiwiZm9yd2FyZGVkQ29tcG9uZW50IiwiY29tcG9uZW50U3R5bGUiLCJfcHJvcHMkZm9yd2FyZGVkQ29tcG8iLCJmb2xkZWRDb21wb25lbnRJZHMiLCJnZW5lcmF0ZWRDbGFzc05hbWUiLCJlbGVtZW50VG9CZUNyZWF0ZWQiLCJhcyIsImlzVGFyZ2V0VGFnIiwicHJvcHNGb3JFbGVtZW50IiwiY29tcHV0ZWRQcm9wcyIsInJlZiIsInN0eWxlIiwiYnVpbGRFeGVjdXRpb25Db250ZXh0IiwiX3RoaXMyIiwiYXR0ckRlZiIsInJlc29sdmVkQXR0ckRlZiIsImF0dHJEZWZXYXNGbiIsImF0dHIiLCJpc1ZhbGlkRWxlbWVudCIsIl9wcm9wcyRmb3J3YXJkZWRDb21wbzIiLCJ3YXJuVG9vTWFueUNsYXNzZXMiLCJjcmVhdGVTdHlsZWRDb21wb25lbnQiLCJpc1RhcmdldFN0eWxlZENvbXAiLCJpc0NsYXNzIiwiX29wdGlvbnMkZGlzcGxheU5hbWUiLCJfb3B0aW9ucyRjb21wb25lbnRJZCIsIl9vcHRpb25zJFBhcmVudENvbXBvbiIsIlBhcmVudENvbXBvbmVudCIsIl9vcHRpb25zJGF0dHJzIiwiZmluYWxBdHRycyIsIldyYXBwZWRTdHlsZWRDb21wb25lbnQiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZGVkUmVmIiwid2l0aENvbXBvbmVudCIsInByZXZpb3VzQ29tcG9uZW50SWQiLCJvcHRpb25zVG9Db3B5IiwibmV3Q29tcG9uZW50SWQiLCJuZXdPcHRpb25zIiwiX2ZvbGRlZERlZmF1bHRQcm9wcyIsInNldCIsInNldCQkMSIsImRvbUVsZW1lbnRzIiwic3R5bGVkIiwiZG9tRWxlbWVudCIsIkdsb2JhbFN0eWxlIiwiY3JlYXRlU3R5bGVzIiwicmVtb3ZlU3R5bGVzIiwicmVuZGVyU3R5bGVzIiwic2NDR1NITVJDYWNoZSIsImNyZWF0ZUdsb2JhbFN0eWxlIiwiSlNPTiIsInN0cmluZ2lmeSIsIkdsb2JhbFN0eWxlQ29tcG9uZW50IiwiX1JlYWN0JENvbXBvbmVudCIsIl90aGlzJGNvbnN0cnVjdG9yIiwiZ2xvYmFsU3R5bGUiLCJzdGF0ZSIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY291bnQiLCJyZXBsYWNlV2hpdGVzcGFjZSIsImtleWZyYW1lcyIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ3aXRoVGhlbWUiLCJDb21wb25lbnQkJDEiLCJXaXRoVGhlbWUiLCJ0aGVtZVByb3AiLCJfX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfSEFVTlRFRF9CWV9TUE9PS1lfR0hPU1RTIiwidXNlckFnZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/node_modules/styled-components/dist/styled-components.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/better-react-carousel/node_modules/stylis-rule-sheet/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/better-react-carousel/node_modules/stylis-rule-sheet/index.js ***!
  \************************************************************************************/
/***/ ((module) => {

eval("(function(factory) {\n     true ? module[\"exports\"] = factory() : 0;\n})(function() {\n    \"use strict\";\n    return function(insertRule) {\n        var delimiter = \"/*|*/\";\n        var needle = delimiter + \"}\";\n        function toSheet(block) {\n            if (block) try {\n                insertRule(block + \"}\");\n            } catch (e) {}\n        }\n        return function ruleSheet(context, content, selectors, parents, line, column, length, ns, depth, at) {\n            switch(context){\n                // property\n                case 1:\n                    // @import\n                    if (depth === 0 && content.charCodeAt(0) === 64) return insertRule(content + \";\"), \"\";\n                    break;\n                // selector\n                case 2:\n                    if (ns === 0) return content + delimiter;\n                    break;\n                // at-rule\n                case 3:\n                    switch(ns){\n                        // @font-face, @page\n                        case 102:\n                        case 112:\n                            return insertRule(selectors[0] + content), \"\";\n                        default:\n                            return content + (at === 0 ? delimiter : \"\");\n                    }\n                case -2:\n                    content.split(needle).forEach(toSheet);\n            }\n        };\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9zdHlsaXMtcnVsZS1zaGVldC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQyxVQUFVQSxPQUFPO0lBQ2pCLEtBQWlELEdBQWVFLE1BQU0sQ0FBQyxVQUFVLEdBQUdGLFlBQ25GLENBQ3VDQTtBQUN6QyxHQUFFO0lBRUQ7SUFFQSxPQUFPLFNBQVVLLFVBQVU7UUFDMUIsSUFBSUMsWUFBWTtRQUNoQixJQUFJQyxTQUFTRCxZQUFVO1FBRXZCLFNBQVNFLFFBQVNDLEtBQUs7WUFDdEIsSUFBSUEsT0FDSCxJQUFJO2dCQUNISixXQUFXSSxRQUFRO1lBQ3BCLEVBQUUsT0FBT0MsR0FBRyxDQUFDO1FBQ2Y7UUFFQSxPQUFPLFNBQVNDLFVBQVdDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxLQUFLLEVBQUVDLEVBQUU7WUFDbkcsT0FBUVQ7Z0JBQ1AsV0FBVztnQkFDWCxLQUFLO29CQUNKLFVBQVU7b0JBQ1YsSUFBSVEsVUFBVSxLQUFLUCxRQUFRUyxVQUFVLENBQUMsT0FBTyxJQUM1QyxPQUFPakIsV0FBV1EsVUFBUSxNQUFNO29CQUNqQztnQkFDRCxXQUFXO2dCQUNYLEtBQUs7b0JBQ0osSUFBSU0sT0FBTyxHQUNWLE9BQU9OLFVBQVVQO29CQUNsQjtnQkFDRCxVQUFVO2dCQUNWLEtBQUs7b0JBQ0osT0FBUWE7d0JBQ1Asb0JBQW9CO3dCQUNwQixLQUFLO3dCQUNMLEtBQUs7NEJBQ0osT0FBT2QsV0FBV1MsU0FBUyxDQUFDLEVBQUUsR0FBQ0QsVUFBVTt3QkFDMUM7NEJBQ0MsT0FBT0EsVUFBV1EsQ0FBQUEsT0FBTyxJQUFJZixZQUFZLEVBQUM7b0JBQzVDO2dCQUNELEtBQUssQ0FBQztvQkFDTE8sUUFBUVUsS0FBSyxDQUFDaEIsUUFBUWlCLE9BQU8sQ0FBQ2hCO1lBQ2hDO1FBQ0Q7SUFDRDtBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29kZV9jdWJpY2xlXzMvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9zdHlsaXMtcnVsZS1zaGVldC9pbmRleC5qcz84YTYwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyAobW9kdWxlWydleHBvcnRzJ10gPSBmYWN0b3J5KCkpIDpcblx0XHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZVsnYW1kJ10gPyBkZWZpbmUoZmFjdG9yeSgpKSA6XG5cdFx0XHQod2luZG93WydzdHlsaXNSdWxlU2hlZXQnXSA9IGZhY3RvcnkoKSlcbn0oZnVuY3Rpb24gKCkge1xuXG5cdCd1c2Ugc3RyaWN0J1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5zZXJ0UnVsZSkge1xuXHRcdHZhciBkZWxpbWl0ZXIgPSAnLyp8Ki8nXG5cdFx0dmFyIG5lZWRsZSA9IGRlbGltaXRlcisnfSdcblxuXHRcdGZ1bmN0aW9uIHRvU2hlZXQgKGJsb2NrKSB7XG5cdFx0XHRpZiAoYmxvY2spXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aW5zZXJ0UnVsZShibG9jayArICd9Jylcblx0XHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcnVsZVNoZWV0IChjb250ZXh0LCBjb250ZW50LCBzZWxlY3RvcnMsIHBhcmVudHMsIGxpbmUsIGNvbHVtbiwgbGVuZ3RoLCBucywgZGVwdGgsIGF0KSB7XG5cdFx0XHRzd2l0Y2ggKGNvbnRleHQpIHtcblx0XHRcdFx0Ly8gcHJvcGVydHlcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdC8vIEBpbXBvcnRcblx0XHRcdFx0XHRpZiAoZGVwdGggPT09IDAgJiYgY29udGVudC5jaGFyQ29kZUF0KDApID09PSA2NClcblx0XHRcdFx0XHRcdHJldHVybiBpbnNlcnRSdWxlKGNvbnRlbnQrJzsnKSwgJydcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHQvLyBzZWxlY3RvclxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0aWYgKG5zID09PSAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRlbnQgKyBkZWxpbWl0ZXJcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHQvLyBhdC1ydWxlXG5cdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRzd2l0Y2ggKG5zKSB7XG5cdFx0XHRcdFx0XHQvLyBAZm9udC1mYWNlLCBAcGFnZVxuXHRcdFx0XHRcdFx0Y2FzZSAxMDI6XG5cdFx0XHRcdFx0XHRjYXNlIDExMjpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGluc2VydFJ1bGUoc2VsZWN0b3JzWzBdK2NvbnRlbnQpLCAnJ1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRlbnQgKyAoYXQgPT09IDAgPyBkZWxpbWl0ZXIgOiAnJylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgLTI6XG5cdFx0XHRcdFx0Y29udGVudC5zcGxpdChuZWVkbGUpLmZvckVhY2godG9TaGVldClcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pKVxuIl0sIm5hbWVzIjpbImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwid2luZG93IiwiaW5zZXJ0UnVsZSIsImRlbGltaXRlciIsIm5lZWRsZSIsInRvU2hlZXQiLCJibG9jayIsImUiLCJydWxlU2hlZXQiLCJjb250ZXh0IiwiY29udGVudCIsInNlbGVjdG9ycyIsInBhcmVudHMiLCJsaW5lIiwiY29sdW1uIiwibGVuZ3RoIiwibnMiLCJkZXB0aCIsImF0IiwiY2hhckNvZGVBdCIsInNwbGl0IiwiZm9yRWFjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/node_modules/stylis-rule-sheet/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/better-react-carousel/node_modules/stylis/stylis.min.js":
/*!******************************************************************************!*\
  !*** ./node_modules/better-react-carousel/node_modules/stylis/stylis.min.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("!function(e) {\n     true ? module.exports = e(null) : 0;\n}(function e(a) {\n    \"use strict\";\n    var r = /^\\0+/g, c = /[\\0\\r\\f]/g, s = /: */g, t = /zoo|gra/, i = /([,: ])(transform)/g, f = /,+\\s*(?![^(]*[)])/g, n = / +\\s*(?![^(]*[)])/g, l = / *[\\0] */g, o = /,\\r+?/g, h = /([\\t\\r\\n ])*\\f?&/g, u = /:global\\(((?:[^\\(\\)\\[\\]]*|\\[.*\\]|\\([^\\(\\)]*\\))*)\\)/g, d = /\\W+/g, b = /@(k\\w+)\\s*(\\S*)\\s*/, p = /::(place)/g, k = /:(read-only)/g, g = /\\s+(?=[{\\];=:>])/g, A = /([[}=:>])\\s+/g, C = /(\\{[^{]+?);(?=\\})/g, w = /\\s{2,}/g, v = /([^\\(])(:+) */g, m = /[svh]\\w+-[tblr]{2}/, x = /\\(\\s*(.*)\\s*\\)/g, $ = /([\\s\\S]*?);/g, y = /-self|flex-/g, O = /[^]*?(:[rp][el]a[\\w-]+)[^]*/, j = /stretch|:\\s*\\w+\\-(?:conte|avail)/, z = /([^-])(image-set\\()/, N = \"-webkit-\", S = \"-moz-\", F = \"-ms-\", W = 59, q = 125, B = 123, D = 40, E = 41, G = 91, H = 93, I = 10, J = 13, K = 9, L = 64, M = 32, P = 38, Q = 45, R = 95, T = 42, U = 44, V = 58, X = 39, Y = 34, Z = 47, _ = 62, ee = 43, ae = 126, re = 0, ce = 12, se = 11, te = 107, ie = 109, fe = 115, ne = 112, le = 111, oe = 105, he = 99, ue = 100, de = 112, be = 1, pe = 1, ke = 0, ge = 1, Ae = 1, Ce = 1, we = 0, ve = 0, me = 0, xe = [], $e = [], ye = 0, Oe = null, je = -2, ze = -1, Ne = 0, Se = 1, Fe = 2, We = 3, qe = 0, Be = 1, De = \"\", Ee = \"\", Ge = \"\";\n    function He(e, a, s, t, i) {\n        for(var f, n, o = 0, h = 0, u = 0, d = 0, g = 0, A = 0, C = 0, w = 0, m = 0, $ = 0, y = 0, O = 0, j = 0, z = 0, R = 0, we = 0, $e = 0, Oe = 0, je = 0, ze = s.length, Je = ze - 1, Re = \"\", Te = \"\", Ue = \"\", Ve = \"\", Xe = \"\", Ye = \"\"; R < ze;){\n            if (C = s.charCodeAt(R), R === Je) {\n                if (h + d + u + o !== 0) {\n                    if (0 !== h) C = h === Z ? I : Z;\n                    d = u = o = 0, ze++, Je++;\n                }\n            }\n            if (h + d + u + o === 0) {\n                if (R === Je) {\n                    if (we > 0) Te = Te.replace(c, \"\");\n                    if (Te.trim().length > 0) {\n                        switch(C){\n                            case M:\n                            case K:\n                            case W:\n                            case J:\n                            case I:\n                                break;\n                            default:\n                                Te += s.charAt(R);\n                        }\n                        C = W;\n                    }\n                }\n                if (1 === $e) switch(C){\n                    case B:\n                    case q:\n                    case W:\n                    case Y:\n                    case X:\n                    case D:\n                    case E:\n                    case U:\n                        $e = 0;\n                    case K:\n                    case J:\n                    case I:\n                    case M:\n                        break;\n                    default:\n                        for($e = 0, je = R, g = C, R--, C = W; je < ze;)switch(s.charCodeAt(je++)){\n                            case I:\n                            case J:\n                            case W:\n                                ++R, C = g, je = ze;\n                                break;\n                            case V:\n                                if (we > 0) ++R, C = g;\n                            case B:\n                                je = ze;\n                        }\n                }\n                switch(C){\n                    case B:\n                        for(g = (Te = Te.trim()).charCodeAt(0), y = 1, je = ++R; R < ze;){\n                            switch(C = s.charCodeAt(R)){\n                                case B:\n                                    y++;\n                                    break;\n                                case q:\n                                    y--;\n                                    break;\n                                case Z:\n                                    switch(A = s.charCodeAt(R + 1)){\n                                        case T:\n                                        case Z:\n                                            R = Qe(A, R, Je, s);\n                                    }\n                                    break;\n                                case G:\n                                    C++;\n                                case D:\n                                    C++;\n                                case Y:\n                                case X:\n                                    for(; R++ < Je && s.charCodeAt(R) !== C;);\n                            }\n                            if (0 === y) break;\n                            R++;\n                        }\n                        if (Ue = s.substring(je, R), g === re) g = (Te = Te.replace(r, \"\").trim()).charCodeAt(0);\n                        switch(g){\n                            case L:\n                                if (we > 0) Te = Te.replace(c, \"\");\n                                switch(A = Te.charCodeAt(1)){\n                                    case ue:\n                                    case ie:\n                                    case fe:\n                                    case Q:\n                                        f = a;\n                                        break;\n                                    default:\n                                        f = xe;\n                                }\n                                if (je = (Ue = He(a, f, Ue, A, i + 1)).length, me > 0 && 0 === je) je = Te.length;\n                                if (ye > 0) {\n                                    if (f = Ie(xe, Te, Oe), n = Pe(We, Ue, f, a, pe, be, je, A, i, t), Te = f.join(\"\"), void 0 !== n) {\n                                        if (0 === (je = (Ue = n.trim()).length)) A = 0, Ue = \"\";\n                                    }\n                                }\n                                if (je > 0) switch(A){\n                                    case fe:\n                                        Te = Te.replace(x, Me);\n                                    case ue:\n                                    case ie:\n                                    case Q:\n                                        Ue = Te + \"{\" + Ue + \"}\";\n                                        break;\n                                    case te:\n                                        if (Ue = (Te = Te.replace(b, \"$1 $2\" + (Be > 0 ? De : \"\"))) + \"{\" + Ue + \"}\", 1 === Ae || 2 === Ae && Le(\"@\" + Ue, 3)) Ue = \"@\" + N + Ue + \"@\" + Ue;\n                                        else Ue = \"@\" + Ue;\n                                        break;\n                                    default:\n                                        if (Ue = Te + Ue, t === de) Ve += Ue, Ue = \"\";\n                                }\n                                else Ue = \"\";\n                                break;\n                            default:\n                                Ue = He(a, Ie(a, Te, Oe), Ue, t, i + 1);\n                        }\n                        Xe += Ue, O = 0, $e = 0, z = 0, we = 0, Oe = 0, j = 0, Te = \"\", Ue = \"\", C = s.charCodeAt(++R);\n                        break;\n                    case q:\n                    case W:\n                        if ((je = (Te = (we > 0 ? Te.replace(c, \"\") : Te).trim()).length) > 1) {\n                            if (0 === z) {\n                                if ((g = Te.charCodeAt(0)) === Q || g > 96 && g < 123) je = (Te = Te.replace(\" \", \":\")).length;\n                            }\n                            if (ye > 0) {\n                                if (void 0 !== (n = Pe(Se, Te, a, e, pe, be, Ve.length, t, i, t))) {\n                                    if (0 === (je = (Te = n.trim()).length)) Te = \"\\x00\\x00\";\n                                }\n                            }\n                            switch(g = Te.charCodeAt(0), A = Te.charCodeAt(1), g){\n                                case re:\n                                    break;\n                                case L:\n                                    if (A === oe || A === he) {\n                                        Ye += Te + s.charAt(R);\n                                        break;\n                                    }\n                                default:\n                                    if (Te.charCodeAt(je - 1) === V) break;\n                                    Ve += Ke(Te, g, A, Te.charCodeAt(2));\n                            }\n                        }\n                        O = 0, $e = 0, z = 0, we = 0, Oe = 0, Te = \"\", C = s.charCodeAt(++R);\n                }\n            }\n            switch(C){\n                case J:\n                case I:\n                    if (h + d + u + o + ve === 0) switch($){\n                        case E:\n                        case X:\n                        case Y:\n                        case L:\n                        case ae:\n                        case _:\n                        case T:\n                        case ee:\n                        case Z:\n                        case Q:\n                        case V:\n                        case U:\n                        case W:\n                        case B:\n                        case q:\n                            break;\n                        default:\n                            if (z > 0) $e = 1;\n                    }\n                    if (h === Z) h = 0;\n                    else if (ge + O === 0 && t !== te && Te.length > 0) we = 1, Te += \"\\x00\";\n                    if (ye * qe > 0) Pe(Ne, Te, a, e, pe, be, Ve.length, t, i, t);\n                    be = 1, pe++;\n                    break;\n                case W:\n                case q:\n                    if (h + d + u + o === 0) {\n                        be++;\n                        break;\n                    }\n                default:\n                    switch(be++, Re = s.charAt(R), C){\n                        case K:\n                        case M:\n                            if (d + o + h === 0) switch(w){\n                                case U:\n                                case V:\n                                case K:\n                                case M:\n                                    Re = \"\";\n                                    break;\n                                default:\n                                    if (C !== M) Re = \" \";\n                            }\n                            break;\n                        case re:\n                            Re = \"\\\\0\";\n                            break;\n                        case ce:\n                            Re = \"\\\\f\";\n                            break;\n                        case se:\n                            Re = \"\\\\v\";\n                            break;\n                        case P:\n                            if (d + h + o === 0 && ge > 0) Oe = 1, we = 1, Re = \"\\f\" + Re;\n                            break;\n                        case 108:\n                            if (d + h + o + ke === 0 && z > 0) switch(R - z){\n                                case 2:\n                                    if (w === ne && s.charCodeAt(R - 3) === V) ke = w;\n                                case 8:\n                                    if (m === le) ke = m;\n                            }\n                            break;\n                        case V:\n                            if (d + h + o === 0) z = R;\n                            break;\n                        case U:\n                            if (h + u + d + o === 0) we = 1, Re += \"\\r\";\n                            break;\n                        case Y:\n                        case X:\n                            if (0 === h) d = d === C ? 0 : 0 === d ? C : d;\n                            break;\n                        case G:\n                            if (d + h + u === 0) o++;\n                            break;\n                        case H:\n                            if (d + h + u === 0) o--;\n                            break;\n                        case E:\n                            if (d + h + o === 0) u--;\n                            break;\n                        case D:\n                            if (d + h + o === 0) {\n                                if (0 === O) switch(2 * w + 3 * m){\n                                    case 533:\n                                        break;\n                                    default:\n                                        y = 0, O = 1;\n                                }\n                                u++;\n                            }\n                            break;\n                        case L:\n                            if (h + u + d + o + z + j === 0) j = 1;\n                            break;\n                        case T:\n                        case Z:\n                            if (d + o + u > 0) break;\n                            switch(h){\n                                case 0:\n                                    switch(2 * C + 3 * s.charCodeAt(R + 1)){\n                                        case 235:\n                                            h = Z;\n                                            break;\n                                        case 220:\n                                            je = R, h = T;\n                                    }\n                                    break;\n                                case T:\n                                    if (C === Z && w === T && je + 2 !== R) {\n                                        if (33 === s.charCodeAt(je + 2)) Ve += s.substring(je, R + 1);\n                                        Re = \"\", h = 0;\n                                    }\n                            }\n                    }\n                    if (0 === h) {\n                        if (ge + d + o + j === 0 && t !== te && C !== W) switch(C){\n                            case U:\n                            case ae:\n                            case _:\n                            case ee:\n                            case E:\n                            case D:\n                                if (0 === O) {\n                                    switch(w){\n                                        case K:\n                                        case M:\n                                        case I:\n                                        case J:\n                                            Re += \"\\x00\";\n                                            break;\n                                        default:\n                                            Re = \"\\x00\" + Re + (C === U ? \"\" : \"\\x00\");\n                                    }\n                                    we = 1;\n                                } else switch(C){\n                                    case D:\n                                        if (z + 7 === R && 108 === w) z = 0;\n                                        O = ++y;\n                                        break;\n                                    case E:\n                                        if (0 == (O = --y)) we = 1, Re += \"\\x00\";\n                                }\n                                break;\n                            case K:\n                            case M:\n                                switch(w){\n                                    case re:\n                                    case B:\n                                    case q:\n                                    case W:\n                                    case U:\n                                    case ce:\n                                    case K:\n                                    case M:\n                                    case I:\n                                    case J:\n                                        break;\n                                    default:\n                                        if (0 === O) we = 1, Re += \"\\x00\";\n                                }\n                        }\n                        if (Te += Re, C !== M && C !== K) $ = C;\n                    }\n            }\n            m = w, w = C, R++;\n        }\n        if (je = Ve.length, me > 0) {\n            if (0 === je && 0 === Xe.length && 0 === a[0].length == false) {\n                if (t !== ie || 1 === a.length && (ge > 0 ? Ee : Ge) === a[0]) je = a.join(\",\").length + 2;\n            }\n        }\n        if (je > 0) {\n            if (f = 0 === ge && t !== te ? function(e) {\n                for(var a, r, s = 0, t = e.length, i = Array(t); s < t; ++s){\n                    for(var f = e[s].split(l), n = \"\", o = 0, h = 0, u = 0, d = 0, b = f.length; o < b; ++o){\n                        if (0 === (h = (r = f[o]).length) && b > 1) continue;\n                        if (u = n.charCodeAt(n.length - 1), d = r.charCodeAt(0), a = \"\", 0 !== o) switch(u){\n                            case T:\n                            case ae:\n                            case _:\n                            case ee:\n                            case M:\n                            case D:\n                                break;\n                            default:\n                                a = \" \";\n                        }\n                        switch(d){\n                            case P:\n                                r = a + Ee;\n                            case ae:\n                            case _:\n                            case ee:\n                            case M:\n                            case E:\n                            case D:\n                                break;\n                            case G:\n                                r = a + r + Ee;\n                                break;\n                            case V:\n                                switch(2 * r.charCodeAt(1) + 3 * r.charCodeAt(2)){\n                                    case 530:\n                                        if (Ce > 0) {\n                                            r = a + r.substring(8, h - 1);\n                                            break;\n                                        }\n                                    default:\n                                        if (o < 1 || f[o - 1].length < 1) r = a + Ee + r;\n                                }\n                                break;\n                            case U:\n                                a = \"\";\n                            default:\n                                if (h > 1 && r.indexOf(\":\") > 0) r = a + r.replace(v, \"$1\" + Ee + \"$2\");\n                                else r = a + r + Ee;\n                        }\n                        n += r;\n                    }\n                    i[s] = n.replace(c, \"\").trim();\n                }\n                return i;\n            }(a) : a, ye > 0) {\n                if (void 0 !== (n = Pe(Fe, Ve, f, e, pe, be, je, t, i, t)) && 0 === (Ve = n).length) return Ye + Ve + Xe;\n            }\n            if (Ve = f.join(\",\") + \"{\" + Ve + \"}\", Ae * ke != 0) {\n                if (2 === Ae && !Le(Ve, 2)) ke = 0;\n                switch(ke){\n                    case le:\n                        Ve = Ve.replace(k, \":\" + S + \"$1\") + Ve;\n                        break;\n                    case ne:\n                        Ve = Ve.replace(p, \"::\" + N + \"input-$1\") + Ve.replace(p, \"::\" + S + \"$1\") + Ve.replace(p, \":\" + F + \"input-$1\") + Ve;\n                }\n                ke = 0;\n            }\n        }\n        return Ye + Ve + Xe;\n    }\n    function Ie(e, a, r) {\n        var c = a.trim().split(o), s = c, t = c.length, i = e.length;\n        switch(i){\n            case 0:\n            case 1:\n                for(var f = 0, n = 0 === i ? \"\" : e[0] + \" \"; f < t; ++f)s[f] = Je(n, s[f], r, i).trim();\n                break;\n            default:\n                f = 0;\n                var l = 0;\n                for(s = []; f < t; ++f)for(var h = 0; h < i; ++h)s[l++] = Je(e[h] + \" \", c[f], r, i).trim();\n        }\n        return s;\n    }\n    function Je(e, a, r, c) {\n        var s = a, t = s.charCodeAt(0);\n        if (t < 33) t = (s = s.trim()).charCodeAt(0);\n        switch(t){\n            case P:\n                switch(ge + c){\n                    case 0:\n                    case 1:\n                        if (0 === e.trim().length) break;\n                    default:\n                        return s.replace(h, \"$1\" + e.trim());\n                }\n                break;\n            case V:\n                switch(s.charCodeAt(1)){\n                    case 103:\n                        if (Ce > 0 && ge > 0) return s.replace(u, \"$1\").replace(h, \"$1\" + Ge);\n                        break;\n                    default:\n                        return e.trim() + s.replace(h, \"$1\" + e.trim());\n                }\n            default:\n                if (r * ge > 0 && s.indexOf(\"\\f\") > 0) return s.replace(h, (e.charCodeAt(0) === V ? \"\" : \"$1\") + e.trim());\n        }\n        return e + s;\n    }\n    function Ke(e, a, r, c) {\n        var l, o = 0, h = e + \";\", u = 2 * a + 3 * r + 4 * c;\n        if (944 === u) return function(e) {\n            var a = e.length, r = e.indexOf(\":\", 9) + 1, c = e.substring(0, r).trim(), s = e.substring(r, a - 1).trim();\n            switch(e.charCodeAt(9) * Be){\n                case 0:\n                    break;\n                case Q:\n                    if (110 !== e.charCodeAt(10)) break;\n                default:\n                    for(var t = s.split((s = \"\", f)), i = 0, r = 0, a = t.length; i < a; r = 0, ++i){\n                        for(var l = t[i], o = l.split(n); l = o[r];){\n                            var h = l.charCodeAt(0);\n                            if (1 === Be && (h > L && h < 90 || h > 96 && h < 123 || h === R || h === Q && l.charCodeAt(1) !== Q)) switch(isNaN(parseFloat(l)) + (-1 !== l.indexOf(\"(\"))){\n                                case 1:\n                                    switch(l){\n                                        case \"infinite\":\n                                        case \"alternate\":\n                                        case \"backwards\":\n                                        case \"running\":\n                                        case \"normal\":\n                                        case \"forwards\":\n                                        case \"both\":\n                                        case \"none\":\n                                        case \"linear\":\n                                        case \"ease\":\n                                        case \"ease-in\":\n                                        case \"ease-out\":\n                                        case \"ease-in-out\":\n                                        case \"paused\":\n                                        case \"reverse\":\n                                        case \"alternate-reverse\":\n                                        case \"inherit\":\n                                        case \"initial\":\n                                        case \"unset\":\n                                        case \"step-start\":\n                                        case \"step-end\":\n                                            break;\n                                        default:\n                                            l += De;\n                                    }\n                            }\n                            o[r++] = l;\n                        }\n                        s += (0 === i ? \"\" : \",\") + o.join(\" \");\n                    }\n            }\n            if (s = c + s + \";\", 1 === Ae || 2 === Ae && Le(s, 1)) return N + s + s;\n            return s;\n        }(h);\n        else if (0 === Ae || 2 === Ae && !Le(h, 1)) return h;\n        switch(u){\n            case 1015:\n                return 97 === h.charCodeAt(10) ? N + h + h : h;\n            case 951:\n                return 116 === h.charCodeAt(3) ? N + h + h : h;\n            case 963:\n                return 110 === h.charCodeAt(5) ? N + h + h : h;\n            case 1009:\n                if (100 !== h.charCodeAt(4)) break;\n            case 969:\n            case 942:\n                return N + h + h;\n            case 978:\n                return N + h + S + h + h;\n            case 1019:\n            case 983:\n                return N + h + S + h + F + h + h;\n            case 883:\n                if (h.charCodeAt(8) === Q) return N + h + h;\n                if (h.indexOf(\"image-set(\", 11) > 0) return h.replace(z, \"$1\" + N + \"$2\") + h;\n                return h;\n            case 932:\n                if (h.charCodeAt(4) === Q) switch(h.charCodeAt(5)){\n                    case 103:\n                        return N + \"box-\" + h.replace(\"-grow\", \"\") + N + h + F + h.replace(\"grow\", \"positive\") + h;\n                    case 115:\n                        return N + h + F + h.replace(\"shrink\", \"negative\") + h;\n                    case 98:\n                        return N + h + F + h.replace(\"basis\", \"preferred-size\") + h;\n                }\n                return N + h + F + h + h;\n            case 964:\n                return N + h + F + \"flex-\" + h + h;\n            case 1023:\n                if (99 !== h.charCodeAt(8)) break;\n                return l = h.substring(h.indexOf(\":\", 15)).replace(\"flex-\", \"\").replace(\"space-between\", \"justify\"), N + \"box-pack\" + l + N + h + F + \"flex-pack\" + l + h;\n            case 1005:\n                return t.test(h) ? h.replace(s, \":\" + N) + h.replace(s, \":\" + S) + h : h;\n            case 1e3:\n                switch(o = (l = h.substring(13).trim()).indexOf(\"-\") + 1, l.charCodeAt(0) + l.charCodeAt(o)){\n                    case 226:\n                        l = h.replace(m, \"tb\");\n                        break;\n                    case 232:\n                        l = h.replace(m, \"tb-rl\");\n                        break;\n                    case 220:\n                        l = h.replace(m, \"lr\");\n                        break;\n                    default:\n                        return h;\n                }\n                return N + h + F + l + h;\n            case 1017:\n                if (-1 === h.indexOf(\"sticky\", 9)) return h;\n            case 975:\n                switch(o = (h = e).length - 10, u = (l = (33 === h.charCodeAt(o) ? h.substring(0, o) : h).substring(e.indexOf(\":\", 7) + 1).trim()).charCodeAt(0) + (0 | l.charCodeAt(7))){\n                    case 203:\n                        if (l.charCodeAt(8) < 111) break;\n                    case 115:\n                        h = h.replace(l, N + l) + \";\" + h;\n                        break;\n                    case 207:\n                    case 102:\n                        h = h.replace(l, N + (u > 102 ? \"inline-\" : \"\") + \"box\") + \";\" + h.replace(l, N + l) + \";\" + h.replace(l, F + l + \"box\") + \";\" + h;\n                }\n                return h + \";\";\n            case 938:\n                if (h.charCodeAt(5) === Q) switch(h.charCodeAt(6)){\n                    case 105:\n                        return l = h.replace(\"-items\", \"\"), N + h + N + \"box-\" + l + F + \"flex-\" + l + h;\n                    case 115:\n                        return N + h + F + \"flex-item-\" + h.replace(y, \"\") + h;\n                    default:\n                        return N + h + F + \"flex-line-pack\" + h.replace(\"align-content\", \"\").replace(y, \"\") + h;\n                }\n                break;\n            case 973:\n            case 989:\n                if (h.charCodeAt(3) !== Q || 122 === h.charCodeAt(4)) break;\n            case 931:\n            case 953:\n                if (true === j.test(e)) if (115 === (l = e.substring(e.indexOf(\":\") + 1)).charCodeAt(0)) return Ke(e.replace(\"stretch\", \"fill-available\"), a, r, c).replace(\":fill-available\", \":stretch\");\n                else return h.replace(l, N + l) + h.replace(l, S + l.replace(\"fill-\", \"\")) + h;\n                break;\n            case 962:\n                if (h = N + h + (102 === h.charCodeAt(5) ? F + h : \"\") + h, r + c === 211 && 105 === h.charCodeAt(13) && h.indexOf(\"transform\", 10) > 0) return h.substring(0, h.indexOf(\";\", 27) + 1).replace(i, \"$1\" + N + \"$2\") + h;\n        }\n        return h;\n    }\n    function Le(e, a) {\n        var r = e.indexOf(1 === a ? \":\" : \"{\"), c = e.substring(0, 3 !== a ? r : 10), s = e.substring(r + 1, e.length - 1);\n        return Oe(2 !== a ? c : c.replace(O, \"$1\"), s, a);\n    }\n    function Me(e, a) {\n        var r = Ke(a, a.charCodeAt(0), a.charCodeAt(1), a.charCodeAt(2));\n        return r !== a + \";\" ? r.replace($, \" or ($1)\").substring(4) : \"(\" + a + \")\";\n    }\n    function Pe(e, a, r, c, s, t, i, f, n, l) {\n        for(var o, h = 0, u = a; h < ye; ++h)switch(o = $e[h].call(Te, e, u, r, c, s, t, i, f, n, l)){\n            case void 0:\n            case false:\n            case true:\n            case null:\n                break;\n            default:\n                u = o;\n        }\n        if (u !== a) return u;\n    }\n    function Qe(e, a, r, c) {\n        for(var s = a + 1; s < r; ++s)switch(c.charCodeAt(s)){\n            case Z:\n                if (e === T) {\n                    if (c.charCodeAt(s - 1) === T && a + 2 !== s) return s + 1;\n                }\n                break;\n            case I:\n                if (e === Z) return s + 1;\n        }\n        return s;\n    }\n    function Re(e) {\n        for(var a in e){\n            var r = e[a];\n            switch(a){\n                case \"keyframe\":\n                    Be = 0 | r;\n                    break;\n                case \"global\":\n                    Ce = 0 | r;\n                    break;\n                case \"cascade\":\n                    ge = 0 | r;\n                    break;\n                case \"compress\":\n                    we = 0 | r;\n                    break;\n                case \"semicolon\":\n                    ve = 0 | r;\n                    break;\n                case \"preserve\":\n                    me = 0 | r;\n                    break;\n                case \"prefix\":\n                    if (Oe = null, !r) Ae = 0;\n                    else if (\"function\" != typeof r) Ae = 1;\n                    else Ae = 2, Oe = r;\n            }\n        }\n        return Re;\n    }\n    function Te(a, r) {\n        if (void 0 !== this && this.constructor === Te) return e(a);\n        var s = a, t = s.charCodeAt(0);\n        if (t < 33) t = (s = s.trim()).charCodeAt(0);\n        if (Be > 0) De = s.replace(d, t === G ? \"\" : \"-\");\n        if (t = 1, 1 === ge) Ge = s;\n        else Ee = s;\n        var i, f = [\n            Ge\n        ];\n        if (ye > 0) {\n            if (void 0 !== (i = Pe(ze, r, f, f, pe, be, 0, 0, 0, 0)) && \"string\" == typeof i) r = i;\n        }\n        var n = He(xe, f, r, 0, 0);\n        if (ye > 0) {\n            if (void 0 !== (i = Pe(je, n, f, f, pe, be, n.length, 0, 0, 0)) && \"string\" != typeof (n = i)) t = 0;\n        }\n        return De = \"\", Ge = \"\", Ee = \"\", ke = 0, pe = 1, be = 1, we * t == 0 ? n : n.replace(c, \"\").replace(g, \"\").replace(A, \"$1\").replace(C, \"$1\").replace(w, \" \");\n    }\n    if (Te.use = function e(a) {\n        switch(a){\n            case void 0:\n            case null:\n                ye = $e.length = 0;\n                break;\n            default:\n                if (\"function\" == typeof a) $e[ye++] = a;\n                else if (\"object\" == typeof a) for(var r = 0, c = a.length; r < c; ++r)e(a[r]);\n                else qe = 0 | !!a;\n        }\n        return e;\n    }, Te.set = Re, void 0 !== a) Re(a);\n    return Te;\n}); //# sourceMappingURL=stylis.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmV0dGVyLXJlYWN0LWNhcm91c2VsL25vZGVfbW9kdWxlcy9zdHlsaXMvc3R5bGlzLm1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxDQUFDLFNBQVNBLENBQUM7SUFBRSxLQUFvREUsR0FBQ0EsT0FBT0QsT0FBTyxHQUFDRCxFQUFFLFFBQU0sQ0FBMkU7QUFBQSxFQUFFLFNBQVNBLEVBQUVPLENBQUM7SUFBRTtJQUFhLElBQUlDLElBQUUsU0FBUUMsSUFBRSxhQUFZQyxJQUFFLFFBQU9DLElBQUUsV0FBVUMsSUFBRSx1QkFBc0JDLElBQUUsc0JBQXFCQyxJQUFFLHNCQUFxQkMsSUFBRSxhQUFZQyxJQUFFLFVBQVNDLElBQUUscUJBQW9CQyxJQUFFLHVEQUFzREMsSUFBRSxRQUFPQyxJQUFFLHNCQUFxQkMsSUFBRSxjQUFhQyxJQUFFLGlCQUFnQkMsSUFBRSxxQkFBb0JDLElBQUUsaUJBQWdCQyxJQUFFLHNCQUFxQkMsSUFBRSxXQUFVQyxJQUFFLGtCQUFpQkMsSUFBRSxzQkFBcUJDLElBQUUsbUJBQWtCQyxJQUFFLGdCQUFlQyxJQUFFLGdCQUFlQyxJQUFFLCtCQUE4QkMsSUFBRSxvQ0FBbUNDLElBQUUsdUJBQXNCQyxJQUFFLFlBQVdDLElBQUUsU0FBUUMsSUFBRSxRQUFPQyxJQUFFLElBQUdDLElBQUUsS0FBSUMsSUFBRSxLQUFJQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLEdBQUVDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLElBQUUsSUFBR0MsSUFBRSxJQUFHQyxJQUFFLElBQUdDLEtBQUcsSUFBR0MsS0FBRyxLQUFJQyxLQUFHLEdBQUVDLEtBQUcsSUFBR0MsS0FBRyxJQUFHQyxLQUFHLEtBQUlDLEtB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QUUsRUFBRUQsRUFBRVIsRUFBRU8sQ0FBQyxDQUFDQyxFQUFFO3FCQUFPcUYsS0FBRyxJQUFFLENBQUMsQ0FBQ3RGO1FBQUM7UUFBQyxPQUFPUDtJQUFDLEdBQUVzRyxHQUFHMEIsR0FBRyxHQUFDM0IsSUFBRyxLQUFLLE1BQUk5RixHQUFFOEYsR0FBRzlGO0lBQUcsT0FBTytGO0FBQUUsSUFDMzFYLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvZGVfY3ViaWNsZV8zLy4vbm9kZV9tb2R1bGVzL2JldHRlci1yZWFjdC1jYXJvdXNlbC9ub2RlX21vZHVsZXMvc3R5bGlzL3N0eWxpcy5taW4uanM/NTA0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZShudWxsKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKGUobnVsbCkpOndpbmRvdy5zdHlsaXM9ZShudWxsKX0oZnVuY3Rpb24gZShhKXtcInVzZSBzdHJpY3RcIjt2YXIgcj0vXlxcMCsvZyxjPS9bXFwwXFxyXFxmXS9nLHM9LzogKi9nLHQ9L3pvb3xncmEvLGk9LyhbLDogXSkodHJhbnNmb3JtKS9nLGY9LywrXFxzKig/IVteKF0qWyldKS9nLG49LyArXFxzKig/IVteKF0qWyldKS9nLGw9LyAqW1xcMF0gKi9nLG89LyxcXHIrPy9nLGg9LyhbXFx0XFxyXFxuIF0pKlxcZj8mL2csdT0vOmdsb2JhbFxcKCgoPzpbXlxcKFxcKVxcW1xcXV0qfFxcWy4qXFxdfFxcKFteXFwoXFwpXSpcXCkpKilcXCkvZyxkPS9cXFcrL2csYj0vQChrXFx3KylcXHMqKFxcUyopXFxzKi8scD0vOjoocGxhY2UpL2csaz0vOihyZWFkLW9ubHkpL2csZz0vXFxzKyg/PVt7XFxdOz06Pl0pL2csQT0vKFtbfT06Pl0pXFxzKy9nLEM9LyhcXHtbXntdKz8pOyg/PVxcfSkvZyx3PS9cXHN7Mix9L2csdj0vKFteXFwoXSkoOispICovZyxtPS9bc3ZoXVxcdystW3RibHJdezJ9Lyx4PS9cXChcXHMqKC4qKVxccypcXCkvZywkPS8oW1xcc1xcU10qPyk7L2cseT0vLXNlbGZ8ZmxleC0vZyxPPS9bXl0qPyg6W3JwXVtlbF1hW1xcdy1dKylbXl0qLyxqPS9zdHJldGNofDpcXHMqXFx3K1xcLSg/OmNvbnRlfGF2YWlsKS8sej0vKFteLV0pKGltYWdlLXNldFxcKCkvLE49XCItd2Via2l0LVwiLFM9XCItbW96LVwiLEY9XCItbXMtXCIsVz01OSxxPTEyNSxCPTEyMyxEPTQwLEU9NDEsRz05MSxIPTkzLEk9MTAsSj0xMyxLPTksTD02NCxNPTMyLFA9MzgsUT00NSxSPTk1LFQ9NDIsVT00NCxWPTU4LFg9MzksWT0zNCxaPTQ3LF89NjIsZWU9NDMsYWU9MTI2LHJlPTAsY2U9MTIsc2U9MTEsdGU9MTA3LGllPTEwOSxmZT0xMTUsbmU9MTEyLGxlPTExMSxvZT0xMDUsaGU9OTksdWU9MTAwLGRlPTExMixiZT0xLHBlPTEsa2U9MCxnZT0xLEFlPTEsQ2U9MSx3ZT0wLHZlPTAsbWU9MCx4ZT1bXSwkZT1bXSx5ZT0wLE9lPW51bGwsamU9LTIsemU9LTEsTmU9MCxTZT0xLEZlPTIsV2U9MyxxZT0wLEJlPTEsRGU9XCJcIixFZT1cIlwiLEdlPVwiXCI7ZnVuY3Rpb24gSGUoZSxhLHMsdCxpKXtmb3IodmFyIGYsbixvPTAsaD0wLHU9MCxkPTAsZz0wLEE9MCxDPTAsdz0wLG09MCwkPTAseT0wLE89MCxqPTAsej0wLFI9MCx3ZT0wLCRlPTAsT2U9MCxqZT0wLHplPXMubGVuZ3RoLEplPXplLTEsUmU9XCJcIixUZT1cIlwiLFVlPVwiXCIsVmU9XCJcIixYZT1cIlwiLFllPVwiXCI7Ujx6ZTspe2lmKEM9cy5jaGFyQ29kZUF0KFIpLFI9PT1KZSlpZihoK2QrdStvIT09MCl7aWYoMCE9PWgpQz1oPT09Wj9JOlo7ZD11PW89MCx6ZSsrLEplKyt9aWYoaCtkK3Urbz09PTApe2lmKFI9PT1KZSl7aWYod2U+MClUZT1UZS5yZXBsYWNlKGMsXCJcIik7aWYoVGUudHJpbSgpLmxlbmd0aD4wKXtzd2l0Y2goQyl7Y2FzZSBNOmNhc2UgSzpjYXNlIFc6Y2FzZSBKOmNhc2UgSTpicmVhaztkZWZhdWx0OlRlKz1zLmNoYXJBdChSKX1DPVd9fWlmKDE9PT0kZSlzd2l0Y2goQyl7Y2FzZSBCOmNhc2UgcTpjYXNlIFc6Y2FzZSBZOmNhc2UgWDpjYXNlIEQ6Y2FzZSBFOmNhc2UgVTokZT0wO2Nhc2UgSzpjYXNlIEo6Y2FzZSBJOmNhc2UgTTpicmVhaztkZWZhdWx0OmZvcigkZT0wLGplPVIsZz1DLFItLSxDPVc7amU8emU7KXN3aXRjaChzLmNoYXJDb2RlQXQoamUrKykpe2Nhc2UgSTpjYXNlIEo6Y2FzZSBXOisrUixDPWcsamU9emU7YnJlYWs7Y2FzZSBWOmlmKHdlPjApKytSLEM9ZztjYXNlIEI6amU9emV9fXN3aXRjaChDKXtjYXNlIEI6Zm9yKGc9KFRlPVRlLnRyaW0oKSkuY2hhckNvZGVBdCgwKSx5PTEsamU9KytSO1I8emU7KXtzd2l0Y2goQz1zLmNoYXJDb2RlQXQoUikpe2Nhc2UgQjp5Kys7YnJlYWs7Y2FzZSBxOnktLTticmVhaztjYXNlIFo6c3dpdGNoKEE9cy5jaGFyQ29kZUF0KFIrMSkpe2Nhc2UgVDpjYXNlIFo6Uj1RZShBLFIsSmUscyl9YnJlYWs7Y2FzZSBHOkMrKztjYXNlIEQ6QysrO2Nhc2UgWTpjYXNlIFg6Zm9yKDtSKys8SmUmJnMuY2hhckNvZGVBdChSKSE9PUM7KTt9aWYoMD09PXkpYnJlYWs7UisrfWlmKFVlPXMuc3Vic3RyaW5nKGplLFIpLGc9PT1yZSlnPShUZT1UZS5yZXBsYWNlKHIsXCJcIikudHJpbSgpKS5jaGFyQ29kZUF0KDApO3N3aXRjaChnKXtjYXNlIEw6aWYod2U+MClUZT1UZS5yZXBsYWNlKGMsXCJcIik7c3dpdGNoKEE9VGUuY2hhckNvZGVBdCgxKSl7Y2FzZSB1ZTpjYXNlIGllOmNhc2UgZmU6Y2FzZSBROmY9YTticmVhaztkZWZhdWx0OmY9eGV9aWYoamU9KFVlPUhlKGEsZixVZSxBLGkrMSkpLmxlbmd0aCxtZT4wJiYwPT09amUpamU9VGUubGVuZ3RoO2lmKHllPjApaWYoZj1JZSh4ZSxUZSxPZSksbj1QZShXZSxVZSxmLGEscGUsYmUsamUsQSxpLHQpLFRlPWYuam9pbihcIlwiKSx2b2lkIDAhPT1uKWlmKDA9PT0oamU9KFVlPW4udHJpbSgpKS5sZW5ndGgpKUE9MCxVZT1cIlwiO2lmKGplPjApc3dpdGNoKEEpe2Nhc2UgZmU6VGU9VGUucmVwbGFjZSh4LE1lKTtjYXNlIHVlOmNhc2UgaWU6Y2FzZSBROlVlPVRlK1wie1wiK1VlK1wifVwiO2JyZWFrO2Nhc2UgdGU6aWYoVWU9KFRlPVRlLnJlcGxhY2UoYixcIiQxICQyXCIrKEJlPjA/RGU6XCJcIikpKStcIntcIitVZStcIn1cIiwxPT09QWV8fDI9PT1BZSYmTGUoXCJAXCIrVWUsMykpVWU9XCJAXCIrTitVZStcIkBcIitVZTtlbHNlIFVlPVwiQFwiK1VlO2JyZWFrO2RlZmF1bHQ6aWYoVWU9VGUrVWUsdD09PWRlKVZlKz1VZSxVZT1cIlwifWVsc2UgVWU9XCJcIjticmVhaztkZWZhdWx0OlVlPUhlKGEsSWUoYSxUZSxPZSksVWUsdCxpKzEpfVhlKz1VZSxPPTAsJGU9MCx6PTAsd2U9MCxPZT0wLGo9MCxUZT1cIlwiLFVlPVwiXCIsQz1zLmNoYXJDb2RlQXQoKytSKTticmVhaztjYXNlIHE6Y2FzZSBXOmlmKChqZT0oVGU9KHdlPjA/VGUucmVwbGFjZShjLFwiXCIpOlRlKS50cmltKCkpLmxlbmd0aCk+MSl7aWYoMD09PXopaWYoKGc9VGUuY2hhckNvZGVBdCgwKSk9PT1RfHxnPjk2JiZnPDEyMylqZT0oVGU9VGUucmVwbGFjZShcIiBcIixcIjpcIikpLmxlbmd0aDtpZih5ZT4wKWlmKHZvaWQgMCE9PShuPVBlKFNlLFRlLGEsZSxwZSxiZSxWZS5sZW5ndGgsdCxpLHQpKSlpZigwPT09KGplPShUZT1uLnRyaW0oKSkubGVuZ3RoKSlUZT1cIlxcMFxcMFwiO3N3aXRjaChnPVRlLmNoYXJDb2RlQXQoMCksQT1UZS5jaGFyQ29kZUF0KDEpLGcpe2Nhc2UgcmU6YnJlYWs7Y2FzZSBMOmlmKEE9PT1vZXx8QT09PWhlKXtZZSs9VGUrcy5jaGFyQXQoUik7YnJlYWt9ZGVmYXVsdDppZihUZS5jaGFyQ29kZUF0KGplLTEpPT09VilicmVhaztWZSs9S2UoVGUsZyxBLFRlLmNoYXJDb2RlQXQoMikpfX1PPTAsJGU9MCx6PTAsd2U9MCxPZT0wLFRlPVwiXCIsQz1zLmNoYXJDb2RlQXQoKytSKX19c3dpdGNoKEMpe2Nhc2UgSjpjYXNlIEk6aWYoaCtkK3Urbyt2ZT09PTApc3dpdGNoKCQpe2Nhc2UgRTpjYXNlIFg6Y2FzZSBZOmNhc2UgTDpjYXNlIGFlOmNhc2UgXzpjYXNlIFQ6Y2FzZSBlZTpjYXNlIFo6Y2FzZSBROmNhc2UgVjpjYXNlIFU6Y2FzZSBXOmNhc2UgQjpjYXNlIHE6YnJlYWs7ZGVmYXVsdDppZih6PjApJGU9MX1pZihoPT09WiloPTA7ZWxzZSBpZihnZStPPT09MCYmdCE9PXRlJiZUZS5sZW5ndGg+MCl3ZT0xLFRlKz1cIlxcMFwiO2lmKHllKnFlPjApUGUoTmUsVGUsYSxlLHBlLGJlLFZlLmxlbmd0aCx0LGksdCk7YmU9MSxwZSsrO2JyZWFrO2Nhc2UgVzpjYXNlIHE6aWYoaCtkK3Urbz09PTApe2JlKys7YnJlYWt9ZGVmYXVsdDpzd2l0Y2goYmUrKyxSZT1zLmNoYXJBdChSKSxDKXtjYXNlIEs6Y2FzZSBNOmlmKGQrbytoPT09MClzd2l0Y2godyl7Y2FzZSBVOmNhc2UgVjpjYXNlIEs6Y2FzZSBNOlJlPVwiXCI7YnJlYWs7ZGVmYXVsdDppZihDIT09TSlSZT1cIiBcIn1icmVhaztjYXNlIHJlOlJlPVwiXFxcXDBcIjticmVhaztjYXNlIGNlOlJlPVwiXFxcXGZcIjticmVhaztjYXNlIHNlOlJlPVwiXFxcXHZcIjticmVhaztjYXNlIFA6aWYoZCtoK289PT0wJiZnZT4wKU9lPTEsd2U9MSxSZT1cIlxcZlwiK1JlO2JyZWFrO2Nhc2UgMTA4OmlmKGQraCtvK2tlPT09MCYmej4wKXN3aXRjaChSLXope2Nhc2UgMjppZih3PT09bmUmJnMuY2hhckNvZGVBdChSLTMpPT09VilrZT13O2Nhc2UgODppZihtPT09bGUpa2U9bX1icmVhaztjYXNlIFY6aWYoZCtoK289PT0wKXo9UjticmVhaztjYXNlIFU6aWYoaCt1K2Qrbz09PTApd2U9MSxSZSs9XCJcXHJcIjticmVhaztjYXNlIFk6Y2FzZSBYOmlmKDA9PT1oKWQ9ZD09PUM/MDowPT09ZD9DOmQ7YnJlYWs7Y2FzZSBHOmlmKGQraCt1PT09MClvKys7YnJlYWs7Y2FzZSBIOmlmKGQraCt1PT09MClvLS07YnJlYWs7Y2FzZSBFOmlmKGQraCtvPT09MCl1LS07YnJlYWs7Y2FzZSBEOmlmKGQraCtvPT09MCl7aWYoMD09PU8pc3dpdGNoKDIqdyszKm0pe2Nhc2UgNTMzOmJyZWFrO2RlZmF1bHQ6eT0wLE89MX11Kyt9YnJlYWs7Y2FzZSBMOmlmKGgrdStkK28reitqPT09MClqPTE7YnJlYWs7Y2FzZSBUOmNhc2UgWjppZihkK28rdT4wKWJyZWFrO3N3aXRjaChoKXtjYXNlIDA6c3dpdGNoKDIqQyszKnMuY2hhckNvZGVBdChSKzEpKXtjYXNlIDIzNTpoPVo7YnJlYWs7Y2FzZSAyMjA6amU9UixoPVR9YnJlYWs7Y2FzZSBUOmlmKEM9PT1aJiZ3PT09VCYmamUrMiE9PVIpe2lmKDMzPT09cy5jaGFyQ29kZUF0KGplKzIpKVZlKz1zLnN1YnN0cmluZyhqZSxSKzEpO1JlPVwiXCIsaD0wfX19aWYoMD09PWgpe2lmKGdlK2QrbytqPT09MCYmdCE9PXRlJiZDIT09Vylzd2l0Y2goQyl7Y2FzZSBVOmNhc2UgYWU6Y2FzZSBfOmNhc2UgZWU6Y2FzZSBFOmNhc2UgRDppZigwPT09Tyl7c3dpdGNoKHcpe2Nhc2UgSzpjYXNlIE06Y2FzZSBJOmNhc2UgSjpSZSs9XCJcXDBcIjticmVhaztkZWZhdWx0OlJlPVwiXFwwXCIrUmUrKEM9PT1VP1wiXCI6XCJcXDBcIil9d2U9MX1lbHNlIHN3aXRjaChDKXtjYXNlIEQ6aWYoeis3PT09UiYmMTA4PT09dyl6PTA7Tz0rK3k7YnJlYWs7Y2FzZSBFOmlmKDA9PShPPS0teSkpd2U9MSxSZSs9XCJcXDBcIn1icmVhaztjYXNlIEs6Y2FzZSBNOnN3aXRjaCh3KXtjYXNlIHJlOmNhc2UgQjpjYXNlIHE6Y2FzZSBXOmNhc2UgVTpjYXNlIGNlOmNhc2UgSzpjYXNlIE06Y2FzZSBJOmNhc2UgSjpicmVhaztkZWZhdWx0OmlmKDA9PT1PKXdlPTEsUmUrPVwiXFwwXCJ9fWlmKFRlKz1SZSxDIT09TSYmQyE9PUspJD1DfX1tPXcsdz1DLFIrK31pZihqZT1WZS5sZW5ndGgsbWU+MClpZigwPT09amUmJjA9PT1YZS5sZW5ndGgmJjA9PT1hWzBdLmxlbmd0aD09ZmFsc2UpaWYodCE9PWllfHwxPT09YS5sZW5ndGgmJihnZT4wP0VlOkdlKT09PWFbMF0pamU9YS5qb2luKFwiLFwiKS5sZW5ndGgrMjtpZihqZT4wKXtpZihmPTA9PT1nZSYmdCE9PXRlP2Z1bmN0aW9uKGUpe2Zvcih2YXIgYSxyLHM9MCx0PWUubGVuZ3RoLGk9QXJyYXkodCk7czx0Oysrcyl7Zm9yKHZhciBmPWVbc10uc3BsaXQobCksbj1cIlwiLG89MCxoPTAsdT0wLGQ9MCxiPWYubGVuZ3RoO288YjsrK28pe2lmKDA9PT0oaD0ocj1mW29dKS5sZW5ndGgpJiZiPjEpY29udGludWU7aWYodT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSksZD1yLmNoYXJDb2RlQXQoMCksYT1cIlwiLDAhPT1vKXN3aXRjaCh1KXtjYXNlIFQ6Y2FzZSBhZTpjYXNlIF86Y2FzZSBlZTpjYXNlIE06Y2FzZSBEOmJyZWFrO2RlZmF1bHQ6YT1cIiBcIn1zd2l0Y2goZCl7Y2FzZSBQOnI9YStFZTtjYXNlIGFlOmNhc2UgXzpjYXNlIGVlOmNhc2UgTTpjYXNlIEU6Y2FzZSBEOmJyZWFrO2Nhc2UgRzpyPWErcitFZTticmVhaztjYXNlIFY6c3dpdGNoKDIqci5jaGFyQ29kZUF0KDEpKzMqci5jaGFyQ29kZUF0KDIpKXtjYXNlIDUzMDppZihDZT4wKXtyPWErci5zdWJzdHJpbmcoOCxoLTEpO2JyZWFrfWRlZmF1bHQ6aWYobzwxfHxmW28tMV0ubGVuZ3RoPDEpcj1hK0VlK3J9YnJlYWs7Y2FzZSBVOmE9XCJcIjtkZWZhdWx0OmlmKGg+MSYmci5pbmRleE9mKFwiOlwiKT4wKXI9YStyLnJlcGxhY2UodixcIiQxXCIrRWUrXCIkMlwiKTtlbHNlIHI9YStyK0VlfW4rPXJ9aVtzXT1uLnJlcGxhY2UoYyxcIlwiKS50cmltKCl9cmV0dXJuIGl9KGEpOmEseWU+MClpZih2b2lkIDAhPT0obj1QZShGZSxWZSxmLGUscGUsYmUsamUsdCxpLHQpKSYmMD09PShWZT1uKS5sZW5ndGgpcmV0dXJuIFllK1ZlK1hlO2lmKFZlPWYuam9pbihcIixcIikrXCJ7XCIrVmUrXCJ9XCIsQWUqa2UhPTApe2lmKDI9PT1BZSYmIUxlKFZlLDIpKWtlPTA7c3dpdGNoKGtlKXtjYXNlIGxlOlZlPVZlLnJlcGxhY2UoayxcIjpcIitTK1wiJDFcIikrVmU7YnJlYWs7Y2FzZSBuZTpWZT1WZS5yZXBsYWNlKHAsXCI6OlwiK04rXCJpbnB1dC0kMVwiKStWZS5yZXBsYWNlKHAsXCI6OlwiK1MrXCIkMVwiKStWZS5yZXBsYWNlKHAsXCI6XCIrRitcImlucHV0LSQxXCIpK1ZlfWtlPTB9fXJldHVybiBZZStWZStYZX1mdW5jdGlvbiBJZShlLGEscil7dmFyIGM9YS50cmltKCkuc3BsaXQobykscz1jLHQ9Yy5sZW5ndGgsaT1lLmxlbmd0aDtzd2l0Y2goaSl7Y2FzZSAwOmNhc2UgMTpmb3IodmFyIGY9MCxuPTA9PT1pP1wiXCI6ZVswXStcIiBcIjtmPHQ7KytmKXNbZl09SmUobixzW2ZdLHIsaSkudHJpbSgpO2JyZWFrO2RlZmF1bHQ6Zj0wO3ZhciBsPTA7Zm9yKHM9W107Zjx0OysrZilmb3IodmFyIGg9MDtoPGk7KytoKXNbbCsrXT1KZShlW2hdK1wiIFwiLGNbZl0scixpKS50cmltKCl9cmV0dXJuIHN9ZnVuY3Rpb24gSmUoZSxhLHIsYyl7dmFyIHM9YSx0PXMuY2hhckNvZGVBdCgwKTtpZih0PDMzKXQ9KHM9cy50cmltKCkpLmNoYXJDb2RlQXQoMCk7c3dpdGNoKHQpe2Nhc2UgUDpzd2l0Y2goZ2UrYyl7Y2FzZSAwOmNhc2UgMTppZigwPT09ZS50cmltKCkubGVuZ3RoKWJyZWFrO2RlZmF1bHQ6cmV0dXJuIHMucmVwbGFjZShoLFwiJDFcIitlLnRyaW0oKSl9YnJlYWs7Y2FzZSBWOnN3aXRjaChzLmNoYXJDb2RlQXQoMSkpe2Nhc2UgMTAzOmlmKENlPjAmJmdlPjApcmV0dXJuIHMucmVwbGFjZSh1LFwiJDFcIikucmVwbGFjZShoLFwiJDFcIitHZSk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gZS50cmltKCkrcy5yZXBsYWNlKGgsXCIkMVwiK2UudHJpbSgpKX1kZWZhdWx0OmlmKHIqZ2U+MCYmcy5pbmRleE9mKFwiXFxmXCIpPjApcmV0dXJuIHMucmVwbGFjZShoLChlLmNoYXJDb2RlQXQoMCk9PT1WP1wiXCI6XCIkMVwiKStlLnRyaW0oKSl9cmV0dXJuIGUrc31mdW5jdGlvbiBLZShlLGEscixjKXt2YXIgbCxvPTAsaD1lK1wiO1wiLHU9MiphKzMqcis0KmM7aWYoOTQ0PT09dSlyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIGE9ZS5sZW5ndGgscj1lLmluZGV4T2YoXCI6XCIsOSkrMSxjPWUuc3Vic3RyaW5nKDAscikudHJpbSgpLHM9ZS5zdWJzdHJpbmcocixhLTEpLnRyaW0oKTtzd2l0Y2goZS5jaGFyQ29kZUF0KDkpKkJlKXtjYXNlIDA6YnJlYWs7Y2FzZSBROmlmKDExMCE9PWUuY2hhckNvZGVBdCgxMCkpYnJlYWs7ZGVmYXVsdDpmb3IodmFyIHQ9cy5zcGxpdCgocz1cIlwiLGYpKSxpPTAscj0wLGE9dC5sZW5ndGg7aTxhO3I9MCwrK2kpe2Zvcih2YXIgbD10W2ldLG89bC5zcGxpdChuKTtsPW9bcl07KXt2YXIgaD1sLmNoYXJDb2RlQXQoMCk7aWYoMT09PUJlJiYoaD5MJiZoPDkwfHxoPjk2JiZoPDEyM3x8aD09PVJ8fGg9PT1RJiZsLmNoYXJDb2RlQXQoMSkhPT1RKSlzd2l0Y2goaXNOYU4ocGFyc2VGbG9hdChsKSkrKC0xIT09bC5pbmRleE9mKFwiKFwiKSkpe2Nhc2UgMTpzd2l0Y2gobCl7Y2FzZVwiaW5maW5pdGVcIjpjYXNlXCJhbHRlcm5hdGVcIjpjYXNlXCJiYWNrd2FyZHNcIjpjYXNlXCJydW5uaW5nXCI6Y2FzZVwibm9ybWFsXCI6Y2FzZVwiZm9yd2FyZHNcIjpjYXNlXCJib3RoXCI6Y2FzZVwibm9uZVwiOmNhc2VcImxpbmVhclwiOmNhc2VcImVhc2VcIjpjYXNlXCJlYXNlLWluXCI6Y2FzZVwiZWFzZS1vdXRcIjpjYXNlXCJlYXNlLWluLW91dFwiOmNhc2VcInBhdXNlZFwiOmNhc2VcInJldmVyc2VcIjpjYXNlXCJhbHRlcm5hdGUtcmV2ZXJzZVwiOmNhc2VcImluaGVyaXRcIjpjYXNlXCJpbml0aWFsXCI6Y2FzZVwidW5zZXRcIjpjYXNlXCJzdGVwLXN0YXJ0XCI6Y2FzZVwic3RlcC1lbmRcIjpicmVhaztkZWZhdWx0OmwrPURlfX1vW3IrK109bH1zKz0oMD09PWk/XCJcIjpcIixcIikrby5qb2luKFwiIFwiKX19aWYocz1jK3MrXCI7XCIsMT09PUFlfHwyPT09QWUmJkxlKHMsMSkpcmV0dXJuIE4rcytzO3JldHVybiBzfShoKTtlbHNlIGlmKDA9PT1BZXx8Mj09PUFlJiYhTGUoaCwxKSlyZXR1cm4gaDtzd2l0Y2godSl7Y2FzZSAxMDE1OnJldHVybiA5Nz09PWguY2hhckNvZGVBdCgxMCk/TitoK2g6aDtjYXNlIDk1MTpyZXR1cm4gMTE2PT09aC5jaGFyQ29kZUF0KDMpP04raCtoOmg7Y2FzZSA5NjM6cmV0dXJuIDExMD09PWguY2hhckNvZGVBdCg1KT9OK2graDpoO2Nhc2UgMTAwOTppZigxMDAhPT1oLmNoYXJDb2RlQXQoNCkpYnJlYWs7Y2FzZSA5Njk6Y2FzZSA5NDI6cmV0dXJuIE4raCtoO2Nhc2UgOTc4OnJldHVybiBOK2grUytoK2g7Y2FzZSAxMDE5OmNhc2UgOTgzOnJldHVybiBOK2grUytoK0YraCtoO2Nhc2UgODgzOmlmKGguY2hhckNvZGVBdCg4KT09PVEpcmV0dXJuIE4raCtoO2lmKGguaW5kZXhPZihcImltYWdlLXNldChcIiwxMSk+MClyZXR1cm4gaC5yZXBsYWNlKHosXCIkMVwiK04rXCIkMlwiKStoO3JldHVybiBoO2Nhc2UgOTMyOmlmKGguY2hhckNvZGVBdCg0KT09PVEpc3dpdGNoKGguY2hhckNvZGVBdCg1KSl7Y2FzZSAxMDM6cmV0dXJuIE4rXCJib3gtXCIraC5yZXBsYWNlKFwiLWdyb3dcIixcIlwiKStOK2grRitoLnJlcGxhY2UoXCJncm93XCIsXCJwb3NpdGl2ZVwiKStoO2Nhc2UgMTE1OnJldHVybiBOK2grRitoLnJlcGxhY2UoXCJzaHJpbmtcIixcIm5lZ2F0aXZlXCIpK2g7Y2FzZSA5ODpyZXR1cm4gTitoK0YraC5yZXBsYWNlKFwiYmFzaXNcIixcInByZWZlcnJlZC1zaXplXCIpK2h9cmV0dXJuIE4raCtGK2graDtjYXNlIDk2NDpyZXR1cm4gTitoK0YrXCJmbGV4LVwiK2graDtjYXNlIDEwMjM6aWYoOTkhPT1oLmNoYXJDb2RlQXQoOCkpYnJlYWs7cmV0dXJuIGw9aC5zdWJzdHJpbmcoaC5pbmRleE9mKFwiOlwiLDE1KSkucmVwbGFjZShcImZsZXgtXCIsXCJcIikucmVwbGFjZShcInNwYWNlLWJldHdlZW5cIixcImp1c3RpZnlcIiksTitcImJveC1wYWNrXCIrbCtOK2grRitcImZsZXgtcGFja1wiK2wraDtjYXNlIDEwMDU6cmV0dXJuIHQudGVzdChoKT9oLnJlcGxhY2UocyxcIjpcIitOKStoLnJlcGxhY2UocyxcIjpcIitTKStoOmg7Y2FzZSAxZTM6c3dpdGNoKG89KGw9aC5zdWJzdHJpbmcoMTMpLnRyaW0oKSkuaW5kZXhPZihcIi1cIikrMSxsLmNoYXJDb2RlQXQoMCkrbC5jaGFyQ29kZUF0KG8pKXtjYXNlIDIyNjpsPWgucmVwbGFjZShtLFwidGJcIik7YnJlYWs7Y2FzZSAyMzI6bD1oLnJlcGxhY2UobSxcInRiLXJsXCIpO2JyZWFrO2Nhc2UgMjIwOmw9aC5yZXBsYWNlKG0sXCJsclwiKTticmVhaztkZWZhdWx0OnJldHVybiBofXJldHVybiBOK2grRitsK2g7Y2FzZSAxMDE3OmlmKC0xPT09aC5pbmRleE9mKFwic3RpY2t5XCIsOSkpcmV0dXJuIGg7Y2FzZSA5NzU6c3dpdGNoKG89KGg9ZSkubGVuZ3RoLTEwLHU9KGw9KDMzPT09aC5jaGFyQ29kZUF0KG8pP2guc3Vic3RyaW5nKDAsbyk6aCkuc3Vic3RyaW5nKGUuaW5kZXhPZihcIjpcIiw3KSsxKS50cmltKCkpLmNoYXJDb2RlQXQoMCkrKDB8bC5jaGFyQ29kZUF0KDcpKSl7Y2FzZSAyMDM6aWYobC5jaGFyQ29kZUF0KDgpPDExMSlicmVhaztjYXNlIDExNTpoPWgucmVwbGFjZShsLE4rbCkrXCI7XCIraDticmVhaztjYXNlIDIwNzpjYXNlIDEwMjpoPWgucmVwbGFjZShsLE4rKHU+MTAyP1wiaW5saW5lLVwiOlwiXCIpK1wiYm94XCIpK1wiO1wiK2gucmVwbGFjZShsLE4rbCkrXCI7XCIraC5yZXBsYWNlKGwsRitsK1wiYm94XCIpK1wiO1wiK2h9cmV0dXJuIGgrXCI7XCI7Y2FzZSA5Mzg6aWYoaC5jaGFyQ29kZUF0KDUpPT09USlzd2l0Y2goaC5jaGFyQ29kZUF0KDYpKXtjYXNlIDEwNTpyZXR1cm4gbD1oLnJlcGxhY2UoXCItaXRlbXNcIixcIlwiKSxOK2grTitcImJveC1cIitsK0YrXCJmbGV4LVwiK2wraDtjYXNlIDExNTpyZXR1cm4gTitoK0YrXCJmbGV4LWl0ZW0tXCIraC5yZXBsYWNlKHksXCJcIikraDtkZWZhdWx0OnJldHVybiBOK2grRitcImZsZXgtbGluZS1wYWNrXCIraC5yZXBsYWNlKFwiYWxpZ24tY29udGVudFwiLFwiXCIpLnJlcGxhY2UoeSxcIlwiKStofWJyZWFrO2Nhc2UgOTczOmNhc2UgOTg5OmlmKGguY2hhckNvZGVBdCgzKSE9PVF8fDEyMj09PWguY2hhckNvZGVBdCg0KSlicmVhaztjYXNlIDkzMTpjYXNlIDk1MzppZih0cnVlPT09ai50ZXN0KGUpKWlmKDExNT09PShsPWUuc3Vic3RyaW5nKGUuaW5kZXhPZihcIjpcIikrMSkpLmNoYXJDb2RlQXQoMCkpcmV0dXJuIEtlKGUucmVwbGFjZShcInN0cmV0Y2hcIixcImZpbGwtYXZhaWxhYmxlXCIpLGEscixjKS5yZXBsYWNlKFwiOmZpbGwtYXZhaWxhYmxlXCIsXCI6c3RyZXRjaFwiKTtlbHNlIHJldHVybiBoLnJlcGxhY2UobCxOK2wpK2gucmVwbGFjZShsLFMrbC5yZXBsYWNlKFwiZmlsbC1cIixcIlwiKSkraDticmVhaztjYXNlIDk2MjppZihoPU4raCsoMTAyPT09aC5jaGFyQ29kZUF0KDUpP0YraDpcIlwiKStoLHIrYz09PTIxMSYmMTA1PT09aC5jaGFyQ29kZUF0KDEzKSYmaC5pbmRleE9mKFwidHJhbnNmb3JtXCIsMTApPjApcmV0dXJuIGguc3Vic3RyaW5nKDAsaC5pbmRleE9mKFwiO1wiLDI3KSsxKS5yZXBsYWNlKGksXCIkMVwiK04rXCIkMlwiKStofXJldHVybiBofWZ1bmN0aW9uIExlKGUsYSl7dmFyIHI9ZS5pbmRleE9mKDE9PT1hP1wiOlwiOlwie1wiKSxjPWUuc3Vic3RyaW5nKDAsMyE9PWE/cjoxMCkscz1lLnN1YnN0cmluZyhyKzEsZS5sZW5ndGgtMSk7cmV0dXJuIE9lKDIhPT1hP2M6Yy5yZXBsYWNlKE8sXCIkMVwiKSxzLGEpfWZ1bmN0aW9uIE1lKGUsYSl7dmFyIHI9S2UoYSxhLmNoYXJDb2RlQXQoMCksYS5jaGFyQ29kZUF0KDEpLGEuY2hhckNvZGVBdCgyKSk7cmV0dXJuIHIhPT1hK1wiO1wiP3IucmVwbGFjZSgkLFwiIG9yICgkMSlcIikuc3Vic3RyaW5nKDQpOlwiKFwiK2ErXCIpXCJ9ZnVuY3Rpb24gUGUoZSxhLHIsYyxzLHQsaSxmLG4sbCl7Zm9yKHZhciBvLGg9MCx1PWE7aDx5ZTsrK2gpc3dpdGNoKG89JGVbaF0uY2FsbChUZSxlLHUscixjLHMsdCxpLGYsbixsKSl7Y2FzZSB2b2lkIDA6Y2FzZSBmYWxzZTpjYXNlIHRydWU6Y2FzZSBudWxsOmJyZWFrO2RlZmF1bHQ6dT1vfWlmKHUhPT1hKXJldHVybiB1fWZ1bmN0aW9uIFFlKGUsYSxyLGMpe2Zvcih2YXIgcz1hKzE7czxyOysrcylzd2l0Y2goYy5jaGFyQ29kZUF0KHMpKXtjYXNlIFo6aWYoZT09PVQpaWYoYy5jaGFyQ29kZUF0KHMtMSk9PT1UJiZhKzIhPT1zKXJldHVybiBzKzE7YnJlYWs7Y2FzZSBJOmlmKGU9PT1aKXJldHVybiBzKzF9cmV0dXJuIHN9ZnVuY3Rpb24gUmUoZSl7Zm9yKHZhciBhIGluIGUpe3ZhciByPWVbYV07c3dpdGNoKGEpe2Nhc2VcImtleWZyYW1lXCI6QmU9MHxyO2JyZWFrO2Nhc2VcImdsb2JhbFwiOkNlPTB8cjticmVhaztjYXNlXCJjYXNjYWRlXCI6Z2U9MHxyO2JyZWFrO2Nhc2VcImNvbXByZXNzXCI6d2U9MHxyO2JyZWFrO2Nhc2VcInNlbWljb2xvblwiOnZlPTB8cjticmVhaztjYXNlXCJwcmVzZXJ2ZVwiOm1lPTB8cjticmVhaztjYXNlXCJwcmVmaXhcIjppZihPZT1udWxsLCFyKUFlPTA7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKUFlPTE7ZWxzZSBBZT0yLE9lPXJ9fXJldHVybiBSZX1mdW5jdGlvbiBUZShhLHIpe2lmKHZvaWQgMCE9PXRoaXMmJnRoaXMuY29uc3RydWN0b3I9PT1UZSlyZXR1cm4gZShhKTt2YXIgcz1hLHQ9cy5jaGFyQ29kZUF0KDApO2lmKHQ8MzMpdD0ocz1zLnRyaW0oKSkuY2hhckNvZGVBdCgwKTtpZihCZT4wKURlPXMucmVwbGFjZShkLHQ9PT1HP1wiXCI6XCItXCIpO2lmKHQ9MSwxPT09Z2UpR2U9cztlbHNlIEVlPXM7dmFyIGksZj1bR2VdO2lmKHllPjApaWYodm9pZCAwIT09KGk9UGUoemUscixmLGYscGUsYmUsMCwwLDAsMCkpJiZcInN0cmluZ1wiPT10eXBlb2YgaSlyPWk7dmFyIG49SGUoeGUsZixyLDAsMCk7aWYoeWU+MClpZih2b2lkIDAhPT0oaT1QZShqZSxuLGYsZixwZSxiZSxuLmxlbmd0aCwwLDAsMCkpJiZcInN0cmluZ1wiIT10eXBlb2Yobj1pKSl0PTA7cmV0dXJuIERlPVwiXCIsR2U9XCJcIixFZT1cIlwiLGtlPTAscGU9MSxiZT0xLHdlKnQ9PTA/bjpuLnJlcGxhY2UoYyxcIlwiKS5yZXBsYWNlKGcsXCJcIikucmVwbGFjZShBLFwiJDFcIikucmVwbGFjZShDLFwiJDFcIikucmVwbGFjZSh3LFwiIFwiKX1pZihUZS51c2U9ZnVuY3Rpb24gZShhKXtzd2l0Y2goYSl7Y2FzZSB2b2lkIDA6Y2FzZSBudWxsOnllPSRlLmxlbmd0aD0wO2JyZWFrO2RlZmF1bHQ6aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgYSkkZVt5ZSsrXT1hO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGEpZm9yKHZhciByPTAsYz1hLmxlbmd0aDtyPGM7KytyKWUoYVtyXSk7ZWxzZSBxZT0wfCEhYX1yZXR1cm4gZX0sVGUuc2V0PVJlLHZvaWQgMCE9PWEpUmUoYSk7cmV0dXJuIFRlfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsaXMubWluLmpzLm1hcCJdLCJuYW1lcyI6WyJlIiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIndpbmRvdyIsInN0eWxpcyIsImEiLCJyIiwiYyIsInMiLCJ0IiwiaSIsImYiLCJuIiwibCIsIm8iLCJoIiwidSIsImQiLCJiIiwicCIsImsiLCJnIiwiQSIsIkMiLCJ3IiwidiIsIm0iLCJ4IiwiJCIsInkiLCJPIiwiaiIsInoiLCJOIiwiUyIsIkYiLCJXIiwicSIsIkIiLCJEIiwiRSIsIkciLCJIIiwiSSIsIkoiLCJLIiwiTCIsIk0iLCJQIiwiUSIsIlIiLCJUIiwiVSIsIlYiLCJYIiwiWSIsIloiLCJfIiwiZWUiLCJhZSIsInJlIiwiY2UiLCJzZSIsInRlIiwiaWUiLCJmZSIsIm5lIiwibGUiLCJvZSIsImhlIiwidWUiLCJkZSIsImJlIiwicGUiLCJrZSIsImdlIiwiQWUiLCJDZSIsIndlIiwidmUiLCJtZSIsInhlIiwiJGUiLCJ5ZSIsIk9lIiwiamUiLCJ6ZSIsIk5lIiwiU2UiLCJGZSIsIldlIiwicWUiLCJCZSIsIkRlIiwiRWUiLCJHZSIsIkhlIiwibGVuZ3RoIiwiSmUiLCJSZSIsIlRlIiwiVWUiLCJWZSIsIlhlIiwiWWUiLCJjaGFyQ29kZUF0IiwicmVwbGFjZSIsInRyaW0iLCJjaGFyQXQiLCJRZSIsInN1YnN0cmluZyIsIkllIiwiUGUiLCJqb2luIiwiTWUiLCJMZSIsIktlIiwiQXJyYXkiLCJzcGxpdCIsImluZGV4T2YiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJ0ZXN0IiwiY2FsbCIsImNvbnN0cnVjdG9yIiwidXNlIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/better-react-carousel/node_modules/stylis/stylis.min.js\n");

/***/ })

};
;